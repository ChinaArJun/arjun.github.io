(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{623:function(t,n,a){"use strict";a.r(n);var e=a(44),r=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_1-6-来，控制一下-goroutine-的并发数量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-来，控制一下-goroutine-的并发数量"}},[t._v("#")]),t._v(" 1.6 来，控制一下 goroutine 的并发数量")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/dGQVT1x.jpg",alt:"image"}})]),t._v(" "),a("h2",{attrs:{id:"问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('func main() {\n\tuserCount := math.MaxInt64\n\tfor i := 0; i < userCount; i++ {\n\t\tgo func(i int) {\n\t\t    // 做一些各种各样的业务逻辑处理\n\t\t\tfmt.Printf("go func: %d\\n", i)\n\t\t\ttime.Sleep(time.Second)\n\t\t}(i)\n\t}\n}\n')])])]),a("p",[t._v("在这里，假设 "),a("code",[t._v("userCount")]),t._v(" 是一个外部传入的参数（不可预测，有可能值非常大），有人会全部丢进去循环。想着全部都并发 goroutine 去同时做某一件事。觉得这样子会效率会更高，对不对！")]),t._v(" "),a("p",[t._v("那么，你觉得这里有没有什么问题？")]),t._v(" "),a("h2",{attrs:{id:"噩梦般的开始"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#噩梦般的开始"}},[t._v("#")]),t._v(" 噩梦般的开始")]),t._v(" "),a("p",[t._v("当然，在"),a("strong",[t._v("特定场景下")]),t._v("，问题可大了。因为在本文被丢进去同时并发的可是一个极端值。我们可以一起观察下图的指标分析，看看情况有多 “崩溃”。下图是上述代码的表现：")]),t._v(" "),a("h3",{attrs:{id:"输出结果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输出结果"}},[t._v("#")]),t._v(" 输出结果")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("...\ngo func: 5839\ngo func: 5840\ngo func: 5841\ngo func: 5842\ngo func: 5915\ngo func: 5524\ngo func: 5916\ngo func: 8209\ngo func: 8264\nsignal: killed\n")])])]),a("p",[t._v("如果你自己执行过代码，在 “输出结果” 上你会遇到如下问题：")]),t._v(" "),a("ul",[a("li",[t._v("系统资源占用率不断上涨")]),t._v(" "),a("li",[t._v("输出一定数量后：控制台就不再刷新输出最新的值了")]),t._v(" "),a("li",[t._v("信号量：signal: killed")])]),t._v(" "),a("h3",{attrs:{id:"系统负载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统负载"}},[t._v("#")]),t._v(" 系统负载")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/bZjQ2ey.jpg",alt:"image"}})]),t._v(" "),a("h3",{attrs:{id:"cpu"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu"}},[t._v("#")]),t._v(" CPU")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/zxXSgaP.jpg",alt:"image"}})]),t._v(" "),a("p",[t._v("短时间内系统负载暴增")]),t._v(" "),a("h3",{attrs:{id:"虚拟内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[t._v("#")]),t._v(" 虚拟内存")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/xYZO9cE.jpg",alt:"image"}})]),t._v(" "),a("p",[t._v("短时间内占用的虚拟内存暴增")]),t._v(" "),a("h3",{attrs:{id:"top"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#top"}},[t._v("#")]),t._v(" top")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("PID    COMMAND      %CPU  TIME     #TH   #WQ  #PORT MEM    PURG   CMPRS  PGRP  PPID  STATE    BOOSTS\n...\n73414  test         100.2 01:59.50 9/1   0    18    6801M+ 0B     114G+  73403 73403 running  *0[1]\n")])])]),a("h3",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("如果仔细看过监控工具的示意图，就可以知道其实我间隔的执行了两次，能看到系统间的使用率幅度非常大。当进程被杀掉后，整体又恢复为正常值")]),t._v(" "),a("p",[t._v("在这里，我们回到主题，就是在"),a("strong",[t._v("不控制并发的 goroutine 数量")]),t._v(" 会发生什么问题？大致如下：")]),t._v(" "),a("ul",[a("li",[t._v("CPU 使用率浮动上涨")]),t._v(" "),a("li",[t._v("Memory 占用不断上涨。也可以看看 CMPRS，它表示进程的压缩数据的字节数。已经到达 114G+ 了")]),t._v(" "),a("li",[t._v("主进程崩溃（被杀掉了）")])]),t._v(" "),a("p",[t._v("简单来说，“崩溃” 的原因就是对系统资源的占用过大。常见的比如：打开文件数（too many files open）、内存占用等等")]),t._v(" "),a("h3",{attrs:{id:"危害"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#危害"}},[t._v("#")]),t._v(" 危害")]),t._v(" "),a("p",[t._v("对该台服务器产生非常大的影响，影响自身及相关联的应用。很有可能导致不可用或响应缓慢，另外启动了复数 “失控” 的 goroutine，导致程序流转混乱")]),t._v(" "),a("h2",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),a("p",[t._v("在前面花了大量篇幅，渲染了在存在大量并发 goroutine 数量时，不控制的话会出现 “严重” 的问题，接下来一起思考下解决方案。如下：")]),t._v(" "),a("ol",[a("li",[t._v("控制/限制 goroutine 同时并发运行的数量")]),t._v(" "),a("li",[t._v("改变应用程序的逻辑写法（避免大规模的使用系统资源和等待）")]),t._v(" "),a("li",[a("s",[t._v("调整服务的硬件配置、最大打开数、内存等阈值")])])]),t._v(" "),a("h2",{attrs:{id:"控制-goroutine-并发数量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制-goroutine-并发数量"}},[t._v("#")]),t._v(" 控制 goroutine 并发数量")]),t._v(" "),a("p",[t._v("接下来正式的开始解决这个问题，希望你认真阅读的同时加以思考，因为这个问题在实际项目中真的是太常见了！")]),t._v(" "),a("p",[t._v("问题已经抛出来了，你需要做的是"),a("strong",[t._v("想想有什么办法")]),t._v("解决这个问题。建议你自行思考一下技术方案。再接着往下看 😃")]),t._v(" "),a("h3",{attrs:{id:"尝试-chan"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尝试-chan"}},[t._v("#")]),t._v(" 尝试 chan")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('func main() {\n\tuserCount := 10\n\tch := make(chan bool, 2)\n\tfor i := 0; i < userCount; i++ {\n\t\tch <- true\n\t\tgo Read(ch, i)\n\t}\n\t\n\t//time.Sleep(time.Second)\n}\n\nfunc Read(ch chan bool, i int) {\n\tfmt.Printf("go func: %d\\n", i)\n\t<- ch\n}\n')])])]),a("p",[t._v("输出结果：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("go func: 1\ngo func: 2\ngo func: 3\ngo func: 4\ngo func: 5\ngo func: 6\ngo func: 7\ngo func: 8\ngo func: 0\n")])])]),a("p",[t._v("嗯，我们似乎很好的控制了 2 个 2 个的 “顺序” 执行多个 goroutine。但是，问题出现了。你仔细数一下输出结果，才 9 个值？")]),t._v(" "),a("p",[t._v("这明显就不对。原因出在当主协程结束时，子协程也是会被终止掉的。因此剩余的 goroutine 没来及把值输出，就被送上路了（不信你把 "),a("code",[t._v("time.Sleep")]),t._v(" 打开看看，看看输出数量）")]),t._v(" "),a("h3",{attrs:{id:"尝试-sync"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尝试-sync"}},[t._v("#")]),t._v(" 尝试 sync")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('...\nvar wg = sync.WaitGroup{}\n\nfunc main() {\n\tuserCount := 10\n\tfor i := 0; i < userCount; i++ {\n\t\twg.Add(1)\n\t\tgo Read(i)\n\t}\n\n\twg.Wait()\n}\n\nfunc Read(i int) {\n\tdefer wg.Done()\n\tfmt.Printf("go func: %d\\n", i)\n}\n')])])]),a("p",[t._v("嗯，单纯的使用 "),a("code",[t._v("sync.WaitGroup")]),t._v(" 也不行。没有控制到同时并发的 goroutine 数量（代指达不到本文所要求的目标）")]),t._v(" "),a("h4",{attrs:{id:"小结-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结-2"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("单纯"),a("strong",[t._v("简单")]),t._v("使用 channel 或 sync 都有明显缺陷，不行。我们再看看组件配合能不能实现")]),t._v(" "),a("h3",{attrs:{id:"尝试-chan-sync"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尝试-chan-sync"}},[t._v("#")]),t._v(" 尝试 chan + sync")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('...\nvar wg = sync.WaitGroup{}\n\nfunc main() {\n\tuserCount := 10\n\tch := make(chan bool, 2)\n\tfor i := 0; i < userCount; i++ {\n\t\twg.Add(1)\n\t\tgo Read(ch, i)\n\t}\n\n\twg.Wait()\n}\n\nfunc Read(ch chan bool, i int) {\n\tdefer wg.Done()\n\n\tch <- true\n\tfmt.Printf("go func: %d, time: %d\\n", i, time.Now().Unix())\n\ttime.Sleep(time.Second)\n\t<-ch\n}\n')])])]),a("p",[t._v("输出结果：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("go func: 9, time: 1547911938\ngo func: 1, time: 1547911938\ngo func: 6, time: 1547911939\ngo func: 7, time: 1547911939\ngo func: 8, time: 1547911940\ngo func: 0, time: 1547911940\ngo func: 3, time: 1547911941\ngo func: 2, time: 1547911941\ngo func: 4, time: 1547911942\ngo func: 5, time: 1547911942\n")])])]),a("p",[t._v("从输出结果来看，确实实现了控制 goroutine 以 2 个 2 个的数量去执行我们的 “业务逻辑”，当然结果集也理所应当的是乱序输出")]),t._v(" "),a("h3",{attrs:{id:"方案一：简单-semaphore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方案一：简单-semaphore"}},[t._v("#")]),t._v(" 方案一：简单 Semaphore")]),t._v(" "),a("p",[t._v("在确立了简单使用 chan + sync 的方案是可行后，我们重新将流转逻辑封装为 "),a("a",{attrs:{href:"https://github.com/EDDYCJY/gsema",target:"_blank",rel:"noopener noreferrer"}},[t._v("gsema"),a("OutboundLink")],1),t._v("，主程序变成如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import (\n\t"fmt"\n\t"time"\n\n\t"github.com/EDDYCJY/gsema"\n)\n\nvar sema = gsema.NewSemaphore(3)\n\nfunc main() {\n\tuserCount := 10\n\tfor i := 0; i < userCount; i++ {\n\t\tgo Read(i)\n\t}\n\n\tsema.Wait()\n}\n\nfunc Read(i int) {\n\tdefer sema.Done()\n\tsema.Add(1)\n\n\tfmt.Printf("go func: %d, time: %d\\n", i, time.Now().Unix())\n\ttime.Sleep(time.Second)\n}\n')])])]),a("h3",{attrs:{id:"分析方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分析方案"}},[t._v("#")]),t._v(" 分析方案")]),t._v(" "),a("p",[t._v("在上述代码中，程序执行流程如下：")]),t._v(" "),a("ul",[a("li",[t._v("设置允许的并发数目为 3 个")]),t._v(" "),a("li",[t._v("循环 10 次，每次启动一个 goroutine 来执行任务")]),t._v(" "),a("li",[t._v("每一个 goroutine 在内部利用 "),a("code",[t._v("sema")]),t._v(" 进行调控是否阻塞")]),t._v(" "),a("li",[t._v("按允许并发数逐渐释出 goroutine，最后结束任务")])]),t._v(" "),a("p",[t._v("看上去人模人样，没什么严重问题。但却有一个 “大” 坑，认真看到第二点 “每次启动一个 goroutine” 这句话。这里"),a("strong",[t._v("有点问题")]),t._v("，提前产生那么多的 goroutine 会不会有什么问题，接下来一起分析下利弊，如下：")]),t._v(" "),a("h4",{attrs:{id:"利"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#利"}},[t._v("#")]),t._v(" 利")]),t._v(" "),a("ul",[a("li",[t._v("适合"),a("strong",[t._v("量不大、复杂度低")]),t._v("的使用场景\n"),a("ul",[a("li",[t._v("几百几千个、几十万个也是可以接受的（看具体业务场景）")]),t._v(" "),a("li",[t._v("实际业务逻辑在运行前就已经被阻塞等待了（因为并发数受限），基本实际业务逻辑损耗的性能比 goroutine 本身大")]),t._v(" "),a("li",[t._v("goroutine 本身很轻便，仅损耗极少许的内存空间和调度。这种等待响应的情况都是躺好了，等待任务唤醒")])])]),t._v(" "),a("li",[t._v("Semaphore 操作复杂度低且流转简单，容易控制")])]),t._v(" "),a("h4",{attrs:{id:"弊"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#弊"}},[t._v("#")]),t._v(" 弊")]),t._v(" "),a("ul",[a("li",[t._v("不适合"),a("strong",[t._v("量很大、复杂度高")]),t._v("的使用场景\n"),a("ul",[a("li",[t._v("有几百万、几千万个 goroutine 的话，就浪费了大量调度 goroutine 和内存空间。恰好你的服务器也接受不了的话")])])]),t._v(" "),a("li",[t._v("Semaphore 操作复杂度提高，要管理更多的状态")])]),t._v(" "),a("h3",{attrs:{id:"小结-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结-3"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("ul",[a("li",[t._v("基于什么业务场景，就用什么方案去做事")]),t._v(" "),a("li",[t._v("有足够的时间，允许你去追求更优秀、极致的方案（用第三方库也行）")])]),t._v(" "),a("p",[t._v("用哪种方案，我认为主要基于以上两点去思考，都是 OK 的。没有对错，只有当前业务场景能不能接受，这个预先启动的 goroutine 数量你的系统是否能够接受")]),t._v(" "),a("p",[t._v("当然了，常见/简单的 Go 应用采用这类技术方案，基本就能解决问题了。因为像本文第一节 “问题” 如此超巨大数量的情况，情况很少。其并不存在那些 “特殊性”。因此用这个方案基本 OK")]),t._v(" "),a("h2",{attrs:{id:"灵活控制-goroutine-并发数量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#灵活控制-goroutine-并发数量"}},[t._v("#")]),t._v(" 灵活控制 goroutine 并发数量")]),t._v(" "),a("p",[t._v("小手一紧。隔壁老王发现了新的问题。“方案一” 中，在"),a("strong",[t._v("输入输出一体")]),t._v("的情况下，在常见的业务场景中确实可以")]),t._v(" "),a("p",[t._v("但，这次新的业务场景比较特殊，要控制输入的数量，以此达到"),a("strong",[t._v("改变允许并发运行 goroutine 的数量")]),t._v("。我们仔细想想，要做出如下改变：")]),t._v(" "),a("ul",[a("li",[t._v("输入/输出要抽离，才可以分别控制")]),t._v(" "),a("li",[t._v("输入/输出要可变，理所应当在 for-loop 中（可设置数值的地方）")]),t._v(" "),a("li",[t._v("允许改变 goroutine 并发数量，但它也必须有一个"),a("strong",[t._v("最大值")]),t._v("（因为允许改变是相对）")])]),t._v(" "),a("h3",{attrs:{id:"方案二：灵活-chan-sync"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方案二：灵活-chan-sync"}},[t._v("#")]),t._v(" 方案二：灵活 chan + sync")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package main\n\nimport (\n\t"fmt"\n\t"sync"\n\t"time"\n)\n\nvar wg sync.WaitGroup\n\nfunc main() {\n\tuserCount := 10\n\tch := make(chan int, 5)\n\tfor i := 0; i < userCount; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor d := range ch {\n\t\t\t\tfmt.Printf("go func: %d, time: %d\\n", d, time.Now().Unix())\n\t\t\t\ttime.Sleep(time.Second * time.Duration(d))\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\tch <- 1\n\t\tch <- 2\n\t\t//time.Sleep(time.Second)\n\t}\n\n\tclose(ch)\n\twg.Wait()\n}\n')])])]),a("p",[t._v("输出结果：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("...\ngo func: 1, time: 1547950567\ngo func: 3, time: 1547950567\ngo func: 1, time: 1547950567\ngo func: 2, time: 1547950567\ngo func: 2, time: 1547950567\ngo func: 3, time: 1547950567\ngo func: 1, time: 1547950568\ngo func: 2, time: 1547950568\ngo func: 3, time: 1547950568\ngo func: 1, time: 1547950568\ngo func: 3, time: 1547950569\ngo func: 2, time: 1547950569\n")])])]),a("p",[t._v("在 “方案二” 中，我们可以随时随地的根据新的业务需求，做如下事情：")]),t._v(" "),a("ul",[a("li",[t._v("变更 channel 的输入数量")]),t._v(" "),a("li",[t._v("能够根据特殊情况，变更 channel 的循环值")]),t._v(" "),a("li",[t._v("变更最大允许并发的 goroutine 数量")])]),t._v(" "),a("p",[t._v("总的来说，就是可控空间都尽量放开了，是不是更加灵活了呢 😃")]),t._v(" "),a("h3",{attrs:{id:"方案三：第三方库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方案三：第三方库"}},[t._v("#")]),t._v(" 方案三：第三方库")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/go-playground/pool",target:"_blank",rel:"noopener noreferrer"}},[t._v("go-playground/pool"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/nozzle/throttler",target:"_blank",rel:"noopener noreferrer"}},[t._v("nozzle/throttler"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/Jeffail/tunny",target:"_blank",rel:"noopener noreferrer"}},[t._v("Jeffail/tunny"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/panjf2000/ants",target:"_blank",rel:"noopener noreferrer"}},[t._v("panjf2000/ants"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("比较成熟的第三方库也不少，基本都是以生成和管理 goroutine 为目标的池工具。我简单列了几个，具体建议大家阅读下源码或者多找找，原理相似")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("在本文的开头，我花了大力气（极端数量），告诉你"),a("strong",[t._v("同时并发过多的 goroutine 数量会导致系统占用资源不断上涨。最终该服务崩盘的极端情况")]),t._v("。为的是希望你今后避免这种问题，给你留下深刻的印象")]),t._v(" "),a("p",[t._v("接下来我们以 “控制 goroutine 并发数量” 为主题，展开了一番分析。分别给出了三种方案。在我看来，各具优缺点，我建议你"),a("strong",[t._v("挑选合适自身场景的技术方案")]),t._v("就可以了")]),t._v(" "),a("p",[t._v("因为，有不同类型的技术方案也能解决这个问题，千人千面。本文推荐的是较常见的解决方案，也欢迎大家在评论区继续补充 😃")])])}),[],!1,null,null,null);n.default=r.exports}}]);