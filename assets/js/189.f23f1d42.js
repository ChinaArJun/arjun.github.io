(window.webpackJsonp=window.webpackJsonp||[]).push([[189],{625:function(t,e,n){"use strict";n.r(e);var r=n(44),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_1-7-for-loop-与-json-unmarshal-性能分析概要"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-for-loop-与-json-unmarshal-性能分析概要"}},[t._v("#")]),t._v(" 1.7 for-loop 与 json.Unmarshal 性能分析概要")]),t._v(" "),n("p",[t._v("在项目中，常常会遇到循环交换赋值的数据处理场景，尤其是 RPC，数据交互格式要转为 Protobuf，赋值是无法避免的。一般会有如下几种做法：")]),t._v(" "),n("ul",[n("li",[t._v("for")]),t._v(" "),n("li",[t._v("for range")]),t._v(" "),n("li",[t._v("json.Marshal/Unmarshal")])]),t._v(" "),n("p",[t._v("这时候又面临 “选择困难症”，用哪个好？又想代码量少，又担心性能有没有影响啊...")]),t._v(" "),n("p",[t._v("为了弄清楚这个疑惑，接下来将分别编写三种使用场景。来简单看看它们的性能情况，看看谁更 “好”")]),t._v(" "),n("h2",{attrs:{id:"功能代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#功能代码"}},[t._v("#")]),t._v(" 功能代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('...\ntype Person struct {\n\tName   string `json:"name"`\n\tAge    int    `json:"age"`\n\tAvatar string `json:"avatar"`\n\tType   string `json:"type"`\n}\n\ntype AgainPerson struct {\n\tName   string `json:"name"`\n\tAge    int    `json:"age"`\n\tAvatar string `json:"avatar"`\n\tType   string `json:"type"`\n}\n\nconst MAX = 10000\n\nfunc InitPerson() []Person {\n\tvar persons []Person\n\tfor i := 0; i < MAX; i++ {\n\t\tpersons = append(persons, Person{\n\t\t\tName:   "EDDYCJY",\n\t\t\tAge:    i,\n\t\t\tAvatar: "https://github.com/EDDYCJY",\n\t\t\tType:   "Person",\n\t\t})\n\t}\n\n\treturn persons\n}\n\nfunc ForStruct(p []Person, count int) {\n\tfor i := 0; i < count; i++ {\n\t\t_, _ = i, p[i]\n\t}\n}\n\nfunc ForRangeStruct(p []Person) {\n\tfor i, v := range p {\n\t\t_, _ = i, v\n\t}\n}\n\nfunc JsonToStruct(data []byte, againPerson []AgainPerson) ([]AgainPerson, error) {\n\terr := json.Unmarshal(data, &againPerson)\n\treturn againPerson, err\n}\n\nfunc JsonIteratorToStruct(data []byte, againPerson []AgainPerson) ([]AgainPerson, error) {\n\tvar jsonIter = jsoniter.ConfigCompatibleWithStandardLibrary\n\terr := jsonIter.Unmarshal(data, &againPerson)\n\treturn againPerson, err\n}\n')])])]),n("h2",{attrs:{id:"测试代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试代码"}},[t._v("#")]),t._v(" 测试代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('...\nfunc BenchmarkForStruct(b *testing.B) {\n\tperson := InitPerson()\n\tcount := len(person)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tForStruct(person, count)\n\t}\n}\n\nfunc BenchmarkForRangeStruct(b *testing.B) {\n\tperson := InitPerson()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tForRangeStruct(person)\n\t}\n}\n\nfunc BenchmarkJsonToStruct(b *testing.B) {\n\tvar (\n\t\tperson = InitPerson()\n\t\tagainPersons []AgainPerson\n\t)\n\tdata, err := json.Marshal(person)\n\tif err != nil {\n\t\tb.Fatalf("json.Marshal err: %v", err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tJsonToStruct(data, againPersons)\n\t}\n}\n\nfunc BenchmarkJsonIteratorToStruct(b *testing.B) {\n\tvar (\n\t\tperson = InitPerson()\n\t\tagainPersons []AgainPerson\n\t)\n\tdata, err := json.Marshal(person)\n\tif err != nil {\n\t\tb.Fatalf("json.Marshal err: %v", err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tJsonIteratorToStruct(data, againPersons)\n\t}\n}\n')])])]),n("h2",{attrs:{id:"测试结果"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试结果"}},[t._v("#")]),t._v(" 测试结果")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BenchmarkForStruct-4              \t  500000\t      3289 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkForRangeStruct-4         \t  200000\t      9178 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkJsonToStruct-4           \t     100\t  19173117 ns/op\t 2618509 B/op\t   40036 allocs/op\nBenchmarkJsonIteratorToStruct-4   \t     300\t   4116491 ns/op\t 3694017 B/op\t   30047 allocs/op\n")])])]),n("p",[t._v("从测试结果来看，性能排名为：for < for range < json-iterator < encoding/json。接下来我们看看是什么原因导致了这样子的排名？")]),t._v(" "),n("h2",{attrs:{id:"性能对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性能对比"}},[t._v("#")]),t._v(" 性能对比")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://i.imgur.com/yEdUayK.png",alt:"image"}})]),t._v(" "),n("h3",{attrs:{id:"for-loop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#for-loop"}},[t._v("#")]),t._v(" for-loop")]),t._v(" "),n("p",[t._v("在测试结果中，"),n("code",[t._v("for range")]),t._v(" 在性能上相较 "),n("code",[t._v("for")]),t._v(" 差。这是为什么呢？在这里我们可以参见 "),n("code",[t._v("for range")]),t._v(" 的 "),n("a",{attrs:{href:"https://github.com/gcc-mirror/gcc/blob/master/gcc/go/gofrontend/statements.cc",target:"_blank",rel:"noopener noreferrer"}},[t._v("实现"),n("OutboundLink")],1),t._v("，伪实现如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("for_temp := range\nlen_temp := len(for_temp)\nfor index_temp = 0; index_temp < len_temp; index_temp++ {\n    value_temp = for_temp[index_temp]\n    index = index_temp\n    value = value_temp\n    original body\n}\n")])])]),n("p",[t._v("通过分析伪实现，可得知 "),n("code",[t._v("for range")]),t._v(" 相较 "),n("code",[t._v("for")]),t._v(" 多做了如下事项")]),t._v(" "),n("h4",{attrs:{id:"expression"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#expression"}},[t._v("#")]),t._v(" Expression")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .\n')])])]),n("p",[t._v("在循环开始之前会对范围表达式进行求值，多做了 “解” 表达式的动作，得到了最终的范围值")]),t._v(" "),n("h4",{attrs:{id:"copy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copy"}},[t._v("#")]),t._v(" Copy")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("...\nvalue_temp = for_temp[index_temp]\nindex = index_temp\nvalue = value_temp\n...\n")])])]),n("p",[t._v("从伪实现上可以得出，"),n("code",[t._v("for range")]),t._v(" 始终使用"),n("strong",[t._v("值拷贝")]),t._v("的方式来生成循环变量。通俗来讲，就是在每次循环时，都会对循环变量重新分配")]),t._v(" "),n("h4",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("p",[t._v("通过上述的分析，可得知其比 "),n("code",[t._v("for")]),t._v(" 慢的原因是 "),n("code",[t._v("for range")]),t._v(" 有额外的性能开销，主要为"),n("strong",[t._v("值拷贝的动作")]),t._v("导致的性能下降。这是它慢的原因")]),t._v(" "),n("p",[t._v("那么其实在 "),n("code",[t._v("for range")]),t._v(" 中，我们可以使用 "),n("code",[t._v("_")]),t._v(" 和 "),n("code",[t._v("T[i]")]),t._v(" 也能达到和 "),n("code",[t._v("for")]),t._v(" 差不多的性能。但这可能不是 "),n("code",[t._v("for range")]),t._v(" 的设计本意了")]),t._v(" "),n("h3",{attrs:{id:"json-marshal-unmarshal"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#json-marshal-unmarshal"}},[t._v("#")]),t._v(" json.Marshal/Unmarshal")]),t._v(" "),n("h4",{attrs:{id:"encoding-json"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#encoding-json"}},[t._v("#")]),t._v(" encoding/json")]),t._v(" "),n("p",[t._v("json 互转是在三种方案中最慢的，这是为什么呢？")]),t._v(" "),n("p",[t._v("众所皆知，官方的 "),n("code",[t._v("encoding/json")]),t._v(" 标准库，是通过大量反射来实现的。那么 “慢”，也是必然的。可参见下述代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("...\nfunc newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {\n    ...\n\tswitch t.Kind() {\n\tcase reflect.Bool:\n\t\treturn boolEncoder\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn intEncoder\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn uintEncoder\n\tcase reflect.Float32:\n\t\treturn float32Encoder\n\tcase reflect.Float64:\n\t\treturn float64Encoder\n\tcase reflect.String:\n\t\treturn stringEncoder\n\tcase reflect.Interface:\n\t\treturn interfaceEncoder\n\tcase reflect.Struct:\n\t\treturn newStructEncoder(t)\n\tcase reflect.Map:\n\t\treturn newMapEncoder(t)\n\tcase reflect.Slice:\n\t\treturn newSliceEncoder(t)\n\tcase reflect.Array:\n\t\treturn newArrayEncoder(t)\n\tcase reflect.Ptr:\n\t\treturn newPtrEncoder(t)\n\tdefault:\n\t\treturn unsupportedTypeEncoder\n\t}\n}\n")])])]),n("p",[t._v("既然官方的标准库存在一定的 “问题”，那么有没有其他解决方法呢？目前在社区里，大多为两类方案。如下：")]),t._v(" "),n("ul",[n("li",[t._v("预编译生成代码（提前确定类型），可以解决运行时的反射带来的性能开销。缺点是增加了预生成的步骤")]),t._v(" "),n("li",[t._v("优化序列化的逻辑，性能达到最大化")])]),t._v(" "),n("p",[t._v("接下来的实验，我们用第二种方案的库来测试，看看有没有改变。另外也推荐大家了解如下项目：")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://github.com/json-iterator/go",target:"_blank",rel:"noopener noreferrer"}},[t._v("json-iterator/go"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/mailru/easyjson",target:"_blank",rel:"noopener noreferrer"}},[t._v("mailru/easyjson"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/pquerna/ffjson",target:"_blank",rel:"noopener noreferrer"}},[t._v("pquerna/ffjson"),n("OutboundLink")],1)])]),t._v(" "),n("h4",{attrs:{id:"json-iterator-go"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#json-iterator-go"}},[t._v("#")]),t._v(" json-iterator/go")]),t._v(" "),n("p",[t._v("目前社区较常用的是 json-iterator/go，我们在测试代码中用到了它")]),t._v(" "),n("p",[t._v("它的用法与标准库 100% 兼容，并且性能有较大提升。我们一起粗略的看下是怎么做到的，如下：")]),t._v(" "),n("h5",{attrs:{id:"reflect2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reflect2"}},[t._v("#")]),t._v(" reflect2")]),t._v(" "),n("p",[t._v("利用 "),n("a",{attrs:{href:"https://github.com/modern-go/reflect2",target:"_blank",rel:"noopener noreferrer"}},[t._v("modern-go/reflect2"),n("OutboundLink")],1),t._v(" 减少运行时调度开销")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("...\ntype StructDescriptor struct {\n\tType   reflect2.Type\n\tFields []*Binding\n}\n\n...\ntype Binding struct {\n\tlevels    []int\n\tField     reflect2.StructField\n\tFromNames []string\n\tToNames   []string\n\tEncoder   ValEncoder\n\tDecoder   ValDecoder\n}\n\ntype Extension interface {\n\tUpdateStructDescriptor(structDescriptor *StructDescriptor)\n\tCreateMapKeyDecoder(typ reflect2.Type) ValDecoder\n\tCreateMapKeyEncoder(typ reflect2.Type) ValEncoder\n\tCreateDecoder(typ reflect2.Type) ValDecoder\n\tCreateEncoder(typ reflect2.Type) ValEncoder\n\tDecorateDecoder(typ reflect2.Type, decoder ValDecoder) ValDecoder\n\tDecorateEncoder(typ reflect2.Type, encoder ValEncoder) ValEncoder\n}\n")])])]),n("h5",{attrs:{id:"struct-encoder-decoder-cache"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#struct-encoder-decoder-cache"}},[t._v("#")]),t._v(" struct Encoder/Decoder Cache")]),t._v(" "),n("p",[t._v("类型为 struct 时，只需要反射一次 Name 和 Type，会缓存 struct Encoder 和 Decoder")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var typeDecoders = map[string]ValDecoder{}\nvar fieldDecoders = map[string]ValDecoder{}\nvar typeEncoders = map[string]ValEncoder{}\nvar fieldEncoders = map[string]ValEncoder{}\nvar extensions = []Extension{}\n\n....\n\nfieldNames := calcFieldNames(field.Name(), tagParts[0], tag)\nfieldCacheKey := fmt.Sprintf("%s/%s", typ.String(), field.Name())\ndecoder := fieldDecoders[fieldCacheKey]\nif decoder == nil {\n\tdecoder = decoderOfType(ctx.append(field.Name()), field.Type())\n}\nencoder := fieldEncoders[fieldCacheKey]\nif encoder == nil {\n\tencoder = encoderOfType(ctx.append(field.Name()), field.Type())\n}\n')])])]),n("h5",{attrs:{id:"文本解析优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文本解析优化"}},[t._v("#")]),t._v(" 文本解析优化")]),t._v(" "),n("h4",{attrs:{id:"小结-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结-2"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("p",[t._v("相较于官方标准库，第三方库 "),n("code",[t._v("json-iterator/go")]),t._v(" 在运行时上做的更好。这是它快的原因")]),t._v(" "),n("p",[t._v("有个需要注意的点，在 Go1.10 后 "),n("code",[t._v("map")]),t._v(" 类型与标准库的已经没有太大的性能差异。但是，例如 "),n("code",[t._v("struct")]),t._v(" 类型等仍然有较大的性能提高")]),t._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[t._v("在本文中，我们首先进行了性能测试，再分析了不同方案，得知为什么了快慢的原因。那么最终在选择方案时，可以根据不同的应用场景去抉择：")]),t._v(" "),n("ul",[n("li",[t._v("对性能开销有较高要求：选用 "),n("code",[t._v("for")]),t._v("，开销最小")]),t._v(" "),n("li",[t._v("中规中矩：选用 "),n("code",[t._v("for range")]),t._v("，大对象慎用")]),t._v(" "),n("li",[t._v("量小、占用小、数量可控：选用 "),n("code",[t._v("json.Marshal/Unmarshal")]),t._v(" 的方案也可以。其"),n("strong",[t._v("重复代码")]),t._v("少，但开销最大")])]),t._v(" "),n("p",[t._v("在绝大多数场景中，使用哪种并没有太大的影响。但作为工程师你应当清楚其利弊。以上就是不同的方案"),n("strong",[t._v("分析概要")]),t._v("，希望对你有所帮助 😃")])])}),[],!1,null,null,null);e.default=a.exports}}]);