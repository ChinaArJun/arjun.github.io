(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{629:function(t,r,e){"use strict";e.r(r);var n=e(44),a=Object(n.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_1-3-用-go-来了解一下-redis-通讯协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-用-go-来了解一下-redis-通讯协议"}},[t._v("#")]),t._v(" 1.3 用 Go 来了解一下 Redis 通讯协议")]),t._v(" "),e("p",[t._v("Go、PHP、Java... 都有那么多包来支撑你使用 Redis，那你是否有想过")]),t._v(" "),e("p",[t._v("有了服务端，有了客户端，他们俩是怎样通讯，又是基于什么通讯协议做出交互的呢？")]),t._v(" "),e("h2",{attrs:{id:"介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),e("p",[t._v("基于我们的目的，本文主要讲解和实践 Redis 的通讯协议")]),t._v(" "),e("p",[t._v("Redis 的客户端和服务端是通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379")]),t._v(" "),e("p",[t._v("客户端和服务器发送的命令或数据一律以 \\r\\n （CRLF）结尾（这是一条约定）")]),t._v(" "),e("h2",{attrs:{id:"协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[t._v("#")]),t._v(" 协议")]),t._v(" "),e("p",[t._v("在 Redis 中分为"),e("strong",[t._v("请求")]),t._v("和"),e("strong",[t._v("回复")]),t._v("，而请求协议又分为新版和旧版，新版统一请求协议在 Redis 1.2 版本中引入，最终在 Redis 2.0 版本成为 Redis 服务器通信的标准方式")]),t._v(" "),e("p",[t._v("本文是基于新版协议来实现功能，不建议使用旧版（1.2 挺老旧了）。如下是新协议的各种范例：")]),t._v(" "),e("h3",{attrs:{id:"请求协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求协议"}},[t._v("#")]),t._v(" 请求协议")]),t._v(" "),e("p",[t._v("1、 格式示例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("*<参数数量> CR LF\n$<参数 1 的字节数量> CR LF\n<参数 1 的数据> CR LF\n...\n$<参数 N 的字节数量> CR LF\n<参数 N 的数据> CR LF\n")])])]),e("p",[t._v("在该协议下所有发送至 Redis 服务器的参数都是二进制安全（binary safe）的")]),t._v(" "),e("p",[t._v("2、打印示例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("*3\n$3\nSET\n$5\nmykey\n$7\nmyvalue\n")])])]),e("p",[t._v("3、实际协议值")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$7\\r\\nmyvalue\\r\\n"\n')])])]),e("p",[t._v("这就是 Redis 的请求协议规范，按照范例1编写客户端逻辑，最终发送的是范例3，相信你已经有大致的概念了，Redis 的协议非常的简洁易懂，这也是好上手的原因之一，你可以想想协议这么定义的好处在哪？")]),t._v(" "),e("h3",{attrs:{id:"回复"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回复"}},[t._v("#")]),t._v(" 回复")]),t._v(" "),e("p",[t._v("Redis 会根据你请求协议的不同（执行的命令结果也不同），返回多种不同类型的回复。在这个回复“协议”中，可以通过检查第一个字节，确定这个回复是什么类型，如下：")]),t._v(" "),e("ul",[e("li",[t._v('状态回复（status reply）的第一个字节是 "+"')]),t._v(" "),e("li",[t._v('错误回复（error reply）的第一个字节是 "-"')]),t._v(" "),e("li",[t._v('整数回复（integer reply）的第一个字节是 ":"')]),t._v(" "),e("li",[t._v('批量回复（bulk reply）的第一个字节是 "$"')]),t._v(" "),e("li",[t._v('多条批量回复（multi bulk reply）的第一个字节是 "*"')])]),t._v(" "),e("p",[t._v("有了回复的头部标识，结尾的 CRLF，你可以大致猜想出回复“协议”是怎么样的，但是实践才能得出真理，斎知道怕是你很快就忘记了 😀")]),t._v(" "),e("h2",{attrs:{id:"实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实践"}},[t._v("#")]),t._v(" 实践")]),t._v(" "),e("h3",{attrs:{id:"与-redis-服务器交互"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与-redis-服务器交互"}},[t._v("#")]),t._v(" 与 Redis 服务器交互")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package main\n\nimport (\n\t"log"\n\t"net"\n\t"os"\n\n\t"github.com/EDDYCJY/redis-protocol-example/protocol"\n)\n\nconst (\n\tAddress = "127.0.0.1:6379"\n\tNetwork = "tcp"\n)\n\nfunc Conn(network, address string) (net.Conn, error) {\n\tconn, err := net.Dial(network, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\nfunc main() {\n        // 读取入参\n\targs := os.Args[1:]\n\tif len(args) <= 0 {\n\t\tlog.Fatalf("Os.Args <= 0")\n\t}\n    \n        // 获取请求协议\n\treqCommand := protocol.GetRequest(args)\n\t\n\t// 连接 Redis 服务器\n\tredisConn, err := Conn(Network, Address)\n\tif err != nil {\n\t\tlog.Fatalf("Conn err: %v", err)\n\t}\n\tdefer redisConn.Close()\n    \n        // 写入请求内容\n\t_, err = redisConn.Write(reqCommand)\n\tif err != nil {\n\t\tlog.Fatalf("Conn Write err: %v", err)\n\t}\n    \n        // 读取回复\n\tcommand := make([]byte, 1024)\n\tn, err := redisConn.Read(command)\n\tif err != nil {\n\t\tlog.Fatalf("Conn Read err: %v", err)\n\t}\n    \n        // 处理回复\n\treply, err := protocol.GetReply(command[:n])\n\tif err != nil {\n\t\tlog.Fatalf("protocol.GetReply err: %v", err)\n\t}\n    \n        // 处理后的回复内容\n\tlog.Printf("Reply: %v", reply)\n\t// 原始的回复内容\n\tlog.Printf("Command: %v", string(command[:n]))\n}\n')])])]),e("p",[t._v("在这里我们完成了整个 Redis 客户端和服务端交互的流程，分别如下：")]),t._v(" "),e("p",[t._v("1、读取命令行参数：获取执行的 Redis 命令")]),t._v(" "),e("p",[t._v("2、获取请求协议参数")]),t._v(" "),e("p",[t._v("3、连接 Redis 服务器，获取连接句柄")]),t._v(" "),e("p",[t._v("4、将请求协议参数写入连接：发送请求的命令行参数")]),t._v(" "),e("p",[t._v("5、从连接中读取返回的数据：读取先前请求的回复数据")]),t._v(" "),e("p",[t._v("6、根据回复“协议”内容，处理回复的数据集")]),t._v(" "),e("p",[t._v("7、输出处理后的回复内容及原始回复内容")]),t._v(" "),e("h3",{attrs:{id:"请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求"}},[t._v("#")]),t._v(" 请求")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func GetRequest(args []string) []byte {\n\treq := []string{\n\t\t"*" + strconv.Itoa(len(args)),\n\t}\n\n\tfor _, arg := range args {\n\t\treq = append(req, "$"+strconv.Itoa(len(arg)))\n\t\treq = append(req, arg)\n\t}\n\n\tstr := strings.Join(req, "\\r\\n")\n\treturn []byte(str + "\\r\\n")\n}\n')])])]),e("p",[t._v("通过对 Redis 的请求协议的分析，可得出它的规律，先加上标志位，计算参数总数量，再循环合并各个参数的字节数量、值就可以了")]),t._v(" "),e("h3",{attrs:{id:"回复-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回复-2"}},[t._v("#")]),t._v(" 回复")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func GetReply(reply []byte) (interface{}, error) {\n\treplyType := reply[0]\n\tswitch replyType {\n\tcase StatusReply:\n\t\treturn doStatusReply(reply[1:])\n\tcase ErrorReply:\n\t\treturn doErrorReply(reply[1:])\n\tcase IntegerReply:\n\t\treturn doIntegerReply(reply[1:])\n\tcase BulkReply:\n\t\treturn doBulkReply(reply[1:])\n\tcase MultiBulkReply:\n\t\treturn doMultiBulkReply(reply[1:])\n\tdefault:\n\t\treturn nil, nil\n\t}\n}\n\nfunc doStatusReply(reply []byte) (string, error) {\n\tif len(reply) == 3 && reply[1] == 'O' && reply[2] == 'K' {\n\t\treturn OkReply, nil\n\t}\n\n\tif len(reply) == 5 && reply[1] == 'P' && reply[2] == 'O' && reply[3] == 'N' && reply[4] == 'G' {\n\t\treturn PongReply, nil\n\t}\n\n\treturn string(reply), nil\n}\n\nfunc doErrorReply(reply []byte) (string, error) {\n\treturn string(reply), nil\n}\n\nfunc doIntegerReply(reply []byte) (int, error) {\n\tpos := getFlagPos('\\r', reply)\n\tresult, err := strconv.Atoi(string(reply[:pos]))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn result, nil\n}\n\n...\n")])])]),e("p",[t._v("在这里我们对所有回复类型进行了分发，不同的回复标志位对应不同的处理方式，在这里需求注意几项问题，如下：")]),t._v(" "),e("p",[t._v("1、当请求的值不存在，会将特殊值 -1 用作回复")]),t._v(" "),e("p",[t._v("2、服务器发送的所有字符串都由 CRLF 结尾")]),t._v(" "),e("p",[t._v("3、多条批量回复是可基于批量回复的，要注意理解")]),t._v(" "),e("p",[t._v("4、无内容的多条批量回复是存在的")]),t._v(" "),e("p",[t._v("最重要的是，对不同回复的规则的把控，能够让你更好的理解 Redis 的请求、回复的交互过程 👌")]),t._v(" "),e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),e("p",[t._v("写这篇文章的起因，是因为常常在使用 Redis 时，只是用，你不知道它是基于什么样的通讯协议来通讯，这样的感觉是十分难受的")]),t._v(" "),e("p",[t._v("通过本文的讲解，我相信你已经大致了解 Redis 客户端是怎么样和服务端交互，也清楚了其所用的通讯原理，希望能够对你有所帮助！")]),t._v(" "),e("p",[t._v("最后，如果想详细查看代码，右拐项目地址：https://github.com/EDDYCJY/redis-protocol-example")]),t._v(" "),e("p",[t._v("如果对你有所帮助，欢迎点个 Star 👍")]),t._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"http://doc.redisfans.com/topic/protocol.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("通信协议"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=a.exports}}]);