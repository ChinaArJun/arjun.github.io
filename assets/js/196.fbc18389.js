(window.webpackJsonp=window.webpackJsonp||[]).push([[196],{632:function(e,t,a){"use strict";a.r(t);var r=a(44),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_1-4-使用-gomock-进行单元测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-使用-gomock-进行单元测试"}},[e._v("#")]),e._v(" 1.4 使用 Gomock 进行单元测试")]),e._v(" "),a("p",[e._v("在实际项目中，需要进行单元测试的时候。却往往发现有一大堆依赖项。这时候就是 "),a("a",{attrs:{href:"https://github.com/golang/mock",target:"_blank",rel:"noopener noreferrer"}},[e._v("Gomock"),a("OutboundLink")],1),e._v(" 大显身手的时候了")]),e._v(" "),a("p",[e._v("Gomock 是 Go 语言的一个 mock 框架，官方的那种 🤪")]),e._v(" "),a("h2",{attrs:{id:"安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[e._v("#")]),e._v(" 安装")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ go get -u github.com/golang/mock/gomock\n$ go install github.com/golang/mock/mockgen\n")])])]),a("ol",[a("li",[a("p",[e._v("第一步：我们将安装 gomock 第三方库和 mock 代码的生成工具 mockgen。而后者可以大大的节省我们的工作量。只需要了解其使用方式就可以")])]),e._v(" "),a("li",[a("p",[e._v("第二步：输入 "),a("code",[e._v("mockgen")]),e._v(" 验证代码生成工具是否安装正确。若无法正常响应，请检查 "),a("code",[e._v("bin")]),e._v(" 目录下是否包含该二进制文件")])])]),e._v(" "),a("h3",{attrs:{id:"用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[e._v("#")]),e._v(" 用法")]),e._v(" "),a("p",[e._v("在 "),a("code",[e._v("mockgen")]),e._v(" 命令中，支持两种生成模式：")]),e._v(" "),a("ol",[a("li",[e._v("source：从源文件生成 mock 接口（通过 -source 启用）")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("mockgen -source=foo.go [other options]\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("reflect：通过使用反射程序来生成 mock 接口。它通过传递两个非标志参数来启用：导入路径和逗号分隔的接口列表")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("mockgen database/sql/driver Conn,Driver\n")])])]),a("p",[e._v("从本质上来讲，两种方式生成的 mock 代码并没有什么区别。因此选择合适的就可以了")]),e._v(" "),a("h2",{attrs:{id:"写测试用例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写测试用例"}},[e._v("#")]),e._v(" 写测试用例")]),e._v(" "),a("p",[e._v("在本文将模拟一个简单 Demo 来编写测试用例，熟悉整体的测试流程")]),e._v(" "),a("h3",{attrs:{id:"步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#步骤"}},[e._v("#")]),e._v(" 步骤")]),e._v(" "),a("ol",[a("li",[e._v("想清楚整体逻辑")]),e._v(" "),a("li",[e._v("定义想要（模拟）依赖项的 interface（接口）")]),e._v(" "),a("li",[e._v("使用 "),a("code",[e._v("mockgen")]),e._v(" 命令对所需 mock 的 interface 生成 mock 文件")]),e._v(" "),a("li",[e._v("编写单元测试的逻辑，在测试中使用 mock")]),e._v(" "),a("li",[e._v("进行单元测试的验证")])]),e._v(" "),a("h3",{attrs:{id:"目录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[e._v("#")]),e._v(" 目录")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("├── mock\n├── person\n│   └── male.go\n└── user\n    ├── user.go\n    └── user_test.go\n")])])]),a("h3",{attrs:{id:"编写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写"}},[e._v("#")]),e._v(" 编写")]),e._v(" "),a("h4",{attrs:{id:"interface-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interface-方法"}},[e._v("#")]),e._v(" interface 方法")]),e._v(" "),a("p",[e._v("打开 person/male.go 文件，写入以下内容：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("package person\n\ntype Male interface {\n\tGet(id int64) error\n}\n")])])]),a("h4",{attrs:{id:"调用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用方法"}},[e._v("#")]),e._v(" 调用方法")]),e._v(" "),a("p",[e._v("打开 user/user.go 文件，写入以下内容：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('package user\n\nimport "github.com/EDDYCJY/mockd/person"\n\ntype User struct {\n\tPerson person.Male\n}\n\nfunc NewUser(p person.Male) *User {\n\treturn &User{Person: p}\n}\n\nfunc (u *User) GetUserInfo(id int64) error {\n\treturn u.Person.Get(id)\n}\n')])])]),a("h4",{attrs:{id:"生成-mock-文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成-mock-文件"}},[e._v("#")]),e._v(" 生成 mock 文件")]),e._v(" "),a("p",[e._v("回到 "),a("code",[e._v("mockd/")]),e._v(" 的根目录下，执行以下命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ mockgen -source=./person/male.go -destination=./mock/male_mock.go -package=mock\n")])])]),a("p",[e._v("在执行完毕后，可以发现 "),a("code",[e._v("mock/")]),e._v(" 目录下多出了 male_mock.go 文件，这就是 mock 文件。那么命令中的指令又分别有什么用呢？如下：")]),e._v(" "),a("ul",[a("li",[e._v("-source：设置需要模拟（mock）的接口文件")]),e._v(" "),a("li",[e._v("-destination：设置 mock 文件输出的地方，若不设置则打印到标准输出中")]),e._v(" "),a("li",[e._v("-package：设置 mock 文件的包名，若不设置则为 "),a("code",[e._v("mock_")]),e._v(" 前缀加上文件名（如本文的包名会为 mock_person）")])]),e._v(" "),a("p",[e._v("想了解更多的指令符，可参见 "),a("a",{attrs:{href:"https://github.com/golang/mock#running-mockgen",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),a("OutboundLink")],1)]),e._v(" "),a("h5",{attrs:{id:"输出的-mock-文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输出的-mock-文件"}},[e._v("#")]),e._v(" 输出的 mock 文件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Code generated by MockGen. DO NOT EDIT.\n// Source: ./person/male.go\n\n// Package mock is a generated GoMock package.\npackage mock\n\nimport (\n\tgomock "github.com/golang/mock/gomock"\n\treflect "reflect"\n)\n\n// MockMale is a mock of Male interface\ntype MockMale struct {\n\tctrl     *gomock.Controller\n\trecorder *MockMaleMockRecorder\n}\n\n// MockMaleMockRecorder is the mock recorder for MockMale\ntype MockMaleMockRecorder struct {\n\tmock *MockMale\n}\n\n// NewMockMale creates a new mock instance\nfunc NewMockMale(ctrl *gomock.Controller) *MockMale {\n\tmock := &MockMale{ctrl: ctrl}\n\tmock.recorder = &MockMaleMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockMale) EXPECT() *MockMaleMockRecorder {\n\treturn m.recorder\n}\n\n// Get mocks base method\nfunc (m *MockMale) Get(id int64) error {\n\tret := m.ctrl.Call(m, "Get", id)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Get indicates an expected call of Get\nfunc (mr *MockMaleMockRecorder) Get(id interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockMale)(nil).Get), id)\n}\n')])])]),a("h4",{attrs:{id:"测试用例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试用例"}},[e._v("#")]),e._v(" 测试用例")]),e._v(" "),a("p",[e._v("打开 user/user_test.go 文件，写入以下内容：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('package user\n\nimport (\n\t"testing"\n\n\t"github.com/EDDYCJY/mockd/mock"\n\n\t"github.com/golang/mock/gomock"\n)\n\nfunc TestUser_GetUserInfo(t *testing.T) {\n\tctl := gomock.NewController(t)\n\tdefer ctl.Finish()\n\n\tvar id int64 = 1\n\tmockMale := mock.NewMockMale(ctl)\n\tgomock.InOrder(\n\t\tmockMale.EXPECT().Get(id).Return(nil),\n\t)\n\n\tuser := NewUser(mockMale)\n\terr := user.GetUserInfo(id)\n\tif err != nil {\n\t\tt.Errorf("user.GetUserInfo err: %v", err)\n\t}\n}\n')])])]),a("ol",[a("li",[a("p",[e._v("gomock.NewController：返回 "),a("code",[e._v("gomock.Controller")]),e._v("，它代表 mock 生态系统中的顶级控件。定义了 mock 对象的范围、生命周期和期待值。另外它在多个 goroutine 中是安全的")])]),e._v(" "),a("li",[a("p",[e._v("mock.NewMockMale：创建一个新的 mock 实例")])]),e._v(" "),a("li",[a("p",[e._v("gomock.InOrder：声明给定的调用应按顺序进行（是对 gomock.After 的二次封装）")])]),e._v(" "),a("li",[a("p",[e._v("mockMale.EXPECT().Get(id).Return(nil)：这里有三个步骤，"),a("code",[e._v("EXPECT()")]),e._v("返回一个允许调用者设置"),a("strong",[e._v("期望")]),e._v("和"),a("strong",[e._v("返回值")]),e._v("的对象。"),a("code",[e._v("Get(id)")]),e._v(" 是设置入参并调用 mock 实例中的方法。"),a("code",[e._v("Return(nil)")]),e._v(" 是设置先前调用的方法出参。简单来说，就是设置入参并调用，最后设置返回值")])]),e._v(" "),a("li",[a("p",[e._v("NewUser(mockMale)：创建 User 实例，值得注意的是，在这里"),a("strong",[e._v("注入了 mock 对象")]),e._v("，因此实际在随后的 "),a("code",[e._v("user.GetUserInfo(id)")]),e._v(" 调用（入参：id 为 1）中。它调用的是我们事先模拟好的 mock 方法")])]),e._v(" "),a("li",[a("p",[e._v("ctl.Finish()：进行 mock 用例的期望值断言，一般会使用 "),a("code",[e._v("defer")]),e._v(" 延迟执行，以防止我们忘记这一操作")])])]),e._v(" "),a("h3",{attrs:{id:"测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试"}},[e._v("#")]),e._v(" 测试")]),e._v(" "),a("p",[e._v("回到 "),a("code",[e._v("mockd/")]),e._v(" 的根目录下，执行以下命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ go test ./user\nok  \tgithub.com/EDDYCJY/mockd/user\n")])])]),a("p",[e._v("看到这样的结果，就大功告成啦！你可以自己调整一下 "),a("code",[e._v("Return()")]),e._v(" 的返回值，以此得到不一样的测试结果哦 😄")]),e._v(" "),a("h2",{attrs:{id:"查看测试情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看测试情况"}},[e._v("#")]),e._v(" 查看测试情况")]),e._v(" "),a("h3",{attrs:{id:"测试覆盖率"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试覆盖率"}},[e._v("#")]),e._v(" 测试覆盖率")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ go test -cover ./user\nok  \tgithub.com/EDDYCJY/mockd/user\t(cached)\tcoverage: 100.0% of statements\n")])])]),a("p",[e._v("可通过设置 "),a("code",[e._v("-cover")]),e._v(" 标志符来开启覆盖率的统计，展示内容为 "),a("code",[e._v("coverage: 100.0%")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"可视化界面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可视化界面"}},[e._v("#")]),e._v(" 可视化界面")]),e._v(" "),a("ol",[a("li",[e._v("生成测试覆盖率的 profile 文件")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ go test ./... -coverprofile=cover.out\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("利用 profile 文件生成可视化界面")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ go tool cover -html=cover.out\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[e._v("查看可视化界面，分析覆盖情况")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/YSZrofR.jpg",alt:"image"}})]),e._v(" "),a("h2",{attrs:{id:"更多"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更多"}},[e._v("#")]),e._v(" 更多")]),e._v(" "),a("h3",{attrs:{id:"一、常用-mock-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、常用-mock-方法"}},[e._v("#")]),e._v(" 一、常用 mock 方法")]),e._v(" "),a("h4",{attrs:{id:"调用方法-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用方法-2"}},[e._v("#")]),e._v(" 调用方法")]),e._v(" "),a("ul",[a("li",[e._v("Call.Do()：声明在匹配时要运行的操作")]),e._v(" "),a("li",[e._v("Call.DoAndReturn()：声明在匹配调用时要运行的操作，并且模拟返回该函数的返回值")]),e._v(" "),a("li",[e._v("Call.MaxTimes()：设置最大的调用次数为 n 次")]),e._v(" "),a("li",[e._v("Call.MinTimes()：设置最小的调用次数为 n 次")]),e._v(" "),a("li",[e._v("Call.AnyTimes()：允许调用次数为 0 次或更多次")]),e._v(" "),a("li",[e._v("Call.Times()：设置调用次数为 n 次")])]),e._v(" "),a("h4",{attrs:{id:"参数匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数匹配"}},[e._v("#")]),e._v(" 参数匹配")]),e._v(" "),a("ul",[a("li",[e._v("gomock.Any()：匹配任意值")]),e._v(" "),a("li",[e._v("gomock.Eq()：通过反射匹配到指定的类型值，而不需要手动设置")]),e._v(" "),a("li",[e._v("gomock.Nil()：返回 nil")])]),e._v(" "),a("p",[e._v("建议更多的方法可参见 "),a("a",{attrs:{href:"https://godoc.org/github.com/golang/mock/gomock#pkg-index",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"二、生成多个-mock-文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、生成多个-mock-文件"}},[e._v("#")]),e._v(" 二、生成多个 mock 文件")]),e._v(" "),a("p",[e._v("你可能会想一条条命令生成 mock 文件，岂不得崩溃？")]),e._v(" "),a("p",[e._v("当然，官方提供了更方便的方式，我们可以利用 "),a("code",[e._v("go:generate")]),e._v(" 来完成批量处理的功能")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]\n")])])]),a("h4",{attrs:{id:"修改-interface-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改-interface-方法"}},[e._v("#")]),e._v(" 修改 interface 方法")]),e._v(" "),a("p",[e._v("打开 person/male.go 文件，修改为以下内容：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("package person\n\n//go:generate mockgen -destination=../mock/male_mock.go -package=mock github.com/EDDYCJY/mockd/person Male\n\ntype Male interface {\n\tGet(id int64) error\n}\n")])])]),a("p",[e._v("我们关注到 "),a("code",[e._v("go:generate")]),e._v(" 这条语句，可分为以下部分：")]),e._v(" "),a("ol",[a("li",[e._v("声明 "),a("code",[e._v("//go:generate")]),e._v(" （注意不要留空格）")]),e._v(" "),a("li",[e._v("使用 "),a("code",[e._v("mockgen")]),e._v(" 命令")]),e._v(" "),a("li",[e._v("定义 "),a("code",[e._v("-destination")])]),e._v(" "),a("li",[e._v("定义 "),a("code",[e._v("-package")])]),e._v(" "),a("li",[e._v("定义 "),a("code",[e._v("source")]),e._v("，此处为 person 的包路径")]),e._v(" "),a("li",[e._v("定义 "),a("code",[e._v("interfaces")]),e._v("，此处为 "),a("code",[e._v("Male")])])]),e._v(" "),a("h4",{attrs:{id:"重新生成-mock-文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重新生成-mock-文件"}},[e._v("#")]),e._v(" 重新生成 mock 文件")]),e._v(" "),a("p",[e._v("回到 "),a("code",[e._v("mockd/")]),e._v(" 的根目录下，执行以下命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ go generate ./...\n")])])]),a("p",[e._v("再检查 "),a("code",[e._v("mock/")]),e._v(" 发现也已经正确生成了，在多个文件时是不是很方便呢 🤩")]),e._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("在单元测试这一环，gomock 给我们提供了极大的便利。能够 mock 掉许许多多的依赖项")]),e._v(" "),a("p",[e._v("其中还有很多的使用方式和功能。你可以 mark 住后详细阅读下官方文档，记忆会更深刻")])])}),[],!1,null,null,null);t.default=o.exports}}]);