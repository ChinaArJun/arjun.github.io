(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{634:function(t,a,e){"use strict";e.r(a);var s=e(44),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_1-9-我要在栈上。不，你应该在堆上"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-我要在栈上。不，你应该在堆上"}},[t._v("#")]),t._v(" 1.9 我要在栈上。不，你应该在堆上")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.imgur.com/ixyP3XP.jpg",alt:"image"}})]),t._v(" "),e("p",[t._v("我们在写代码的时候，有时候会想这个变量到底分配到哪里了？这时候可能会有人说，在栈上，在堆上。信我准没错...")]),t._v(" "),e("p",[t._v("但从结果上来讲你还是一知半解，这可不行，万一被人懵了呢。今天我们一起来深挖下 Go 在这块的奥妙，自己动手丰衣足食")]),t._v(" "),e("h2",{attrs:{id:"问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('type User struct {\n\tID     int64\n\tName   string\n\tAvatar string\n}\n\nfunc GetUserInfo() *User {\n\treturn &User{ID: 13746731, Name: "EDDYCJY", Avatar: "https://avatars0.githubusercontent.com/u/13746731"}\n}\n\nfunc main() {\n\t_ = GetUserInfo()\n}\n')])])]),e("p",[t._v("开局就是一把问号，带着问题进行学习。请问 main 调用 "),e("code",[t._v("GetUserInfo")]),t._v(" 后返回的 "),e("code",[t._v("&User{...}")]),t._v("。这个变量是分配到栈上了呢，还是分配到堆上了？")]),t._v(" "),e("h2",{attrs:{id:"什么是堆-栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是堆-栈"}},[t._v("#")]),t._v(" 什么是堆/栈")]),t._v(" "),e("p",[t._v("在这里并不打算详细介绍堆栈，仅简单介绍本文所需的基础知识。如下：")]),t._v(" "),e("ul",[e("li",[t._v("堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多")]),t._v(" "),e("li",[t._v("栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上")])]),t._v(" "),e("p",[t._v("今天我们介绍的 Go 语言，它的堆栈分配是通过 Compiler 进行分析，GC 去管理的，而对其的分析选择动作就是今天探讨的重点")]),t._v(" "),e("h2",{attrs:{id:"什么是逃逸分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是逃逸分析"}},[t._v("#")]),t._v(" 什么是逃逸分析")]),t._v(" "),e("p",[t._v("在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针")]),t._v(" "),e("p",[t._v("通俗地讲，逃逸分析就是确定一个变量要放堆上还是栈上，规则如下：")]),t._v(" "),e("ol",[e("li",[t._v("是否有在其他地方（非局部）被引用。只要"),e("strong",[t._v("有可能")]),t._v("被引用了，那么它"),e("strong",[t._v("一定")]),t._v("分配到堆上。否则分配到栈上")]),t._v(" "),e("li",[t._v("即使没有被外部引用，但对象过大，无法存放在栈区上。依然有可能分配到堆上")])]),t._v(" "),e("p",[t._v("对此你可以理解为，逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为")]),t._v(" "),e("h2",{attrs:{id:"在什么阶段确立逃逸"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在什么阶段确立逃逸"}},[t._v("#")]),t._v(" 在什么阶段确立逃逸")]),t._v(" "),e("p",[t._v("在编译阶段确立逃逸，注意并不是在运行时")]),t._v(" "),e("h2",{attrs:{id:"为什么需要逃逸"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要逃逸"}},[t._v("#")]),t._v(" 为什么需要逃逸")]),t._v(" "),e("p",[t._v("这个问题我们可以反过来想，如果变量都分配到堆上了会出现什么事情？例如：")]),t._v(" "),e("ul",[e("li",[t._v("垃圾回收（GC）的压力不断增大")]),t._v(" "),e("li",[t._v("申请、分配、回收内存的系统开销增大（相对于栈）")]),t._v(" "),e("li",[t._v("动态分配产生一定量的内存碎片")])]),t._v(" "),e("p",[t._v("其实总的来说，就是频繁申请、分配堆内存是有一定 “代价” 的。会影响应用程序运行的效率，间接影响到整体系统。因此 “按需分配” 最大限度的灵活利用资源，才是正确的治理之道。这就是为什么需要逃逸分析的原因，你觉得呢？")]),t._v(" "),e("h2",{attrs:{id:"怎么确定是否逃逸"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么确定是否逃逸"}},[t._v("#")]),t._v(" 怎么确定是否逃逸")]),t._v(" "),e("p",[t._v("第一，通过编译器命令，就可以看到详细的逃逸分析过程。而指令集 "),e("code",[t._v("-gcflags")]),t._v(" 用于将标识参数传递给 Go 编译器，涉及如下：")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("-m")]),t._v(" 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 "),e("code",[t._v("-m")]),t._v("，但是信息量较大，一般用 1 个就可以了")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("-l")]),t._v(" 会禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go build -gcflags '-m -l' main.go\n")])])]),e("p",[t._v("第二，通过反编译命令查看")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go tool compile -S main.go\n")])])]),e("p",[t._v("注：可以通过 "),e("code",[t._v("go tool compile -help")]),t._v(" 查看所有允许传递给编译器的标识参数")]),t._v(" "),e("h2",{attrs:{id:"逃逸案例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#逃逸案例"}},[t._v("#")]),t._v(" 逃逸案例")]),t._v(" "),e("h3",{attrs:{id:"案例一：指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例一：指针"}},[t._v("#")]),t._v(" 案例一：指针")]),t._v(" "),e("p",[t._v("第一个案例是一开始抛出的问题，现在你再看看，想想，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('type User struct {\n\tID     int64\n\tName   string\n\tAvatar string\n}\n\nfunc GetUserInfo() *User {\n\treturn &User{ID: 13746731, Name: "EDDYCJY", Avatar: "https://avatars0.githubusercontent.com/u/13746731"}\n}\n\nfunc main() {\n\t_ = GetUserInfo()\n}\n')])])]),e("p",[t._v("执行命令观察一下，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go build -gcflags '-m -l' main.go\n# command-line-arguments\n./main.go:10:54: &User literal escapes to heap\n")])])]),e("p",[t._v("通过查看分析结果，可得知 "),e("code",[t._v("&User")]),t._v(" 逃到了堆里，也就是分配到堆上了。这是不是有问题啊...再看看汇编代码确定一下，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ go tool compile -S main.go                \n"".GetUserInfo STEXT size=190 args=0x8 locals=0x18\n\t0x0000 00000 (main.go:9)\tTEXT\t"".GetUserInfo(SB), $24-8\n\t...\n\t0x0028 00040 (main.go:10)\tMOVQ\tAX, (SP)\n\t0x002c 00044 (main.go:10)\tCALL\truntime.newobject(SB)\n\t0x0031 00049 (main.go:10)\tPCDATA\t$2, $1\n\t0x0031 00049 (main.go:10)\tMOVQ\t8(SP), AX\n\t0x0036 00054 (main.go:10)\tMOVQ\t$13746731, (AX)\n\t0x003d 00061 (main.go:10)\tMOVQ\t$7, 16(AX)\n\t0x0045 00069 (main.go:10)\tPCDATA\t$2, $-2\n\t0x0045 00069 (main.go:10)\tPCDATA\t$0, $-2\n\t0x0045 00069 (main.go:10)\tCMPL\truntime.writeBarrier(SB), $0\n\t0x004c 00076 (main.go:10)\tJNE\t156\n\t0x004e 00078 (main.go:10)\tLEAQ\tgo.string."EDDYCJY"(SB), CX\n    ...\n')])])]),e("p",[t._v("我们将目光集中到 CALL 指令，发现其执行了 "),e("code",[t._v("runtime.newobject")]),t._v(" 方法，也就是确实是分配到了堆上。这是为什么呢？")]),t._v(" "),e("h4",{attrs:{id:"分析结果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析结果"}},[t._v("#")]),t._v(" 分析结果")]),t._v(" "),e("p",[t._v("这是因为 "),e("code",[t._v("GetUserInfo()")]),t._v(" 返回的是指针对象，引用被返回到了方法之外了。因此编译器会把该对象分配到堆上，而不是栈上。否则方法结束之后，局部变量就被回收了，岂不是翻车。所以最终分配到堆上是理所当然的")]),t._v(" "),e("h4",{attrs:{id:"再想想"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#再想想"}},[t._v("#")]),t._v(" 再想想")]),t._v(" "),e("p",[t._v("那你可能会想，那就是所有指针对象，都应该在堆上？并不。如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func main() {\n\tstr := new(string)\n\t*str = "EDDYCJY"\n}\n')])])]),e("p",[t._v("你想想这个对象会分配到哪里？如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go build -gcflags '-m -l' main.go\n# command-line-arguments\n./main.go:4:12: main new(string) does not escape\n")])])]),e("p",[t._v("显然，该对象分配到栈上了。很核心的一点就是它有没有被作用域之外所引用，而这里作用域仍然保留在 "),e("code",[t._v("main")]),t._v(" 中，因此它没有发生逃逸")]),t._v(" "),e("h3",{attrs:{id:"案例二：未确定类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例二：未确定类型"}},[t._v("#")]),t._v(" 案例二：未确定类型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func main() {\n\tstr := new(string)\n\t*str = "EDDYCJY"\n\n\tfmt.Println(str)\n}\n')])])]),e("p",[t._v("执行命令观察一下，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go build -gcflags '-m -l' main.go\n# command-line-arguments\n./main.go:9:13: str escapes to heap\n./main.go:6:12: new(string) escapes to heap\n./main.go:9:13: main ... argument does not escape\n")])])]),e("p",[t._v("通过查看分析结果，可得知 "),e("code",[t._v("str")]),t._v(" 变量逃到了堆上，也就是该对象在堆上分配。但上个案例时它还在栈上，我们也就 "),e("code",[t._v("fmt")]),t._v(" 输出了它而已。这...到底发生了什么事？")]),t._v(" "),e("h4",{attrs:{id:"分析结果-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析结果-2"}},[t._v("#")]),t._v(" 分析结果")]),t._v(" "),e("p",[t._v("相对案例一，案例二只加了一行代码 "),e("code",[t._v("fmt.Println(str)")]),t._v("，问题肯定出在它身上。其原型：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func Println(a ...interface{}) (n int, err error)\n")])])]),e("p",[t._v("通过对其分析，可得知当形参为 "),e("code",[t._v("interface")]),t._v(" 类型时，在编译阶段编译器无法确定其具体的类型。因此会产生逃逸，最终分配到堆上")]),t._v(" "),e("p",[t._v("如果你有兴趣追源码的话，可以看下内部的 "),e("code",[t._v("reflect.TypeOf(arg).Kind()")]),t._v(" 语句，其会造成堆逃逸，而表象就是 "),e("code",[t._v("interface")]),t._v(" 类型会导致该对象分配到堆上")]),t._v(" "),e("h3",{attrs:{id:"案例三、泄露参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例三、泄露参数"}},[t._v("#")]),t._v(" 案例三、泄露参数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('type User struct {\n\tID     int64\n\tName   string\n\tAvatar string\n}\n\nfunc GetUserInfo(u *User) *User {\n\treturn u\n}\n\nfunc main() {\n\t_ = GetUserInfo(&User{ID: 13746731, Name: "EDDYCJY", Avatar: "https://avatars0.githubusercontent.com/u/13746731"})\n}\n')])])]),e("p",[t._v("执行命令观察一下，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go build -gcflags '-m -l' main.go\n# command-line-arguments\n./main.go:9:18: leaking param: u to result ~r1 level=0\n./main.go:14:63: main &User literal does not escape\n")])])]),e("p",[t._v("我们注意到 "),e("code",[t._v("leaking param")]),t._v(" 的表述，它说明了变量 "),e("code",[t._v("u")]),t._v(" 是一个泄露参数。结合代码可得知其传给 "),e("code",[t._v("GetUserInfo")]),t._v(" 方法后，没有做任何引用之类的涉及变量的动作，直接就把这个变量返回出去了。因此这个变量实际上并没有逃逸，它的作用域还在 "),e("code",[t._v("main()")]),t._v(" 之中，所以分配在栈上")]),t._v(" "),e("h4",{attrs:{id:"再想想-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#再想想-2"}},[t._v("#")]),t._v(" 再想想")]),t._v(" "),e("p",[t._v("那你再想想怎么样才能让它分配到堆上？结合案例一，举一反三。修改如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('type User struct {\n\tID     int64\n\tName   string\n\tAvatar string\n}\n\nfunc GetUserInfo(u User) *User {\n\treturn &u\n}\n\nfunc main() {\n\t_ = GetUserInfo(User{ID: 13746731, Name: "EDDYCJY", Avatar: "https://avatars0.githubusercontent.com/u/13746731"})\n}\n')])])]),e("p",[t._v("执行命令观察一下，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go build -gcflags '-m -l' main.go\n# command-line-arguments\n./main.go:10:9: &u escapes to heap\n./main.go:9:18: moved to heap: u\n")])])]),e("p",[t._v("只要一小改，它就考虑会被外部所引用，因此妥妥的分配到堆上了")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("在本文我给你介绍了逃逸分析的概念和规则，并列举了一些例子加深理解。但实际肯定远远不止这些案例，你需要做到的是掌握方法，遇到再看就好了。除此之外你还需要注意：")]),t._v(" "),e("ul",[e("li",[t._v("静态分配到栈上，性能一定比动态分配到堆上好")]),t._v(" "),e("li",[t._v("底层分配到堆，还是栈。实际上对你来说是透明的，不需要过度关心")]),t._v(" "),e("li",[t._v("每个 Go 版本的逃逸分析都会有所不同（会改变，会优化）")]),t._v(" "),e("li",[t._v("直接通过 "),e("code",[t._v("go build -gcflags '-m -l'")]),t._v(" 就可以看到逃逸分析的过程和结果")]),t._v(" "),e("li",[t._v("到处都用指针传递并不一定是最好的，要用对")])]),t._v(" "),e("p",[t._v("之前就有想过要不要写 “逃逸分析” 相关的文章，直到最近看到在夜读里有人问，还是有写的必要。对于这块的知识点。我的建议是适当了解，但没必要硬记。靠基础知识点加命令调试观察就好了。像是曹大之前讲的 “你琢磨半天逃逸分析，一压测，瓶颈在锁上”，完全没必要过度在意...")]),t._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Golang escape analysis"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://golang.org/doc/faq#stack_or_heap",target:"_blank",rel:"noopener noreferrer"}},[t._v("FAQ"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90",target:"_blank",rel:"noopener noreferrer"}},[t._v("逃逸分析"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=n.exports}}]);