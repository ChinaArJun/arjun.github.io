(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{635:function(t,e,r){"use strict";r.r(e);var n=r(44),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_1-11-从实践到原理，带你参透-grpc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-11-从实践到原理，带你参透-grpc"}},[t._v("#")]),t._v(" 1.11 从实践到原理，带你参透 gRPC")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/cjLNsWj.png",alt:"image"}})]),t._v(" "),r("p",[t._v("gRPC 在 Go 语言中大放异彩，越来越多的小伙伴在使用，最近也在公司安利了一波，希望这一篇文章能带你一览 gRPC 的巧妙之处，本文篇幅比较长，请做好阅读准备。本文目录如下：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/TYvrtlc.jpg",alt:"image"}})]),t._v(" "),r("h2",{attrs:{id:"简述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简述"}},[t._v("#")]),t._v(" 简述")]),t._v(" "),r("p",[t._v("gRPC  是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持。")]),t._v(" "),r("p",[t._v("gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。")]),t._v(" "),r("h2",{attrs:{id:"调用模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#调用模型"}},[t._v("#")]),t._v(" 调用模型")]),t._v(" "),r("p",[r("img",{attrs:{src:"http://www.grpc.io/img/grpc_concept_diagram_00.png",alt:"image"}})]),t._v(" "),r("p",[t._v("1、客户端（gRPC Stub）调用 A 方法，发起 RPC 调用。")]),t._v(" "),r("p",[t._v("2、对请求信息使用 Protobuf 进行对象序列化压缩（IDL）。")]),t._v(" "),r("p",[t._v("3、服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回。")]),t._v(" "),r("p",[t._v("4、对响应结果使用 Protobuf 进行对象序列化压缩（IDL）。")]),t._v(" "),r("p",[t._v("5、客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果。")]),t._v(" "),r("h2",{attrs:{id:"调用方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#调用方式"}},[t._v("#")]),t._v(" 调用方式")]),t._v(" "),r("h3",{attrs:{id:"一、unary-rpc：一元-rpc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、unary-rpc：一元-rpc"}},[t._v("#")]),t._v(" 一、Unary RPC：一元 RPC")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/Z3V3hl1.png",alt:"image"}})]),t._v(" "),r("h4",{attrs:{id:"server"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[t._v("#")]),t._v(" Server")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('type SearchService struct{}\n\nfunc (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {\n    return &pb.SearchResponse{Response: r.GetRequest() + " Server"}, nil\n}\n\nconst PORT = "9001"\n\nfunc main() {\n    server := grpc.NewServer()\n    pb.RegisterSearchServiceServer(server, &SearchService{})\n\n    lis, err := net.Listen("tcp", ":"+PORT)\n    ...\n\n    server.Serve(lis)\n}\n')])])]),r("ul",[r("li",[t._v("创建 gRPC Server 对象，你可以理解为它是 Server 端的抽象对象。")]),t._v(" "),r("li",[t._v("将 SearchService（其包含需要被调用的服务端接口）注册到 gRPC Server。 的内部注册中心。这样可以在接受到请求时，通过内部的 “服务发现”，发现该服务端接口并转接进行逻辑处理。")]),t._v(" "),r("li",[t._v("创建 Listen，监听 TCP 端口。")]),t._v(" "),r("li",[t._v("gRPC Server 开始 lis.Accept，直到 Stop 或 GracefulStop。")])]),t._v(" "),r("h4",{attrs:{id:"client"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#client"}},[t._v("#")]),t._v(" Client")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('func main() {\n    conn, err := grpc.Dial(":"+PORT, grpc.WithInsecure())\n    ...\n    defer conn.Close()\n\n    client := pb.NewSearchServiceClient(conn)\n    resp, err := client.Search(context.Background(), &pb.SearchRequest{\n        Request: "gRPC",\n    })\n    ...\n}\n')])])]),r("ul",[r("li",[t._v("创建与给定目标（服务端）的连接句柄。")]),t._v(" "),r("li",[t._v("创建 SearchService 的客户端对象。")]),t._v(" "),r("li",[t._v("发送 RPC 请求，等待同步响应，得到回调后返回响应结果。")])]),t._v(" "),r("h3",{attrs:{id:"二、server-side-streaming-rpc：服务端流式-rpc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、server-side-streaming-rpc：服务端流式-rpc"}},[t._v("#")]),t._v(" 二、Server-side streaming RPC：服务端流式 RPC")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/W7g3kSC.png",alt:"image"}})]),t._v(" "),r("h4",{attrs:{id:"server-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#server-2"}},[t._v("#")]),t._v(" Server")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func (s *StreamService) List(r *pb.StreamRequest, stream pb.StreamService_ListServer) error {\n    for n := 0; n <= 6; n++ {\n        stream.Send(&pb.StreamResponse{\n            Pt: &pb.StreamPoint{\n                ...\n            },\n        })\n    }\n\n    return nil\n}\n")])])]),r("h4",{attrs:{id:"client-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#client-2"}},[t._v("#")]),t._v(" Client")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func printLists(client pb.StreamServiceClient, r *pb.StreamRequest) error {\n    stream, err := client.List(context.Background(), r)\n    ...\n    \n    for {\n        resp, err := stream.Recv()\n        if err == io.EOF {\n            break\n        }\n        ...\n    }\n\n    return nil\n}\n")])])]),r("h3",{attrs:{id:"三、client-side-streaming-rpc：客户端流式-rpc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、client-side-streaming-rpc：客户端流式-rpc"}},[t._v("#")]),t._v(" 三、Client-side streaming RPC：客户端流式 RPC")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/e60IAxT.png",alt:"image"}})]),t._v(" "),r("h4",{attrs:{id:"server-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#server-3"}},[t._v("#")]),t._v(" Server")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func (s *StreamService) Record(stream pb.StreamService_RecordServer) error {\n    for {\n        r, err := stream.Recv()\n        if err == io.EOF {\n            return stream.SendAndClose(&pb.StreamResponse{Pt: &pb.StreamPoint{...}})\n        }\n        ...\n\n    }\n\n    return nil\n}\n")])])]),r("h4",{attrs:{id:"client-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#client-3"}},[t._v("#")]),t._v(" Client")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func printRecord(client pb.StreamServiceClient, r *pb.StreamRequest) error {\n    stream, err := client.Record(context.Background())\n    ...\n    \n    for n := 0; n < 6; n++ {\n        stream.Send(r)\n    }\n\n    resp, err := stream.CloseAndRecv()\n    ...\n\n    return nil\n}\n")])])]),r("h3",{attrs:{id:"四、bidirectional-streaming-rpc：双向流式-rpc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四、bidirectional-streaming-rpc：双向流式-rpc"}},[t._v("#")]),t._v(" 四、Bidirectional streaming RPC：双向流式 RPC")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/DCcxwfj.png",alt:"image"}})]),t._v(" "),r("h4",{attrs:{id:"server-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#server-4"}},[t._v("#")]),t._v(" Server")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func (s *StreamService) Route(stream pb.StreamService_RouteServer) error {\n    for {\n        stream.Send(&pb.StreamResponse{...})\n        r, err := stream.Recv()\n        if err == io.EOF {\n            return nil\n        }\n        ...\n    }\n\n    return nil\n}\n")])])]),r("h4",{attrs:{id:"client-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#client-4"}},[t._v("#")]),t._v(" Client")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func printRoute(client pb.StreamServiceClient, r *pb.StreamRequest) error {\n    stream, err := client.Route(context.Background())\n    ...\n\n    for n := 0; n <= 6; n++ {\n        stream.Send(r)\n        resp, err := stream.Recv()\n        if err == io.EOF {\n            break\n        }\n        ...\n    }\n\n    stream.CloseSend()\n\n    return nil\n}\n")])])]),r("h2",{attrs:{id:"客户端与服务端是如何交互的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#客户端与服务端是如何交互的"}},[t._v("#")]),t._v(" 客户端与服务端是如何交互的")]),t._v(" "),r("p",[t._v("在开始分析之前，我们要先 gRPC 的调用有一个初始印象。那么最简单的就是对 Client 端调用 Server 端进行抓包去剖析，看看整个过程中它都做了些什么事。如下图：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/H0HPgv9.jpg",alt:"image"}})]),t._v(" "),r("ul",[r("li",[t._v("Magic")]),t._v(" "),r("li",[t._v("SETTINGS")]),t._v(" "),r("li",[t._v("HEADERS")]),t._v(" "),r("li",[t._v("DATA")]),t._v(" "),r("li",[t._v("SETTINGS")]),t._v(" "),r("li",[t._v("WINDOW_UPDATE")]),t._v(" "),r("li",[t._v("PING")]),t._v(" "),r("li",[t._v("HEADERS")]),t._v(" "),r("li",[t._v("DATA")]),t._v(" "),r("li",[t._v("HEADERS")]),t._v(" "),r("li",[t._v("WINDOW_UPDATE")]),t._v(" "),r("li",[t._v("PING")])]),t._v(" "),r("p",[t._v("我们略加整理发现共有十二个行为，是比较重要的。在开始分析之前，建议你自己先想一下，它们的作用都是什么？大胆猜测一下，带着疑问去学习效果更佳。")]),t._v(" "),r("h3",{attrs:{id:"行为分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#行为分析"}},[t._v("#")]),t._v(" 行为分析")]),t._v(" "),r("h4",{attrs:{id:"magic"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#magic"}},[t._v("#")]),t._v(" Magic")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/fFkwLPK.jpg",alt:"image"}})]),t._v(" "),r("p",[t._v("Magic 帧的主要作用是建立 HTTP/2 请求的前言。在 HTTP/2 中，要求两端都要发送一个连接前言，作为对所使用协议的最终确认，并确定 HTTP/2 连接的初始设置，客户端和服务端各自发送不同的连接前言。")]),t._v(" "),r("p",[t._v("而上图中的 Magic 帧是客户端的前言之一，内容为 "),r("code",[t._v("PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n")]),t._v("，以确定启用 HTTP/2 连接。")]),t._v(" "),r("h4",{attrs:{id:"settings"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#settings"}},[t._v("#")]),t._v(" SETTINGS")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/wSCvLtb.jpg",alt:"image"}})]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/0780hAb.jpg",alt:"image"}})]),t._v(" "),r("p",[t._v("SETTINGS 帧的主要作用是设置这一个连接的参数，作用域是整个连接而并非单一的流。")]),t._v(" "),r("p",[t._v("而上图的 SETTINGS 帧都是空 SETTINGS 帧，图一是客户端连接的前言（Magic 和 SETTINGS 帧分别组成连接前言）。图二是服务端的。另外我们从图中可以看到多个 SETTINGS 帧，这是为什么呢？是因为发送完连接前言后，客户端和服务端还需要有一步互动确认的动作。对应的就是带有 ACK 标识 SETTINGS 帧。")]),t._v(" "),r("h4",{attrs:{id:"headers"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#headers"}},[t._v("#")]),t._v(" HEADERS")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/cfDGkPS.jpg",alt:"image"}})]),t._v(" "),r("p",[t._v("HEADERS 帧的主要作用是存储和传播 HTTP 的标头信息。我们关注到 HEADERS 里有一些眼熟的信息，分别如下：")]),t._v(" "),r("ul",[r("li",[t._v("method：POST")]),t._v(" "),r("li",[t._v("scheme：http")]),t._v(" "),r("li",[t._v("path：/proto.SearchService/Search")]),t._v(" "),r("li",[t._v("authority：:10001")]),t._v(" "),r("li",[t._v("content-type：application/grpc")]),t._v(" "),r("li",[t._v("user-agent：grpc-go/1.20.0-dev")])]),t._v(" "),r("p",[t._v("你会发现这些东西非常眼熟，其实都是 gRPC 的基础属性，实际上远远不止这些，只是设置了多少展示多少。例如像平时常见的 "),r("code",[t._v("grpc-timeout")]),t._v("、"),r("code",[t._v("grpc-encoding")]),t._v(" 也是在这里设置的。")]),t._v(" "),r("h4",{attrs:{id:"data"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#data"}},[t._v("#")]),t._v(" DATA")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/EbsbREx.jpg",alt:"image"}})]),t._v(" "),r("p",[t._v("DATA 帧的主要作用是装填主体信息，是数据帧。而在上图中，可以很明显看到我们的请求参数 gRPC 存储在里面。只需要了解到这一点就可以了。")]),t._v(" "),r("h4",{attrs:{id:"headers-data-headers"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#headers-data-headers"}},[t._v("#")]),t._v(" HEADERS, DATA, HEADERS")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/ZHGY0K6.jpg",alt:"image"}})]),t._v(" "),r("p",[t._v("在上图中 HEADERS 帧比较简单，就是告诉我们 HTTP 响应状态和响应的内容格式。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/u0Js4iF.jpg",alt:"imgae"}})]),t._v(" "),r("p",[t._v("在上图中 DATA 帧主要承载了响应结果的数据集，图中的 gRPC Server 就是我们 RPC 方法的响应结果。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/5SPNVYk.jpg",alt:"image"}})]),t._v(" "),r("p",[t._v("在上图中 HEADERS 帧主要承载了 gRPC 状态 和 gRPC 状态消息，图中的 "),r("code",[t._v("grpc-status")]),t._v(" 和 "),r("code",[t._v("grpc-message")]),t._v(" 就是我们的 gRPC 调用状态的结果。")]),t._v(" "),r("h3",{attrs:{id:"其它步骤"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#其它步骤"}},[t._v("#")]),t._v(" 其它步骤")]),t._v(" "),r("h4",{attrs:{id:"window-update"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#window-update"}},[t._v("#")]),t._v(" WINDOW_UPDATE")]),t._v(" "),r("p",[t._v("主要作用是管理和流的窗口控制。通常情况下打开一个连接后，服务器和客户端会立即交换 SETTINGS 帧来确定流控制窗口的大小。默认情况下，该大小设置为约 65 KB，但可通过发出一个 WINDOW_UPDATE 帧为流控制设置不同的大小。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/MVsSKSx.jpg",alt:"image"}})]),t._v(" "),r("h4",{attrs:{id:"ping-pong"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ping-pong"}},[t._v("#")]),t._v(" PING/PONG")]),t._v(" "),r("p",[t._v("主要作用是判断当前连接是否仍然可用，也常用于计算往返时间。其实也就是 PING/PONG，大家对此应该很熟。")]),t._v(" "),r("h3",{attrs:{id:"小结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/FrA8EW4.png",alt:"image"}})]),t._v(" "),r("ul",[r("li",[t._v("在建立连接之前，客户端/服务端都会发送"),r("strong",[t._v("连接前言")]),t._v("（Magic+SETTINGS），确立协议和配置项。")]),t._v(" "),r("li",[t._v("在传输数据时，是会涉及滑动窗口（WINDOW_UPDATE）等流控策略的。")]),t._v(" "),r("li",[t._v("传播 gRPC 附加信息时，是基于 HEADERS 帧进行传播和设置；而具体的请求/响应数据是存储的 DATA 帧中的。")]),t._v(" "),r("li",[t._v("请求/响应结果会分为 HTTP 和 gRPC 状态响应两种类型。")]),t._v(" "),r("li",[t._v("客户端发起 PING，服务端就会回应 PONG，反之亦可。")])]),t._v(" "),r("p",[t._v("这块 gRPC 的基础使用，你可以看看我另外的 "),r("a",{attrs:{href:"https://github.com/EDDYCJY/blog#grpc%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95",target:"_blank",rel:"noopener noreferrer"}},[t._v("《gRPC 入门系列》"),r("OutboundLink")],1),t._v("，相信对你一定有帮助。")]),t._v(" "),r("h2",{attrs:{id:"浅谈理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浅谈理解"}},[t._v("#")]),t._v(" 浅谈理解")]),t._v(" "),r("h3",{attrs:{id:"服务端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务端"}},[t._v("#")]),t._v(" 服务端")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/xgcsjiQ.png",alt:"image"}})]),t._v(" "),r("p",[t._v("为什么四行代码，就能够起一个 gRPC Server，内部做了什么逻辑。你有想过吗？接下来我们一步步剖析，看看里面到底是何方神圣。")]),t._v(" "),r("h3",{attrs:{id:"一、初始化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、初始化"}},[t._v("#")]),t._v(" 一、初始化")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// grpc.NewServer()\nfunc NewServer(opt ...ServerOption) *Server {\n\topts := defaultServerOptions\n\tfor _, o := range opt {\n\t\to(&opts)\n\t}\n\ts := &Server{\n\t\tlis:    make(map[net.Listener]bool),\n\t\topts:   opts,\n\t\tconns:  make(map[io.Closer]bool),\n\t\tm:      make(map[string]*service),\n\t\tquit:   make(chan struct{}),\n\t\tdone:   make(chan struct{}),\n\t\tczData: new(channelzData),\n\t}\n\ts.cv = sync.NewCond(&s.mu)\n\t...\n\n\treturn s\n}\n")])])]),r("p",[t._v("这块比较简单，主要是实例 grpc.Server 并进行初始化动作。涉及如下：")]),t._v(" "),r("ul",[r("li",[t._v("lis：监听地址列表。")]),t._v(" "),r("li",[t._v("opts：服务选项，这块包含 Credentials、Interceptor 以及一些基础配置。")]),t._v(" "),r("li",[t._v("conns：客户端连接句柄列表。")]),t._v(" "),r("li",[t._v("m：服务信息映射。")]),t._v(" "),r("li",[t._v("quit：退出信号。")]),t._v(" "),r("li",[t._v("done：完成信号。")]),t._v(" "),r("li",[t._v("czData：用于存储 ClientConn，addrConn 和 Server 的channelz 相关数据。")]),t._v(" "),r("li",[t._v("cv：当优雅退出时，会等待这个信号量，直到所有 RPC 请求都处理并断开才会继续处理。")])]),t._v(" "),r("h3",{attrs:{id:"二、注册"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、注册"}},[t._v("#")]),t._v(" 二、注册")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("pb.RegisterSearchServiceServer(server, &SearchService{})\n")])])]),r("h4",{attrs:{id:"步骤一：service-api-interface"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#步骤一：service-api-interface"}},[t._v("#")]),t._v(" 步骤一：Service API interface")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// search.pb.go\ntype SearchServiceServer interface {\n\tSearch(context.Context, *SearchRequest) (*SearchResponse, error)\n}\n\nfunc RegisterSearchServiceServer(s *grpc.Server, srv SearchServiceServer) {\n\ts.RegisterService(&_SearchService_serviceDesc, srv)\n}\n")])])]),r("p",[t._v("还记得我们平时编写的 Protobuf 吗？在生成出来的 "),r("code",[t._v(".pb.go")]),t._v(" 文件中，会定义出 Service APIs interface 的具体实现约束。而我们在 gRPC Server 进行注册时，会传入应用 Service 的功能接口实现，此时生成的 "),r("code",[t._v("RegisterServer")]),t._v(" 方法就会保证两者之间的一致性。")]),t._v(" "),r("h4",{attrs:{id:"步骤二：service-api-idl"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#步骤二：service-api-idl"}},[t._v("#")]),t._v(" 步骤二：Service API IDL")]),t._v(" "),r("p",[t._v("你想乱传糊弄一下？不可能的，请乖乖定义与 Protobuf 一致的接口方法。但是那个 "),r("code",[t._v("&_SearchService_serviceDesc")]),t._v(" 又有什么作用呢？代码如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('// search.pb.go\nvar _SearchService_serviceDesc = grpc.ServiceDesc{\n\tServiceName: "proto.SearchService",\n\tHandlerType: (*SearchServiceServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: "Search",\n\t\t\tHandler:    _SearchService_Search_Handler,\n\t\t},\n\t},\n\tStreams:  []grpc.StreamDesc{},\n\tMetadata: "search.proto",\n}\n')])])]),r("p",[t._v("这看上去像服务的描述代码，用来向内部表述 “我” 都有什么。涉及如下:")]),t._v(" "),r("ul",[r("li",[t._v("ServiceName：服务名称")]),t._v(" "),r("li",[t._v("HandlerType：服务接口，用于检查用户提供的实现是否满足接口要求")]),t._v(" "),r("li",[t._v("Methods：一元方法集，注意结构内的 "),r("code",[t._v("Handler")]),t._v(" 方法，其对应最终的 RPC 处理方法，在执行 RPC 方法的阶段会使用。")]),t._v(" "),r("li",[t._v("Streams：流式方法集")]),t._v(" "),r("li",[t._v("Metadata：元数据，是一个描述数据属性的东西。在这里主要是描述 "),r("code",[t._v("SearchServiceServer")]),t._v(" 服务")])]),t._v(" "),r("h4",{attrs:{id:"步骤三：register-service"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#步骤三：register-service"}},[t._v("#")]),t._v(" 步骤三：Register Service")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func (s *Server) register(sd *ServiceDesc, ss interface{}) {\n    ...\n\tsrv := &service{\n\t\tserver: ss,\n\t\tmd:     make(map[string]*MethodDesc),\n\t\tsd:     make(map[string]*StreamDesc),\n\t\tmdata:  sd.Metadata,\n\t}\n\tfor i := range sd.Methods {\n\t\td := &sd.Methods[i]\n\t\tsrv.md[d.MethodName] = d\n\t}\n\tfor i := range sd.Streams {\n\t\t...\n\t}\n\ts.m[sd.ServiceName] = srv\n}\n")])])]),r("p",[t._v("在最后一步中，我们会将先前的服务接口信息、服务描述信息给注册到内部 "),r("code",[t._v("service")]),t._v(" 去，以便于后续实际调用的使用。涉及如下：")]),t._v(" "),r("ul",[r("li",[t._v("server：服务的接口信息")]),t._v(" "),r("li",[t._v("md：一元服务的 RPC 方法集")]),t._v(" "),r("li",[t._v("sd：流式服务的 RPC 方法集")]),t._v(" "),r("li",[t._v("mdata：metadata，元数据")])]),t._v(" "),r("h4",{attrs:{id:"小结-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#小结-2"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),r("p",[t._v("在这一章节中，主要介绍的是 gRPC Server 在启动前的整理和注册行为，看上去很简单，但其实一切都是为了后续的实际运行的预先准备。因此我们整理一下思路，将其串联起来看看，如下：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/vvBWEyx.png",alt:"image"}})]),t._v(" "),r("h3",{attrs:{id:"三、监听"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、监听"}},[t._v("#")]),t._v(" 三、监听")]),t._v(" "),r("p",[t._v("接下来到了整个流程中，最重要也是大家最关注的监听/处理阶段，核心代码如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func (s *Server) Serve(lis net.Listener) error {\n\t...\n\tvar tempDelay time.Duration \n\tfor {\n\t\trawConn, err := lis.Accept()\n\t\tif err != nil {\n\t\t\tif ne, ok := err.(interface {\n\t\t\t\tTemporary() bool\n\t\t\t}); ok && ne.Temporary() {\n\t\t\t\tif tempDelay == 0 {\n\t\t\t\t\ttempDelay = 5 * time.Millisecond\n\t\t\t\t} else {\n\t\t\t\t\ttempDelay *= 2\n\t\t\t\t}\n\t\t\t\tif max := 1 * time.Second; tempDelay > max {\n\t\t\t\t\ttempDelay = max\n\t\t\t\t}\n\t\t\t\t...\n\t\t\t\ttimer := time.NewTimer(tempDelay)\n\t\t\t\tselect {\n\t\t\t\tcase <-timer.C:\n\t\t\t\tcase <-s.quit:\n\t\t\t\t\ttimer.Stop()\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t...\n\t\t\treturn err\n\t\t}\n\t\ttempDelay = 0\n\n\t\ts.serveWG.Add(1)\n\t\tgo func() {\n\t\t\ts.handleRawConn(rawConn)\n\t\t\ts.serveWG.Done()\n\t\t}()\n\t}\n}\n")])])]),r("p",[t._v("Serve 会根据外部传入的 Listener 不同而调用不同的监听模式，这也是 "),r("code",[t._v("net.Listener")]),t._v(" 的魅力，灵活性和扩展性会比较高。而在 gRPC Server 中最常用的就是 "),r("code",[t._v("TCPConn")]),t._v("，基于 TCP Listener 去做。接下来我们一起看看具体的处理逻辑，如下：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/SYrkt0d.png",alt:"image"}})]),t._v(" "),r("ul",[r("li",[t._v("循环处理连接，通过 "),r("code",[t._v("lis.Accept")]),t._v(" 取出连接，如果队列中没有需处理的连接时，会形成阻塞等待。")]),t._v(" "),r("li",[t._v("若 "),r("code",[t._v("lis.Accept")]),t._v(" 失败，则触发休眠机制，若为第一次失败那么休眠 5ms，否则翻倍，再次失败则不断翻倍直至上限休眠时间 1s，而休眠完毕后就会尝试去取下一个 “它”。")]),t._v(" "),r("li",[t._v("若 "),r("code",[t._v("lis.Accept")]),t._v(" 成功，则重置休眠的时间计数和启动一个新的 goroutine 调用 "),r("code",[t._v("handleRawConn")]),t._v(" 方法去执行/处理新的请求，也就是大家很喜欢说的 “每一个请求都是不同的 goroutine 在处理”。")]),t._v(" "),r("li",[t._v("在循环过程中，包含了 “退出” 服务的场景，主要是硬关闭和优雅重启服务两种情况。")])]),t._v(" "),r("h2",{attrs:{id:"客户端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#客户端"}},[t._v("#")]),t._v(" 客户端")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/xK0QsIm.png",alt:"image"}})]),t._v(" "),r("h3",{attrs:{id:"一、创建拨号连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、创建拨号连接"}},[t._v("#")]),t._v(" 一、创建拨号连接")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('// grpc.Dial(":"+PORT, grpc.WithInsecure())\nfunc DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) {\n\tcc := &ClientConn{\n\t\ttarget:            target,\n\t\tcsMgr:             &connectivityStateManager{},\n\t\tconns:             make(map[*addrConn]struct{}),\n\t\tdopts:             defaultDialOptions(),\n\t\tblockingpicker:    newPickerWrapper(),\n\t\tczData:            new(channelzData),\n\t\tfirstResolveEvent: grpcsync.NewEvent(),\n\t}\n\t...\n\tchainUnaryClientInterceptors(cc)\n\tchainStreamClientInterceptors(cc)\n\n\t...\n}\n')])])]),r("p",[r("code",[t._v("grpc.Dial")]),t._v(" 方法实际上是对于 "),r("code",[t._v("grpc.DialContext")]),t._v(" 的封装，区别在于 "),r("code",[t._v("ctx")]),t._v(" 是直接传入 "),r("code",[t._v("context.Background")]),t._v("。其主要功能是"),r("strong",[t._v("创建")]),t._v("与给定目标的客户端连接，其承担了以下职责：")]),t._v(" "),r("ul",[r("li",[t._v("初始化 ClientConn")]),t._v(" "),r("li",[t._v("初始化（基于进程 LB）负载均衡配置")]),t._v(" "),r("li",[t._v("初始化 channelz")]),t._v(" "),r("li",[t._v("初始化重试规则和客户端一元/流式拦截器")]),t._v(" "),r("li",[t._v("初始化协议栈上的基础信息")]),t._v(" "),r("li",[t._v("相关 context 的超时控制")]),t._v(" "),r("li",[t._v("初始化并解析地址信息")]),t._v(" "),r("li",[t._v("创建与服务端之间的连接")])]),t._v(" "),r("h4",{attrs:{id:"连没连"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#连没连"}},[t._v("#")]),t._v(" 连没连")]),t._v(" "),r("p",[t._v("之前听到有的人说调用 "),r("code",[t._v("grpc.Dial")]),t._v(" 后客户端就已经与服务端建立起了连接，但这对不对呢？我们先鸟瞰全貌，看看正在跑的 goroutine。如下：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/yPK1KZn.jpg",alt:"image"}})]),t._v(" "),r("p",[t._v("我们可以有几个核心方法一直在等待/处理信号，通过分析底层源码可得知。涉及如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func (ac *addrConn) connect()\nfunc (ac *addrConn) resetTransport()\nfunc (ac *addrConn) createTransport(addr resolver.Address, copts transport.ConnectOptions, connectDeadline time.Time)\nfunc (ac *addrConn) getReadyTransport()\n")])])]),r("p",[t._v("在这里主要分析 goroutine 提示的 "),r("code",[t._v("resetTransport")]),t._v(" 方法，看看都做了啥。核心代码如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func (ac *addrConn) resetTransport() {\n\tfor i := 0; ; i++ {\n\t\tif ac.state == connectivity.Shutdown {\n\t\t\treturn\n\t\t}\n\t\t...\n\t\tconnectDeadline := time.Now().Add(dialDuration)\n\t\tac.updateConnectivityState(connectivity.Connecting)\n\t\tnewTr, addr, reconnect, err := ac.tryAllAddrs(addrs, connectDeadline)\n\t\tif err != nil {\n\t\t\tif ac.state == connectivity.Shutdown {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tac.updateConnectivityState(connectivity.TransientFailure)\n\t\t\ttimer := time.NewTimer(backoffFor)\n\t\t\tselect {\n\t\t\tcase <-timer.C:\n\t\t\t\t...\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif ac.state == connectivity.Shutdown {\n\t\t\tnewTr.Close()\n\t\t\treturn\n\t\t}\n\t\t...\n\t\tif !healthcheckManagingState {\n\t\t\tac.updateConnectivityState(connectivity.Ready)\n\t\t}\n\t\t...\n\n\t\tif ac.state == connectivity.Shutdown {\n\t\t\treturn\n\t\t}\n\t\tac.updateConnectivityState(connectivity.TransientFailure)\n\t}\n}\n")])])]),r("p",[t._v("在该方法中会不断地去尝试创建连接，若成功则结束。否则不断地根据 "),r("code",[t._v("Backoff")]),t._v(" 算法的重试机制去尝试创建连接，直到成功为止。从结论上来讲，单纯调用 "),r("code",[t._v("DialContext")]),t._v(" 是异步建立连接的，也就是并不是马上生效，处于 "),r("code",[t._v("Connecting")]),t._v(" 状态，而正式下要到达 "),r("code",[t._v("Ready")]),t._v(" 状态才可用。")]),t._v(" "),r("h4",{attrs:{id:"真的连了吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#真的连了吗"}},[t._v("#")]),t._v(" 真的连了吗")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/hYklktM.jpg",alt:"image"}})]),t._v(" "),r("p",[t._v("在抓包工具上提示一个包都没有，那么这算真正连接了吗？我认为这是一个表述问题，我们应该尽可能的严谨。如果你真的想通过 "),r("code",[t._v("DialContext")]),t._v(" 方法就打通与服务端的连接，则需要调用 "),r("code",[t._v("WithBlock")]),t._v(" 方法，虽然会导致阻塞等待，但最终连接会到达 "),r("code",[t._v("Ready")]),t._v(" 状态（握手成功）。如下图：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/jHNuIYR.jpg",alt:"image"}})]),t._v(" "),r("h3",{attrs:{id:"二、实例化-service-api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、实例化-service-api"}},[t._v("#")]),t._v(" 二、实例化 Service API")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("type SearchServiceClient interface {\n\tSearch(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)\n}\n\ntype searchServiceClient struct {\n\tcc *grpc.ClientConn\n}\n\nfunc NewSearchServiceClient(cc *grpc.ClientConn) SearchServiceClient {\n\treturn &searchServiceClient{cc}\n}\n")])])]),r("p",[t._v("这块就是实例 Service API interface，比较简单。")]),t._v(" "),r("h3",{attrs:{id:"三、调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、调用"}},[t._v("#")]),t._v(" 三、调用")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('// search.pb.go\nfunc (c *searchServiceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {\n\tout := new(SearchResponse)\n\terr := c.cc.Invoke(ctx, "/proto.SearchService/Search", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n')])])]),r("p",[t._v("proto 生成的 RPC 方法更像是一个包装盒，把需要的东西放进去，而实际上调用的还是 "),r("code",[t._v("grpc.invoke")]),t._v(" 方法。如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func invoke(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, opts ...CallOption) error {\n\tcs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := cs.SendMsg(req); err != nil {\n\t\treturn err\n\t}\n\treturn cs.RecvMsg(reply)\n}\n")])])]),r("p",[t._v("通过概览，可以关注到三块调用。如下：")]),t._v(" "),r("ul",[r("li",[t._v("newClientStream：获取传输层 Trasport 并组合封装到 ClientStream 中返回，在这块会涉及负载均衡、超时控制、 Encoding、 Stream 的动作，与服务端基本一致的行为。")]),t._v(" "),r("li",[t._v("cs.SendMsg：发送 RPC 请求出去，但其并不承担等待响应的功能。")]),t._v(" "),r("li",[t._v("cs.RecvMsg：阻塞等待接受到的 RPC 方法响应结果。")])]),t._v(" "),r("h4",{attrs:{id:"连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[t._v("#")]),t._v(" 连接")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// clientconn.go\nfunc (cc *ClientConn) getTransport(ctx context.Context, failfast bool, method string) (transport.ClientTransport, func(balancer.DoneInfo), error) {\n\tt, done, err := cc.blockingpicker.pick(ctx, failfast, balancer.PickOptions{\n\t\tFullMethodName: method,\n\t})\n\tif err != nil {\n\t\treturn nil, nil, toRPCErr(err)\n\t}\n\treturn t, done, nil\n}\n")])])]),r("p",[t._v("在 "),r("code",[t._v("newClientStream")]),t._v(" 方法中，我们通过 "),r("code",[t._v("getTransport")]),t._v(" 方法获取了 Transport 层中抽象出来的 ClientTransport 和 ServerTransport，实际上就是获取一个连接给后续 RPC 调用传输使用。")]),t._v(" "),r("h3",{attrs:{id:"四、关闭连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四、关闭连接"}},[t._v("#")]),t._v(" 四、关闭连接")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// conn.Close()\nfunc (cc *ClientConn) Close() error {\n\tdefer cc.cancel()\n    ...\n\tcc.csMgr.updateState(connectivity.Shutdown)\n    ...\n\tcc.blockingpicker.close()\n\tif rWrapper != nil {\n\t\trWrapper.close()\n\t}\n\tif bWrapper != nil {\n\t\tbWrapper.close()\n\t}\n\n\tfor ac := range conns {\n\t\tac.tearDown(ErrClientConnClosing)\n\t}\n\tif channelz.IsOn() {\n\t\t...\n\t\tchannelz.AddTraceEvent(cc.channelzID, ted)\n\t\tchannelz.RemoveEntry(cc.channelzID)\n\t}\n\treturn nil\n}\n")])])]),r("p",[t._v("该方法会取消 ClientConn 上下文，同时关闭所有底层传输。涉及如下：")]),t._v(" "),r("ul",[r("li",[t._v("Context Cancel")]),t._v(" "),r("li",[t._v("清空并关闭客户端连接")]),t._v(" "),r("li",[t._v("清空并关闭解析器连接")]),t._v(" "),r("li",[t._v("清空并关闭负载均衡连接")]),t._v(" "),r("li",[t._v("添加跟踪引用")]),t._v(" "),r("li",[t._v("移除当前通道信息")])]),t._v(" "),r("h2",{attrs:{id:"q-a"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[t._v("#")]),t._v(" Q&A")]),t._v(" "),r("h3",{attrs:{id:"_1-grpc-metadata-是通过什么传输？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-grpc-metadata-是通过什么传输？"}},[t._v("#")]),t._v(" 1. gRPC Metadata 是通过什么传输？")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/N7xx2JH.jpg",alt:"image"}})]),t._v(" "),r("h3",{attrs:{id:"_2-调用-grpc-dial-会真正的去连接服务端吗？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-调用-grpc-dial-会真正的去连接服务端吗？"}},[t._v("#")]),t._v(" 2. 调用 grpc.Dial 会真正的去连接服务端吗？")]),t._v(" "),r("p",[t._v("会，但是是异步连接的，连接状态为正在连接。但如果你设置了 "),r("code",[t._v("grpc.WithBlock")]),t._v(" 选项，就会阻塞等待（等待握手成功）。另外你需要注意，当未设置 "),r("code",[t._v("grpc.WithBlock")]),t._v(" 时，ctx 超时控制对其无任何效果。")]),t._v(" "),r("h3",{attrs:{id:"_3-调用-clientconn-不-close-会导致泄露吗？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-调用-clientconn-不-close-会导致泄露吗？"}},[t._v("#")]),t._v(" 3. 调用 ClientConn 不 Close 会导致泄露吗？")]),t._v(" "),r("p",[t._v("会，除非你的客户端不是常驻进程，那么在应用结束时会被动地回收资源。但如果是常驻进程，你又真的忘记执行 "),r("code",[t._v("Close")]),t._v(" 语句，会造成的泄露。如下图：")]),t._v(" "),r("p",[r("strong",[t._v("3.1. 客户端")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/YFMv93J.jpg",alt:"image"}})]),t._v(" "),r("p",[r("strong",[t._v("3.2. 服务端")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/mu65CZL.png",alt:"image"}})]),t._v(" "),r("p",[r("strong",[t._v("3.3. TCP")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/0Wg6ZY7.jpg",alt:"image"}})]),t._v(" "),r("h3",{attrs:{id:"_4-不控制超时调用的话，会出现什么问题？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-不控制超时调用的话，会出现什么问题？"}},[t._v("#")]),t._v(" 4. 不控制超时调用的话，会出现什么问题？")]),t._v(" "),r("p",[t._v("短时间内不会出现问题，但是会不断积蓄泄露，积蓄到最后当然就是服务无法提供响应了。如下图：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/GIgP062.jpg",alt:"image"}})]),t._v(" "),r("h3",{attrs:{id:"_5-为什么默认的拦截器不可以传多个？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-为什么默认的拦截器不可以传多个？"}},[t._v("#")]),t._v(" 5. 为什么默认的拦截器不可以传多个？")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func chainUnaryClientInterceptors(cc *ClientConn) {\n\tinterceptors := cc.dopts.chainUnaryInts\n\tif cc.dopts.unaryInt != nil {\n\t\tinterceptors = append([]UnaryClientInterceptor{cc.dopts.unaryInt}, interceptors...)\n\t}\n\tvar chainedInt UnaryClientInterceptor\n\tif len(interceptors) == 0 {\n\t\tchainedInt = nil\n\t} else if len(interceptors) == 1 {\n\t\tchainedInt = interceptors[0]\n\t} else {\n\t\tchainedInt = func(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption) error {\n\t\t\treturn interceptors[0](ctx, method, req, reply, cc, getChainUnaryInvoker(interceptors, 0, invoker), opts...)\n\t\t}\n\t}\n\tcc.dopts.unaryInt = chainedInt\n}\n")])])]),r("p",[t._v("当存在多个拦截器时，取的就是第一个拦截器。因此结论是允许传多个，但并没有用。")]),t._v(" "),r("h3",{attrs:{id:"_6-真的需要用到多个拦截器的话，怎么办？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-真的需要用到多个拦截器的话，怎么办？"}},[t._v("#")]),t._v(" 6. 真的需要用到多个拦截器的话，怎么办？")]),t._v(" "),r("p",[t._v("可以使用 "),r("a",{attrs:{href:"https://github.com/grpc-ecosystem/go-grpc-middleware",target:"_blank",rel:"noopener noreferrer"}},[t._v("go-grpc-middleware"),r("OutboundLink")],1),t._v(" 提供的 "),r("code",[t._v("grpc.UnaryInterceptor")]),t._v(" 和 "),r("code",[t._v("grpc.StreamInterceptor")]),t._v(" 链式方法，方便快捷省心。")]),t._v(" "),r("p",[t._v("单单会用还不行，我们再深剖一下，看看它是怎么实现的。核心代码如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("func ChainUnaryClient(interceptors ...grpc.UnaryClientInterceptor) grpc.UnaryClientInterceptor {\n\tn := len(interceptors)\n\tif n > 1 {\n\t\tlastI := n - 1\n\t\treturn func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {\n\t\t\tvar (\n\t\t\t\tchainHandler grpc.UnaryInvoker\n\t\t\t\tcurI         int\n\t\t\t)\n\n\t\t\tchainHandler = func(currentCtx context.Context, currentMethod string, currentReq, currentRepl interface{}, currentConn *grpc.ClientConn, currentOpts ...grpc.CallOption) error {\n\t\t\t\tif curI == lastI {\n\t\t\t\t\treturn invoker(currentCtx, currentMethod, currentReq, currentRepl, currentConn, currentOpts...)\n\t\t\t\t}\n\t\t\t\tcurI++\n\t\t\t\terr := interceptors[curI](currentCtx, currentMethod, currentReq, currentRepl, currentConn, chainHandler, currentOpts...)\n\t\t\t\tcurI--\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn interceptors[0](ctx, method, req, reply, cc, chainHandler, opts...)\n\t\t}\n\t}\n    ...\n}\n")])])]),r("p",[t._v("当拦截器数量大于 1 时，从 "),r("code",[t._v("interceptors[1]")]),t._v(" 开始递归，每一个递归的拦截器 "),r("code",[t._v("interceptors[i]")]),t._v(" 会不断地执行，最后才真正的去执行 "),r("code",[t._v("handler")]),t._v(" 方法。同时也经常有人会问拦截器的执行顺序是什么，通过这段代码你得出结论了吗？")]),t._v(" "),r("h3",{attrs:{id:"_7-频繁创建-clientconn-有什么问题？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-频繁创建-clientconn-有什么问题？"}},[t._v("#")]),t._v(" 7. 频繁创建 ClientConn 有什么问题？")]),t._v(" "),r("p",[t._v("这个问题我们可以反向验证一下，假设不公用 ClientConn 看看会怎么样？如下:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('func BenchmarkSearch(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tconn, err := GetClientConn()\n\t\tif err != nil {\n\t\t\tb.Errorf("GetClientConn err: %v", err)\n\t\t}\n\t\t_, err = Search(context.Background(), conn)\n\t\tif err != nil {\n\t\t\tb.Errorf("Search err: %v", err)\n\t\t}\n\t}\n}\n')])])]),r("p",[t._v("输出结果：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('    ... connection error: desc = "transport: Error while dialing dial tcp :10001: socket: too many open files"\n    ... connection error: desc = "transport: Error while dialing dial tcp :10001: socket: too many open files"\n    ... connection error: desc = "transport: Error while dialing dial tcp :10001: socket: too many open files"\n    ... connection error: desc = "transport: Error while dialing dial tcp :10001: socket: too many open files"\nFAIL\nexit status 1\n')])])]),r("p",[t._v("当你的应用场景是存在高频次同时生成/调用 ClientConn 时，可能会导致系统的文件句柄占用过多。这种情况下你可以变更应用程序生成/调用 ClientConn 的模式，又或是池化它，这块可以参考 "),r("a",{attrs:{href:"github.com/processout/grpc-go-pool"}},[t._v("grpc-go-pool")]),t._v(" 项目。")]),t._v(" "),r("h3",{attrs:{id:"_8-客户端请求失败后会默认重试吗？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-客户端请求失败后会默认重试吗？"}},[t._v("#")]),t._v(" 8. 客户端请求失败后会默认重试吗？")]),t._v(" "),r("p",[t._v("会不断地进行重试，直到上下文取消。而重试时间方面采用 backoff 算法作为的重连机制，默认的最大重试时间间隔是 120s。")]),t._v(" "),r("h3",{attrs:{id:"_9-为什么要用-http-2-作为传输协议？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-为什么要用-http-2-作为传输协议？"}},[t._v("#")]),t._v(" 9. 为什么要用 HTTP/2 作为传输协议？")]),t._v(" "),r("p",[t._v("许多客户端要通过 HTTP 代理来访问网络，gRPC 全部用 HTTP/2 实现，等到代理开始支持 HTTP/2 就能透明转发 gRPC 的数据。不光如此，负责负载均衡、访问控制等等的反向代理都能无缝兼容 gRPC，比起自己设计 wire protocol 的 Thrift，这样做科学不少。@ctiller @滕亦飞")]),t._v(" "),r("h3",{attrs:{id:"_10-在-kubernetes-中-grpc-负载均衡有问题？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-在-kubernetes-中-grpc-负载均衡有问题？"}},[t._v("#")]),t._v(" 10. 在 Kubernetes 中 gRPC 负载均衡有问题？")]),t._v(" "),r("p",[t._v("gRPC 的 RPC 协议是基于 HTTP/2 标准实现的，HTTP/2 的一大特性就是不需要像 HTTP/1.1 一样，每次发出请求都要重新建立一个新连接，而是会复用原有的连接。")]),t._v(" "),r("p",[t._v("所以这将导致 kube-proxy 只有在连接建立时才会做负载均衡，而在这之后的每一次 RPC 请求都会利用原本的连接，那么实际上后续的每一次的 RPC 请求都跑到了同一个地方。")]),t._v(" "),r("p",[t._v("注：使用 k8s service 做负载均衡的情况下")]),t._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),r("ul",[r("li",[t._v("gRPC 基于 HTTP/2 + Protobuf。")]),t._v(" "),r("li",[t._v("gRPC 有四种调用方式，分别是一元、服务端/客户端流式、双向流式。")]),t._v(" "),r("li",[t._v("gRPC 的附加信息都会体现在 HEADERS 帧，数据在 DATA 帧上。")]),t._v(" "),r("li",[t._v("Client 请求若使用 grpc.Dial 默认是异步建立连接，当时状态为 Connecting。")]),t._v(" "),r("li",[t._v("Client 请求若需要同步则调用 WithBlock()，完成状态为 Ready。")]),t._v(" "),r("li",[t._v("Server 监听是循环等待连接，若没有则休眠，最大休眠时间 1s；若接收到新请求则起一个新的 goroutine 去处理。")]),t._v(" "),r("li",[t._v("grpc.ClientConn 不关闭连接，会导致 goroutine 和 Memory 等泄露。")]),t._v(" "),r("li",[t._v("任何内/外调用如果不加超时控制，会出现泄漏和客户端不断重试。")]),t._v(" "),r("li",[t._v("特定场景下，如果不对 grpc.ClientConn 加以调控，会影响调用。")]),t._v(" "),r("li",[t._v("拦截器如果不用 go-grpc-middleware 链式处理，会覆盖。")]),t._v(" "),r("li",[t._v("在选择 gRPC 的负载均衡模式时，需要谨慎。")])]),t._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),r("ul",[r("li",[t._v("http://doc.oschina.net/grpc")]),t._v(" "),r("li",[t._v("https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md")]),t._v(" "),r("li",[t._v("https://juejin.im/post/5b88a4f56fb9a01a0b31a67e")]),t._v(" "),r("li",[t._v("https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html")]),t._v(" "),r("li",[t._v("https://github.com/grpc/grpc-go/issues/1953")]),t._v(" "),r("li",[t._v("https://www.zhihu.com/question/52670041")])])])}),[],!1,null,null,null);e.default=a.exports}}]);