(window.webpackJsonp=window.webpackJsonp||[]).push([[218],{654:function(t,e,n){"use strict";n.r(e);var a=n(44),o=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"编写一个简单的文件日志"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#编写一个简单的文件日志"}},[t._v("#")]),t._v(" 编写一个简单的文件日志")]),t._v(" "),n("p",[t._v("项目地址：https://github.com/EDDYCJY/go-gin-example")]),t._v(" "),n("h2",{attrs:{id:"涉及知识点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#涉及知识点"}},[t._v("#")]),t._v(" 涉及知识点")]),t._v(" "),n("ul",[n("li",[t._v("自定义 log。")])]),t._v(" "),n("h2",{attrs:{id:"本文目标"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#本文目标"}},[t._v("#")]),t._v(" 本文目标")]),t._v(" "),n("p",[t._v("在上一节中，我们解决了API's可以任意访问的问题，那么我们现在还有一个问题，就是我们的日志，都是输出到控制台上的，这显然对于一个项目来说是不合理的，因此我们这一节简单封装"),n("code",[t._v("log")]),t._v("库，使其支持简单的文件日志！")]),t._v(" "),n("h2",{attrs:{id:"新建logging包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#新建logging包"}},[t._v("#")]),t._v(" 新建"),n("code",[t._v("logging")]),t._v("包")]),t._v(" "),n("p",[t._v("我们在"),n("code",[t._v("pkg")]),t._v("下新建"),n("code",[t._v("logging")]),t._v("目录，新建"),n("code",[t._v("file.go")]),t._v("和"),n("code",[t._v("log.go")]),t._v("文件，写入内容：")]),t._v(" "),n("h3",{attrs:{id:"编写file文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#编写file文件"}},[t._v("#")]),t._v(" 编写"),n("code",[t._v("file")]),t._v("文件")]),t._v(" "),n("p",[n("strong",[t._v("1、 file.go：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package logging\n\nimport (\n\t"os"\n\t"time"\n\t"fmt"\n\t"log"\n)\n\nvar (\n\tLogSavePath = "runtime/logs/"\n\tLogSaveName = "log"\n\tLogFileExt = "log"\n\tTimeFormat = "20060102"\n)\n\nfunc getLogFilePath() string {\n\treturn fmt.Sprintf("%s", LogSavePath)\n}\n\nfunc getLogFileFullPath() string {\n\tprefixPath := getLogFilePath()\n\tsuffixPath := fmt.Sprintf("%s%s.%s", LogSaveName, time.Now().Format(TimeFormat), LogFileExt)\n\n\treturn fmt.Sprintf("%s%s", prefixPath, suffixPath)\n}\n\nfunc openLogFile(filePath string) *os.File {\n\t_, err := os.Stat(filePath)\n\tswitch {\n\t\tcase os.IsNotExist(err):\n\t\t\tmkDir()\n\t\tcase os.IsPermission(err):\n\t\t\tlog.Fatalf("Permission :%v", err)\n\t}\n\n\thandle, err := os.OpenFile(filePath, os.O_APPEND | os.O_CREATE | os.O_WRONLY, 0644)\n\tif err != nil {\n\t\tlog.Fatalf("Fail to OpenFile :%v", err)\n\t}\n\n\treturn handle\n}\n\nfunc mkDir() {\n\tdir, _ := os.Getwd()\n\terr := os.MkdirAll(dir + "/" + getLogFilePath(), os.ModePerm)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n')])])]),n("ul",[n("li",[n("code",[t._v("os.Stat")]),t._v("：返回文件信息结构描述文件。如果出现错误，会返回"),n("code",[t._v("*PathError")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("type PathError struct {\n    Op   string\n    Path string\n    Err  error\n}\n")])])]),n("ul",[n("li",[n("code",[t._v("os.IsNotExist")]),t._v("：能够接受"),n("code",[t._v("ErrNotExist")]),t._v("、"),n("code",[t._v("syscall")]),t._v("的一些错误，它会返回一个布尔值，能够得知文件不存在或目录不存在")]),t._v(" "),n("li",[n("code",[t._v("os.IsPermission")]),t._v("：能够接受"),n("code",[t._v("ErrPermission")]),t._v("、"),n("code",[t._v("syscall")]),t._v("的一些错误，它会返回一个布尔值，能够得知权限是否满足")]),t._v(" "),n("li",[n("code",[t._v("os.OpenFile")]),t._v("：调用文件，支持传入文件名称、指定的模式调用文件、文件权限，返回的文件的方法可以用于I/O。如果出现错误，则为"),n("code",[t._v("*PathError")]),t._v("。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const (\n    // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.\n    O_RDONLY int = syscall.O_RDONLY // 以只读模式打开文件\n    O_WRONLY int = syscall.O_WRONLY // 以只写模式打开文件\n    O_RDWR   int = syscall.O_RDWR   // 以读写模式打开文件\n    // The remaining values may be or'ed in to control behavior.\n    O_APPEND int = syscall.O_APPEND // 在写入时将数据追加到文件中\n    O_CREATE int = syscall.O_CREAT  // 如果不存在，则创建一个新文件\n    O_EXCL   int = syscall.O_EXCL   // 使用O_CREATE时，文件必须不存在\n    O_SYNC   int = syscall.O_SYNC   // 同步IO\n    O_TRUNC  int = syscall.O_TRUNC  // 如果可以，打开时\n)\n")])])]),n("ul",[n("li",[n("code",[t._v("os.Getwd")]),t._v("：返回与当前目录对应的根路径名")]),t._v(" "),n("li",[n("code",[t._v("os.MkdirAll")]),t._v("：创建对应的目录以及所需的子目录，若成功则返回"),n("code",[t._v("nil")]),t._v("，否则返回"),n("code",[t._v("error")])]),t._v(" "),n("li",[n("code",[t._v("os.ModePerm")]),t._v("："),n("code",[t._v("const")]),t._v("定义"),n("code",[t._v("ModePerm FileMode = 0777")])])]),t._v(" "),n("h3",{attrs:{id:"编写log文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#编写log文件"}},[t._v("#")]),t._v(" 编写"),n("code",[t._v("log")]),t._v("文件")]),t._v(" "),n("p",[n("strong",[t._v("2、log.go")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package logging\n\nimport (\n\t"log"\n\t"os"\n\t"runtime"\n\t"path/filepath"\n\t"fmt"\n)\n\ntype Level int\n\nvar (\n\tF *os.File\n\n\tDefaultPrefix = ""\n\tDefaultCallerDepth = 2\n\n\tlogger *log.Logger\n\tlogPrefix = ""\n\tlevelFlags = []string{"DEBUG", "INFO", "WARN", "ERROR", "FATAL"}\n)\n\nconst (\n\tDEBUG Level = iota\n\tINFO\n\tWARNING\n\tERROR\n\tFATAL\n)\n\nfunc init() {\n\tfilePath := getLogFileFullPath()\n\tF = openLogFile(filePath)\n\n\tlogger = log.New(F, DefaultPrefix, log.LstdFlags)\n}\n\nfunc Debug(v ...interface{}) {\n\tsetPrefix(DEBUG)\n\tlogger.Println(v)\n}\n\nfunc Info(v ...interface{}) {\n\tsetPrefix(INFO)\n\tlogger.Println(v)\n}\n\nfunc Warn(v ...interface{}) {\n\tsetPrefix(WARNING)\n\tlogger.Println(v)\n}\n\nfunc Error(v ...interface{}) {\n\tsetPrefix(ERROR)\n\tlogger.Println(v)\n}\n\nfunc Fatal(v ...interface{}) {\n\tsetPrefix(FATAL)\n\tlogger.Fatalln(v)\n}\n\nfunc setPrefix(level Level) {\n\t_, file, line, ok := runtime.Caller(DefaultCallerDepth)\n\tif ok {\n\t\tlogPrefix = fmt.Sprintf("[%s][%s:%d]", levelFlags[level], filepath.Base(file), line)\n\t} else {\n\t\tlogPrefix = fmt.Sprintf("[%s]", levelFlags[level])\n\t}\n\t\n\tlogger.SetPrefix(logPrefix)\n}\n\n')])])]),n("ul",[n("li",[n("code",[t._v("log.New")]),t._v("：创建一个新的日志记录器。"),n("code",[t._v("out")]),t._v("定义要写入日志数据的"),n("code",[t._v("IO")]),t._v("句柄。"),n("code",[t._v("prefix")]),t._v("定义每个生成的日志行的开头。"),n("code",[t._v("flag")]),t._v("定义了日志记录属性")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func New(out io.Writer, prefix string, flag int) *Logger {\n    return &Logger{out: out, prefix: prefix, flag: flag}\n}\n")])])]),n("ul",[n("li",[n("code",[t._v("log.LstdFlags")]),t._v("：日志记录的格式属性之一，其余的选项如下")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const (\n    Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23\n    Ltime                         // the time in the local time zone: 01:23:23\n    Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.\n    Llongfile                     // full file name and line number: /a/b/c/d.go:23\n    Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile\n    LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone\n    LstdFlags     = Ldate | Ltime // initial values for the standard logger\n)\n")])])]),n("p",[t._v("当前目录结构：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("gin-blog/\n├── conf\n│   └── app.ini\n├── main.go\n├── middleware\n│   └── jwt\n│       └── jwt.go\n├── models\n│   ├── article.go\n│   ├── auth.go\n│   ├── models.go\n│   └── tag.go\n├── pkg\n│   ├── e\n│   │   ├── code.go\n│   │   └── msg.go\n│   ├── logging\n│   │   ├── file.go\n│   │   └── log.go\n│   ├── setting\n│   │   └── setting.go\n│   └── util\n│       ├── jwt.go\n│       └── pagination.go\n├── routers\n│   ├── api\n│   │   ├── auth.go\n│   │   └── v1\n│   │       ├── article.go\n│   │       └── tag.go\n│   └── router.go\n├── runtime\n\n")])])]),n("p",[t._v("我们自定义的"),n("code",[t._v("logging")]),t._v("包，已经基本完成了，接下来让它接入到我们的项目之中吧。我们打开先前包含"),n("code",[t._v("log")]),t._v("包的代码，如下：")]),t._v(" "),n("ol",[n("li",[t._v("打开"),n("code",[t._v("routers")]),t._v("目录下的"),n("code",[t._v("article.go")]),t._v("、"),n("code",[t._v("tag.go")]),t._v("、"),n("code",[t._v("auth.go")]),t._v("。")]),t._v(" "),n("li",[t._v("将"),n("code",[t._v("log")]),t._v("包的引用删除，修改引用我们自己的日志包为"),n("code",[t._v("github.com/EDDYCJY/go-gin-example/pkg/logging")]),t._v("。")]),t._v(" "),n("li",[t._v("将原本的"),n("code",[t._v("log.Println(...)")]),t._v("改为"),n("code",[t._v("logging.Info(...)")]),t._v("。")])]),t._v(" "),n("p",[t._v("例如"),n("code",[t._v("auth.go")]),t._v("文件的修改内容：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package api\n\nimport (\n\t"net/http"\n\n\t"github.com/gin-gonic/gin"\n\t"github.com/astaxie/beego/validation"\n\n\t"github.com/EDDYCJY/go-gin-example/pkg/e"\n\t"github.com/EDDYCJY/go-gin-example/pkg/util"\n\t"github.com/EDDYCJY/go-gin-example/models"\n\t"github.com/EDDYCJY/go-gin-example/pkg/logging"\n)\n...\nfunc GetAuth(c *gin.Context) {\n\t...\n\tcode := e.INVALID_PARAMS\n\tif ok {\n\t\t...\n\t} else {\n\t    for _, err := range valid.Errors {\n                logging.Info(err.Key, err.Message)\n            }\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{\n        "code" : code,\n        "msg" : e.GetMsg(code),\n        "data" : data,\n    })\n}\n')])])]),n("h2",{attrs:{id:"验证功能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#验证功能"}},[t._v("#")]),t._v(" 验证功能")]),t._v(" "),n("p",[t._v("修改文件后，重启服务，我们来试试吧！")]),t._v(" "),n("p",[t._v("获取到API的Token后，我们故意传错误URL参数给接口，如："),n("code",[t._v("http://127.0.0.1:8000/api/v1/articles?tag_id=0&state=9999999&token=eyJhbG..")])]),t._v(" "),n("p",[t._v("然后我们到"),n("code",[t._v("$GOPATH/gin-blog/runtime/logs")]),t._v("查看日志：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("$ tail -f log20180216.log \n[INFO][article.go:79]2018/02/16 18:33:12 [state 状态只允许0或1]\n[INFO][article.go:79]2018/02/16 18:33:42 [state 状态只允许0或1]\n[INFO][article.go:79]2018/02/16 18:33:42 [tag_id 标签ID必须大于0]\n[INFO][article.go:79]2018/02/16 18:38:39 [state 状态只允许0或1]\n[INFO][article.go:79]2018/02/16 18:38:39 [tag_id 标签ID必须大于0]\n")])])]),n("p",[t._v("日志结构一切正常，我们的记录模式都为"),n("code",[t._v("Info")]),t._v("，因此前缀是对的，并且我们是入参有问题，也把错误记录下来了，这样排错就很方便了！")]),t._v(" "),n("p",[t._v("至此，本节就完成了，这只是一个简单的扩展，实际上我们线上项目要使用的文件日志，是更复杂一些，开动你的大脑 举一反三吧！")]),t._v(" "),n("h2",{attrs:{id:"参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),n("h3",{attrs:{id:"本系列示例代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#本系列示例代码"}},[t._v("#")]),t._v(" 本系列示例代码")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://github.com/EDDYCJY/go-gin-example",target:"_blank",rel:"noopener noreferrer"}},[t._v("go-gin-example"),n("OutboundLink")],1)])]),t._v(" "),n("h2",{attrs:{id:"关于"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于"}},[t._v("#")]),t._v(" 关于")]),t._v(" "),n("h3",{attrs:{id:"修改记录"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#修改记录"}},[t._v("#")]),t._v(" 修改记录")]),t._v(" "),n("ul",[n("li",[t._v("第一版：2018年02月16日发布文章")]),t._v(" "),n("li",[t._v("第二版：2019年10月01日修改文章")])]),t._v(" "),n("h2",{attrs:{id:"？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#？"}},[t._v("#")]),t._v(" ？")]),t._v(" "),n("p",[t._v("如果有任何疑问或错误，欢迎在 "),n("a",{attrs:{href:"https://github.com/EDDYCJY/blog",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),n("OutboundLink")],1),t._v(" 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。")]),t._v(" "),n("h3",{attrs:{id:"我的公众号"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#我的公众号"}},[t._v("#")]),t._v(" 我的公众号")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg",alt:"image"}})])])}),[],!1,null,null,null);e.default=o.exports}}]);