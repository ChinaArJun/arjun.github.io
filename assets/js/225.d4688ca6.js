(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{660:function(t,e,r){"use strict";r.r(e);var n=r(44),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_4-7-让你的服务同时提供-http-接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-让你的服务同时提供-http-接口"}},[t._v("#")]),t._v(" 4.7 让你的服务同时提供 HTTP 接口")]),t._v(" "),r("p",[t._v("项目地址：https://github.com/EDDYCJY/go-grpc-example")]),t._v(" "),r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("接口需要提供给其他业务组访问，但是 RPC 协议不同无法内调，对方问能否走 HTTP 接口，怎么办？")])]),t._v(" "),r("li",[r("p",[t._v("微信（公众号、小程序）等第三方回调接口只支持 HTTP 接口，怎么办")])])]),t._v(" "),r("p",[t._v("我相信你在实际工作中都会遇到如上问题，在 gRPC 中都是有解决方案的，本章节将会进行介绍 🤔")]),t._v(" "),r("h2",{attrs:{id:"为什么可以同时提供-http-接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么可以同时提供-http-接口"}},[t._v("#")]),t._v(" 为什么可以同时提供 HTTP 接口")]),t._v(" "),r("p",[t._v("关键一点，gRPC 的协议是基于 HTTP/2 的，因此应用程序能够在单个 TCP 端口上提供 HTTP/1.1 和 gRPC 接口服务（两种不同的流量）")]),t._v(" "),r("h2",{attrs:{id:"怎么同时提供-http-接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#怎么同时提供-http-接口"}},[t._v("#")]),t._v(" 怎么同时提供 HTTP 接口")]),t._v(" "),r("h3",{attrs:{id:"检测协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#检测协议"}},[t._v("#")]),t._v(" 检测协议")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('if r.ProtoMajor == 2 && strings.Contains(r.Header.Get("Content-Type"), "application/grpc") {\n    server.ServeHTTP(w, r)\n} else {\n    mux.ServeHTTP(w, r)\n}\n')])])]),r("h3",{attrs:{id:"流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[t._v("#")]),t._v(" 流程")]),t._v(" "),r("ol",[r("li",[t._v("检测请求协议是否为 HTTP/2")]),t._v(" "),r("li",[t._v("判断 Content-Type 是否为 application/grpc（gRPC 的默认标识位）")]),t._v(" "),r("li",[t._v("根据协议的不同转发到不同的服务处理")])]),t._v(" "),r("h2",{attrs:{id:"grpc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#grpc"}},[t._v("#")]),t._v(" gRPC")]),t._v(" "),r("h3",{attrs:{id:"tls"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tls"}},[t._v("#")]),t._v(" TLS")]),t._v(" "),r("p",[t._v("在前面的章节，为了便于展示因此没有简单封装")]),t._v(" "),r("p",[t._v("在本节需复用代码，重新封装了，可详见："),r("a",{attrs:{href:"https://github.com/EDDYCJY/go-grpc-example/tree/master/pkg/gtls",target:"_blank",rel:"noopener noreferrer"}},[t._v("go-grpc-example"),r("OutboundLink")],1)]),t._v(" "),r("h3",{attrs:{id:"目录结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[t._v("#")]),t._v(" 目录结构")]),t._v(" "),r("p",[t._v("新建 simple_http_client、simple_http_server 目录，目录结构如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("go-grpc-example\n├── client\n│   ├── simple_client\n│   ├── simple_http_client\n│   └── stream_client\n├── conf\n├── pkg\n│   └── gtls\n├── proto\n├── server\n│   ├── simple_http_server\n│   ├── simple_server\n│   └── stream_server\n")])])]),r("h3",{attrs:{id:"server"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[t._v("#")]),t._v(" Server")]),t._v(" "),r("p",[t._v("在 simple_http_server 目录下新建 server.go，写入文件内容：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('package main\n\nimport (\n\t"context"\n\t"log"\n\t"net/http"\n\t"strings"\n\n\t"github.com/EDDYCJY/go-grpc-example/pkg/gtls"\n\tpb "github.com/EDDYCJY/go-grpc-example/proto"\n\n\t"google.golang.org/grpc"\n)\n\ntype SearchService struct{}\n\nfunc (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {\n\treturn &pb.SearchResponse{Response: r.GetRequest() + " HTTP Server"}, nil\n}\n\nconst PORT = "9003"\n\nfunc main() {\n\tcertFile := "../../conf/server/server.pem"\n\tkeyFile := "../../conf/server/server.key"\n\ttlsServer := gtls.Server{\n\t\tCertFile: certFile,\n\t\tKeyFile:  keyFile,\n\t}\n\n\tc, err := tlsServer.GetTLSCredentials()\n\tif err != nil {\n\t\tlog.Fatalf("tlsServer.GetTLSCredentials err: %v", err)\n\t}\n\n\tmux := GetHTTPServeMux()\n\n\tserver := grpc.NewServer(grpc.Creds(c))\n\tpb.RegisterSearchServiceServer(server, &SearchService{})\n\n\thttp.ListenAndServeTLS(":"+PORT,\n\t\tcertFile,\n\t\tkeyFile,\n\t\thttp.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.ProtoMajor == 2 && strings.Contains(r.Header.Get("Content-Type"), "application/grpc") {\n\t\t\t\tserver.ServeHTTP(w, r)\n\t\t\t} else {\n\t\t\t\tmux.ServeHTTP(w, r)\n\t\t\t}\n\n\t\t\treturn\n\t\t}),\n\t)\n}\n\nfunc GetHTTPServeMux() *http.ServeMux {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte("eddycjy: go-grpc-example"))\n\t})\n\n\treturn mux\n}\n')])])]),r("ul",[r("li",[t._v("http.NewServeMux：创建一个新的 ServeMux，ServeMux 本质上是一个路由表。它默认实现了 ServeHTTP，因此返回 Handler 后可直接通过 HandleFunc 注册 pattern 和处理逻辑的方法")]),t._v(" "),r("li",[t._v("http.ListenAndServeTLS：可简单的理解为提供监听 HTTPS 服务的方法，重点的协议判断转发，也在这里面")])]),t._v(" "),r("p",[t._v("其实，你理解后就会觉得很简单，核心步骤：判断 -> 转发 -> 响应。我们改变了前两步的默认逻辑，仅此而已")]),t._v(" "),r("h3",{attrs:{id:"client"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#client"}},[t._v("#")]),t._v(" Client")]),t._v(" "),r("p",[t._v("在 simple_http_server 目录下新建 client.go，写入文件内容：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('package main\n\nimport (\n\t"context"\n\t"log"\n\n\t"google.golang.org/grpc"\n\n\t"github.com/EDDYCJY/go-grpc-example/pkg/gtls"\n\tpb "github.com/EDDYCJY/go-grpc-example/proto"\n)\n\nconst PORT = "9003"\n\nfunc main() {\n\ttlsClient := gtls.Client{\n\t\tServerName: "go-grpc-example",\n\t\tCertFile:   "../../conf/server/server.pem",\n\t}\n\tc, err := tlsClient.GetTLSCredentials()\n\tif err != nil {\n\t\tlog.Fatalf("tlsClient.GetTLSCredentials err: %v", err)\n\t}\n\n\tconn, err := grpc.Dial(":"+PORT, grpc.WithTransportCredentials(c))\n\tif err != nil {\n\t\tlog.Fatalf("grpc.Dial err: %v", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewSearchServiceClient(conn)\n\tresp, err := client.Search(context.Background(), &pb.SearchRequest{\n\t\tRequest: "gRPC",\n\t})\n\tif err != nil {\n\t\tlog.Fatalf("client.Search err: %v", err)\n\t}\n\n\tlog.Printf("resp: %s", resp.GetResponse())\n}\n')])])]),r("h2",{attrs:{id:"验证"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#验证"}},[t._v("#")]),t._v(" 验证")]),t._v(" "),r("h3",{attrs:{id:"grpc-client"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#grpc-client"}},[t._v("#")]),t._v(" gRPC Client")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("$ go run client.go \n2018/10/04 14:56:56 resp: gRPC HTTP Server\n")])])]),r("h3",{attrs:{id:"http-1-1-访问"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-访问"}},[t._v("#")]),t._v(" HTTP/1.1 访问")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://image.eddycjy.com/1d92cb9e949e32eef7f8a64a6a77deb9.jpg",alt:"image"}})]),t._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),r("p",[t._v("通过本章节，表面上完成了同端口提供双服务的功能，但实际上，应该是加深了 HTTP/2 的理解和使用，这才是本质")]),t._v(" "),r("h2",{attrs:{id:"拓展"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#拓展"}},[t._v("#")]),t._v(" 拓展")]),t._v(" "),r("p",[t._v("如果你有一个需求，是要"),r("strong",[t._v("同时提供")]),t._v(" RPC 和 RESTful JSON API 两种接口的，不要犹豫，点进去："),r("a",{attrs:{href:"https://segmentfault.com/a/1190000013339403",target:"_blank",rel:"noopener noreferrer"}},[t._v("gRPC + gRPC Gateway 实践"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),r("p",[t._v("你以为这个方案就万能了吗，不。Envoy Proxy 的支持就不完美，无法同时监听一个端口的两种流量 😤")]),t._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),r("h3",{attrs:{id:"本系列示例代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本系列示例代码"}},[t._v("#")]),t._v(" 本系列示例代码")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/EDDYCJY/go-grpc-example",target:"_blank",rel:"noopener noreferrer"}},[t._v("go-grpc-example"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);