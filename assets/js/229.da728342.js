(window.webpackJsonp=window.webpackJsonp||[]).push([[229],{664:function(t,e,r){"use strict";r.r(e);var n=r(44),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_4-8-对-rpc-方法做自定义认证"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-对-rpc-方法做自定义认证"}},[t._v("#")]),t._v(" 4.8 对 RPC 方法做自定义认证")]),t._v(" "),r("p",[t._v("项目地址：https://github.com/EDDYCJY/go-grpc-example")]),t._v(" "),r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),r("p",[t._v("在前面的章节中，我们介绍了两种（证书算一种）可全局认证的方法：")]),t._v(" "),r("ol",[r("li",[r("a",{attrs:{href:"https://github.com/EDDYCJY/blog/blob/master/grpc/grpc-tls.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("TLS 证书认证"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/EDDYCJY/blog/blob/master/grpc/ca-tls.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("基于 CA 的 TLS 证书认证"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/EDDYCJY/blog/blob/master/grpc/interceptor.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Unary and Stream interceptor"),r("OutboundLink")],1)])]),t._v(" "),r("p",[t._v("而在实际需求中，常常会对某些模块的 RPC 方法做特殊认证或校验。今天将会讲解、实现这块的功能点")]),t._v(" "),r("h2",{attrs:{id:"课前知识"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#课前知识"}},[t._v("#")]),t._v(" 课前知识")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("type PerRPCCredentials interface {\n    GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)\n    RequireTransportSecurity() bool\n}\n")])])]),r("p",[t._v("在 gRPC 中默认定义了 PerRPCCredentials，它就是本章节的主角，是 gRPC 默认提供用于自定义认证的接口，它的作用是将所需的安全认证信息添加到每个 RPC 方法的上下文中。其包含 2 个方法：")]),t._v(" "),r("ul",[r("li",[t._v("GetRequestMetadata：获取当前请求认证所需的元数据（metadata）")]),t._v(" "),r("li",[t._v("RequireTransportSecurity：是否需要基于 TLS 认证进行安全传输")])]),t._v(" "),r("h2",{attrs:{id:"目录结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[t._v("#")]),t._v(" 目录结构")]),t._v(" "),r("p",[t._v("新建 simple_token_server/server.go 和 simple_token_client/client.go，目录结构如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("go-grpc-example\n├── client\n│   ├── simple_client\n│   ├── simple_http_client\n│   ├── simple_token_client\n│   └── stream_client\n├── conf\n├── pkg\n├── proto\n├── server\n│   ├── simple_http_server\n│   ├── simple_server\n│   ├── simple_token_server\n│   └── stream_server\n└── vendor\n")])])]),r("h2",{attrs:{id:"grpc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#grpc"}},[t._v("#")]),t._v(" gRPC")]),t._v(" "),r("h3",{attrs:{id:"client"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#client"}},[t._v("#")]),t._v(" Client")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('package main\n\nimport (\n\t"context"\n\t"log"\n\n\t"google.golang.org/grpc"\n\n\t"github.com/EDDYCJY/go-grpc-example/pkg/gtls"\n\tpb "github.com/EDDYCJY/go-grpc-example/proto"\n)\n\nconst PORT = "9004"\n\ntype Auth struct {\n\tAppKey    string\n\tAppSecret string\n}\n\nfunc (a *Auth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {\n\treturn map[string]string{"app_key": a.AppKey, "app_secret": a.AppSecret}, nil\n}\n\nfunc (a *Auth) RequireTransportSecurity() bool {\n\treturn true\n}\n\nfunc main() {\n\ttlsClient := gtls.Client{\n\t\tServerName: "go-grpc-example",\n\t\tCertFile:   "../../conf/server/server.pem",\n\t}\n\tc, err := tlsClient.GetTLSCredentials()\n\tif err != nil {\n\t\tlog.Fatalf("tlsClient.GetTLSCredentials err: %v", err)\n\t}\n\n\tauth := Auth{\n\t\tAppKey:    "eddycjy",\n\t\tAppSecret: "20181005",\n\t}\n\tconn, err := grpc.Dial(":"+PORT, grpc.WithTransportCredentials(c), grpc.WithPerRPCCredentials(&auth))\n\t...\n}\n')])])]),r("p",[t._v("在 Client 端，重点实现 "),r("code",[t._v("type PerRPCCredentials interface")]),t._v(" 所需的方法，关注两点即可：")]),t._v(" "),r("ul",[r("li",[t._v("struct Auth：GetRequestMetadata、RequireTransportSecurity")]),t._v(" "),r("li",[t._v("grpc.WithPerRPCCredentials")])]),t._v(" "),r("h3",{attrs:{id:"server"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[t._v("#")]),t._v(" Server")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('package main\n\nimport (\n\t"context"\n\t"log"\n\t"net"\n\n\t"google.golang.org/grpc"\n\t"google.golang.org/grpc/codes"\n\t"google.golang.org/grpc/metadata"\n\t"google.golang.org/grpc/status"\n\n\t"github.com/EDDYCJY/go-grpc-example/pkg/gtls"\n\tpb "github.com/EDDYCJY/go-grpc-example/proto"\n)\n\ntype SearchService struct {\n\tauth *Auth\n}\n\nfunc (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {\n\tif err := s.auth.Check(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pb.SearchResponse{Response: r.GetRequest() + " Token Server"}, nil\n}\n\nconst PORT = "9004"\n\nfunc main() {\n\t...\n}\n\ntype Auth struct {\n\tappKey    string\n\tappSecret string\n}\n\nfunc (a *Auth) Check(ctx context.Context) error {\n\tmd, ok := metadata.FromIncomingContext(ctx)\n\tif !ok {\n\t\treturn status.Errorf(codes.Unauthenticated, "自定义认证 Token 失败")\n\t}\n\n\tvar (\n\t\tappKey    string\n\t\tappSecret string\n\t)\n\tif value, ok := md["app_key"]; ok {\n\t\tappKey = value[0]\n\t}\n\tif value, ok := md["app_secret"]; ok {\n\t\tappSecret = value[0]\n\t}\n\n\tif appKey != a.GetAppKey() || appSecret != a.GetAppSecret() {\n\t\treturn status.Errorf(codes.Unauthenticated, "自定义认证 Token 无效")\n\t}\n\n\treturn nil\n}\n\nfunc (a *Auth) GetAppKey() string {\n\treturn "eddycjy"\n}\n\nfunc (a *Auth) GetAppSecret() string {\n\treturn "20181005"\n}\n')])])]),r("p",[t._v("在 Server 端就更简单了，实际就是调用 "),r("code",[t._v("metadata.FromIncomingContext")]),t._v(" 从上下文中获取 metadata，再在不同的 RPC 方法中进行认证检查")]),t._v(" "),r("h3",{attrs:{id:"验证"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#验证"}},[t._v("#")]),t._v(" 验证")]),t._v(" "),r("p",[t._v("重新启动 server.go 和 client.go，得到以下结果：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("$ go run client.go\n2018/10/05 20:59:58 resp: gRPC Token Server\n")])])]),r("p",[t._v("修改 client.go 的值，制造两者不一致，得到无效结果：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("$ go run client.go\n2018/10/05 21:00:05 client.Search err: rpc error: code = Unauthenticated desc = invalid token\nexit status 1\n")])])]),r("h3",{attrs:{id:"一个个加太麻烦"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一个个加太麻烦"}},[t._v("#")]),t._v(" 一个个加太麻烦")]),t._v(" "),r("p",[t._v("我相信你肯定会问一个个加，也太麻烦了吧？有这个想法的你，应当把 "),r("code",[t._v("type PerRPCCredentials interface")]),t._v(" 做成一个拦截器（interceptor）")]),t._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),r("p",[t._v("本章节比较简单，主要是针对 RPC 方法的自定义认证进行了介绍，如果是想做全局的，建议是举一反三从拦截器下手哦。")]),t._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),r("h3",{attrs:{id:"本系列示例代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本系列示例代码"}},[t._v("#")]),t._v(" 本系列示例代码")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/EDDYCJY/go-grpc-example",target:"_blank",rel:"noopener noreferrer"}},[t._v("go-grpc-example"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);