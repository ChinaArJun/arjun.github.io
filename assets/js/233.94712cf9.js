(window.webpackJsonp=window.webpackJsonp||[]).push([[233],{668:function(e,r,t){"use strict";t.r(r);var n=t(44),o=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_5-2-hello-world"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-hello-world"}},[e._v("#")]),e._v(" 5.2 Hello World")]),e._v(" "),t("p",[e._v("这节将开始编写一个复杂的Hello World，涉及到许多的知识，建议大家认真思考其中的概念")]),e._v(" "),t("h2",{attrs:{id:"需求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需求"}},[e._v("#")]),e._v(" 需求")]),e._v(" "),t("p",[e._v("由于本实践偏向"),t("code",[e._v("Grpc")]),e._v("+"),t("code",[e._v("Grpc Gateway")]),e._v("的方面，我们的需求是"),t("strong",[e._v("同一个服务端支持"),t("code",[e._v("Rpc")]),e._v("和"),t("code",[e._v("Restful Api")])]),e._v("，那么就意味着"),t("code",[e._v("http2")]),e._v("、"),t("code",[e._v("TLS")]),e._v("等等的应用，功能方面就是一个服务端能够接受来自"),t("code",[e._v("grpc")]),e._v("和"),t("code",[e._v("Restful Api")]),e._v("的请求并响应")]),e._v(" "),t("h2",{attrs:{id:"一、初始化目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、初始化目录"}},[e._v("#")]),e._v(" 一、初始化目录")]),e._v(" "),t("p",[e._v("我们先在$GOPATH中新建"),t("code",[e._v("grpc-hello-world")]),e._v("文件夹，我们项目的初始目录目录如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("grpc-hello-world/\n├── certs\n├── client\n├── cmd\n├── pkg\n├── proto\n│   ├── google\n│   │   └── api\n└── server\n")])])]),t("ul",[t("li",[t("code",[e._v("certs")]),e._v("：证书凭证")]),e._v(" "),t("li",[t("code",[e._v("client")]),e._v("：客户端")]),e._v(" "),t("li",[t("code",[e._v("cmd")]),e._v("：命令行")]),e._v(" "),t("li",[t("code",[e._v("pkg")]),e._v("：第三方公共模块")]),e._v(" "),t("li",[t("code",[e._v("proto")]),e._v("："),t("code",[e._v("protobuf")]),e._v("的一些相关文件（含"),t("code",[e._v(".proto")]),e._v("、"),t("code",[e._v("pb.go")]),e._v("、"),t("code",[e._v(".pb.gw.go")]),e._v(")，"),t("code",[e._v("google/api")]),e._v("中用于存放"),t("code",[e._v("annotations.proto")]),e._v("、"),t("code",[e._v("http.proto")])]),e._v(" "),t("li",[t("code",[e._v("server")]),e._v("：服务端")])]),e._v(" "),t("h2",{attrs:{id:"二、制作证书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、制作证书"}},[e._v("#")]),e._v(" 二、制作证书")]),e._v(" "),t("p",[e._v("在服务端支持"),t("code",[e._v("Rpc")]),e._v("和"),t("code",[e._v("Restful Api")]),e._v("，需要用到"),t("code",[e._v("TLS")]),e._v("，因此我们要先制作证书")]),e._v(" "),t("p",[e._v("进入"),t("code",[e._v("certs")]),e._v("目录，生成"),t("code",[e._v("TLS")]),e._v("所需的公钥密钥文件")]),e._v(" "),t("h3",{attrs:{id:"私钥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#私钥"}},[e._v("#")]),e._v(" 私钥")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("openssl genrsa -out server.key 2048\n\nopenssl ecparam -genkey -name secp384r1 -out server.key\n")])])]),t("ul",[t("li",[t("code",[e._v("openssl genrsa")]),e._v("：生成"),t("code",[e._v("RSA")]),e._v("私钥，命令的最后一个参数，将指定生成密钥的位数，如果没有指定，默认512")]),e._v(" "),t("li",[t("code",[e._v("openssl ecparam")]),e._v("：生成"),t("code",[e._v("ECC")]),e._v("私钥，命令为椭圆曲线密钥参数生成及操作，本文中"),t("code",[e._v("ECC")]),e._v("曲线选择的是"),t("code",[e._v("secp384r1")])])]),e._v(" "),t("h3",{attrs:{id:"自签名公钥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自签名公钥"}},[e._v("#")]),e._v(" 自签名公钥")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650\n")])])]),t("ul",[t("li",[t("code",[e._v("openssl req")]),e._v("：生成自签名证书，"),t("code",[e._v("-new")]),e._v("指生成证书请求、"),t("code",[e._v("-sha256")]),e._v("指使用"),t("code",[e._v("sha256")]),e._v("加密、"),t("code",[e._v("-key")]),e._v("指定私钥文件、"),t("code",[e._v("-x509")]),e._v("指输出证书、"),t("code",[e._v("-days 3650")]),e._v("为有效期，此后则输入证书拥有者信息")])]),e._v(" "),t("h3",{attrs:{id:"填写信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#填写信息"}},[e._v("#")]),e._v(" 填写信息")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Country Name (2 letter code) [XX]:\nState or Province Name (full name) []:\nLocality Name (eg, city) [Default City]:\nOrganization Name (eg, company) [Default Company Ltd]:\nOrganizational Unit Name (eg, section) []:\nCommon Name (eg, your name or your server's hostname) []:grpc server name\nEmail Address []:\n")])])]),t("h2",{attrs:{id:"三、proto"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、proto"}},[e._v("#")]),e._v(" 三、"),t("code",[e._v("proto")])]),e._v(" "),t("h3",{attrs:{id:"编写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写"}},[e._v("#")]),e._v(" 编写")]),e._v(" "),t("p",[e._v("1、 "),t("code",[e._v("google.api")])]),e._v(" "),t("p",[e._v("我们看到"),t("code",[e._v("proto")]),e._v("目录中有"),t("code",[e._v("google/api")]),e._v("目录，它用到了"),t("code",[e._v("google")]),e._v("官方提供的两个"),t("code",[e._v("api")]),e._v("描述文件，主要是针对"),t("code",[e._v("grpc-gateway")]),e._v("的"),t("code",[e._v("http")]),e._v("转换提供支持，定义了"),t("code",[e._v("Protocol Buffer")]),e._v("所扩展的"),t("code",[e._v("HTTP Option")])]),e._v(" "),t("p",[t("code",[e._v("annotations.proto")]),e._v("文件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Copyright (c) 2015, Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = "proto3";\n\npackage google.api;\n\nimport "google/api/http.proto";\nimport "google/protobuf/descriptor.proto";\n\noption java_multiple_files = true;\noption java_outer_classname = "AnnotationsProto";\noption java_package = "com.google.api";\n\nextend google.protobuf.MethodOptions {\n  // See `HttpRule`.\n  HttpRule http = 72295728;\n}\n\n')])])]),t("p",[t("code",[e._v("http.proto")]),e._v("文件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// Copyright 2016 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nsyntax = "proto3";\n\npackage google.api;\n\noption cc_enable_arenas = true;\noption java_multiple_files = true;\noption java_outer_classname = "HttpProto";\noption java_package = "com.google.api";\n\n\n// Defines the HTTP configuration for a service. It contains a list of\n// [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method\n// to one or more HTTP REST API methods.\nmessage Http {\n  // A list of HTTP rules for configuring the HTTP REST API methods.\n  repeated HttpRule rules = 1;\n}\n\n// Use CustomHttpPattern to specify any HTTP method that is not included in the\n// `pattern` field, such as HEAD, or "*" to leave the HTTP method unspecified for\n// a given URL path rule. The wild-card rule is useful for services that provide\n// content to Web (HTML) clients.\nmessage HttpRule {\n  // Selects methods to which this rule applies.\n  //\n  // Refer to [selector][google.api.DocumentationRule.selector] for syntax details.\n  string selector = 1;\n\n  // Determines the URL pattern is matched by this rules. This pattern can be\n  // used with any of the {get|put|post|delete|patch} methods. A custom method\n  // can be defined using the \'custom\' field.\n  oneof pattern {\n    // Used for listing and getting information about resources.\n    string get = 2;\n\n    // Used for updating a resource.\n    string put = 3;\n\n    // Used for creating a resource.\n    string post = 4;\n\n    // Used for deleting a resource.\n    string delete = 5;\n\n    // Used for updating a resource.\n    string patch = 6;\n\n    // Custom pattern is used for defining custom verbs.\n    CustomHttpPattern custom = 8;\n  }\n\n  // The name of the request field whose value is mapped to the HTTP body, or\n  // `*` for mapping all fields not captured by the path pattern to the HTTP\n  // body. NOTE: the referred field must not be a repeated field.\n  string body = 7;\n\n  // Additional HTTP bindings for the selector. Nested bindings must\n  // not contain an `additional_bindings` field themselves (that is,\n  // the nesting may only be one level deep).\n  repeated HttpRule additional_bindings = 11;\n}\n\n// A custom pattern is used for defining custom HTTP verb.\nmessage CustomHttpPattern {\n  // The name of this custom HTTP verb.\n  string kind = 1;\n\n  // The path matched by this custom verb.\n  string path = 2;\n}\n\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[t("code",[e._v("hello.proto")])])]),e._v(" "),t("p",[e._v("这一小节将编写"),t("code",[e._v("Demo")]),e._v("的"),t("code",[e._v(".proto")]),e._v("文件，我们在"),t("code",[e._v("proto")]),e._v("目录下新建"),t("code",[e._v("hello.proto")]),e._v("文件，写入文件内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('syntax = "proto3";\n\npackage proto;\n\nimport "google/api/annotations.proto";\n\nservice HelloWorld {\n    rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse) {\n        option (google.api.http) = {\n            post: "/hello_world"\n            body: "*"\n        };\n    }\n}\n\nmessage HelloWorldRequest {\n    string referer = 1;\n}\n\nmessage HelloWorldResponse {\n    string message = 1;\n}\n')])])]),t("p",[e._v("在"),t("code",[e._v("hello.proto")]),e._v("文件中，引用了"),t("code",[e._v("google/api/annotations.proto")]),e._v("，达到支持"),t("code",[e._v("HTTP Option")]),e._v("的效果")]),e._v(" "),t("ul",[t("li",[e._v("定义了一个"),t("code",[e._v("service")]),e._v("RPC服务"),t("code",[e._v("HelloWorld")]),e._v("，在其内部定义了一个"),t("code",[e._v("HTTP Option")]),e._v("的"),t("code",[e._v("POST")]),e._v("方法，"),t("code",[e._v("HTTP")]),e._v("响应路径为"),t("code",[e._v("/hello_world")])]),e._v(" "),t("li",[e._v("定义"),t("code",[e._v("message")]),e._v("类型"),t("code",[e._v("HelloWorldRequest")]),e._v("、"),t("code",[e._v("HelloWorldResponse")]),e._v("，用于响应请求和返回结果")])]),e._v(" "),t("h3",{attrs:{id:"编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译"}},[e._v("#")]),e._v(" 编译")]),e._v(" "),t("p",[e._v("在编写完"),t("code",[e._v(".proto")]),e._v("文件后，我们需要对其进行编译，就能够在"),t("code",[e._v("server")]),e._v("中使用")]),e._v(" "),t("p",[e._v("进入"),t("code",[e._v("proto")]),e._v("目录，执行以下命令")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# 编译google.api\nprotoc -I . --go_out=plugins=grpc,Mgoogle/protobuf/descriptor.proto=github.com/golang/protobuf/protoc-gen-go/descriptor:. google/api/*.proto\n\n#编译hello_http.proto为hello_http.pb.proto\nprotoc -I . --go_out=plugins=grpc,Mgoogle/api/annotations.proto=grpc-hello-world/proto/google/api:. ./hello.proto\n\n#编译hello_http.proto为hello_http.pb.gw.proto\nprotoc --grpc-gateway_out=logtostderr=true:. ./hello.proto\n")])])]),t("p",[e._v("执行完毕后将生成"),t("code",[e._v("hello.pb.go")]),e._v("和"),t("code",[e._v("hello.gw.pb.go")]),e._v("，分别针对"),t("code",[e._v("grpc")]),e._v("和"),t("code",[e._v("grpc-gateway")]),e._v("的功能支持")]),e._v(" "),t("h2",{attrs:{id:"四、命令行模块-cmd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、命令行模块-cmd"}},[e._v("#")]),e._v(" 四、命令行模块 "),t("code",[e._v("cmd")])]),e._v(" "),t("h3",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),t("p",[e._v("这一小节我们编写命令行模块，为什么要独立出来呢，是为了将"),t("code",[e._v("cmd")]),e._v("和"),t("code",[e._v("server")]),e._v("两者解耦，避免混淆在一起。")]),e._v(" "),t("p",[e._v("我们采用 "),t("a",{attrs:{href:"https://github.com/spf13/cobra",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cobra"),t("OutboundLink")],1),e._v(" 来完成这项功能，"),t("code",[e._v("Cobra")]),e._v("既是创建强大的现代CLI应用程序的库，也是生成应用程序和命令文件的程序。提供了以下功能：")]),e._v(" "),t("ul",[t("li",[e._v("简易的子命令行模式")]),e._v(" "),t("li",[e._v("完全兼容posix的命令行模式(包括短和长版本)")]),e._v(" "),t("li",[e._v("嵌套的子命令")]),e._v(" "),t("li",[e._v("全局、本地和级联"),t("code",[e._v("flags")])]),e._v(" "),t("li",[e._v("使用"),t("code",[e._v("Cobra")]),e._v("很容易的生成应用程序和命令，使用"),t("code",[e._v("cobra create appname")]),e._v("和"),t("code",[e._v("cobra add cmdname")])]),e._v(" "),t("li",[e._v("智能提示")]),e._v(" "),t("li",[e._v("自动生成commands和flags的帮助信息")]),e._v(" "),t("li",[e._v("自动生成详细的help信息"),t("code",[e._v("-h")]),e._v("，"),t("code",[e._v("--help")]),e._v("等等")]),e._v(" "),t("li",[e._v("自动生成的bash自动完成功能")]),e._v(" "),t("li",[e._v("为应用程序自动生成手册")]),e._v(" "),t("li",[e._v("命令别名")]),e._v(" "),t("li",[e._v("定义您自己的帮助、用法等的灵活性。")]),e._v(" "),t("li",[e._v("可选与"),t("a",{attrs:{href:"https://github.com/spf13/viper",target:"_blank",rel:"noopener noreferrer"}},[e._v("viper"),t("OutboundLink")],1),e._v("紧密集成的apps")])]),e._v(" "),t("h3",{attrs:{id:"编写server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写server"}},[e._v("#")]),e._v(" 编写"),t("code",[e._v("server")])]),e._v(" "),t("p",[e._v("在编写"),t("code",[e._v("cmd")]),e._v("时需要先用"),t("code",[e._v("server")]),e._v("进行测试关联，因此这一步我们先写"),t("code",[e._v("server.go")]),e._v("用于测试")]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("server")]),e._v("模块下 新建"),t("code",[e._v("server.go")]),e._v("文件，写入测试内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package server\n\nimport (\n    "log"\n)\n\nvar (\n    ServerPort string\n    CertName string\n    CertPemPath string\n    CertKeyPath string\n)\n\nfunc Serve() (err error){\n    log.Println(ServerPort)\n    \n    log.Println(CertName)\n    \n    log.Println(CertPemPath)\n    \n    log.Println(CertKeyPath)\n    \n    return nil\n}\n\n')])])]),t("h3",{attrs:{id:"编写cmd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写cmd"}},[e._v("#")]),e._v(" 编写"),t("code",[e._v("cmd")])]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("cmd")]),e._v("模块下 新建"),t("code",[e._v("root.go")]),e._v("文件，写入内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package cmd\n\nimport (\n    "fmt"\n    "os"\n\n    "github.com/spf13/cobra"\n)\n\nvar rootCmd = &cobra.Command{\n    Use:   "grpc",\n    Short: "Run the gRPC hello-world server",\n}\n\nfunc Execute() {\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Println(err)\n        os.Exit(-1)\n    }\n}\n')])])]),t("p",[e._v("新建"),t("code",[e._v("server.go")]),e._v("文件，写入内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package cmd\n\nimport (\n\t"log"\n\n\t"github.com/spf13/cobra"\n\t\n\t"grpc-hello-world/server"\n)\n\nvar serverCmd = &cobra.Command{\n\tUse:   "server",\n\tShort: "Run the gRPC hello-world server",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tlog.Println("Recover error : %v", err)\n\t\t\t}\n\t\t}()\n\t\t\n\t\tserver.Serve()\n\t},\n}\n\nfunc init() {\n\tserverCmd.Flags().StringVarP(&server.ServerPort, "port", "p", "50052", "server port")\n\tserverCmd.Flags().StringVarP(&server.CertPemPath, "cert-pem", "", "./certs/server.pem", "cert pem path")\n\tserverCmd.Flags().StringVarP(&server.CertKeyPath, "cert-key", "", "./certs/server.key", "cert key path")\n\tserverCmd.Flags().StringVarP(&server.CertName, "cert-name", "", "grpc server name", "server\'s hostname")\n\trootCmd.AddCommand(serverCmd)\n}\n')])])]),t("p",[e._v("我们在"),t("code",[e._v("grpc-hello-world/")]),e._v("目录下，新建文件"),t("code",[e._v("main.go")]),e._v("，写入内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package main\n\nimport (\n\t"grpc-hello-world/cmd"\n)\n\nfunc main() {\n\tcmd.Execute()\n}\n')])])]),t("h3",{attrs:{id:"讲解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讲解"}},[e._v("#")]),e._v(" 讲解")]),e._v(" "),t("p",[e._v("要使用"),t("code",[e._v("Cobra")]),e._v("，按照"),t("code",[e._v("Cobra")]),e._v("标准要创建"),t("code",[e._v("main.go")]),e._v("和一个"),t("code",[e._v("rootCmd")]),e._v("文件，另外我们有子命令"),t("code",[e._v("server")])]),e._v(" "),t("p",[e._v("1、"),t("code",[e._v("rootCmd")]),e._v("：\n"),t("code",[e._v("rootCmd")]),e._v("表示在没有任何子命令的情况下的基本命令")]),e._v(" "),t("p",[e._v("2、"),t("code",[e._v("&cobra.Command")]),e._v("：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Use")]),e._v("："),t("code",[e._v("Command")]),e._v("的用法，"),t("code",[e._v("Use")]),e._v("是一个行用法消息")]),e._v(" "),t("li",[t("code",[e._v("Short")]),e._v("："),t("code",[e._v("Short")]),e._v("是"),t("code",[e._v("help")]),e._v("命令输出中显示的简短描述")]),e._v(" "),t("li",[t("code",[e._v("Run")]),e._v("：运行:典型的实际工作功能。大多数命令只会实现这一点；另外还有"),t("code",[e._v("PreRun")]),e._v("、"),t("code",[e._v("PreRunE")]),e._v("、"),t("code",[e._v("PostRun")]),e._v("、"),t("code",[e._v("PostRunE")]),e._v("等等不同时期的运行命令，但比较少用，具体使用时再查看亦可")])]),e._v(" "),t("p",[e._v("3、"),t("code",[e._v("rootCmd.AddCommand")]),e._v("："),t("code",[e._v("AddCommand")]),e._v("向这父命令（"),t("code",[e._v("rootCmd")]),e._v("）添加一个或多个命令")]),e._v(" "),t("p",[e._v("4、"),t("code",[e._v("serverCmd.Flags().StringVarP()")]),e._v("：")]),e._v(" "),t("p",[e._v("一般来说，我们需要在"),t("code",[e._v("init()")]),e._v("函数中定义"),t("code",[e._v("flags")]),e._v("和处理配置，以"),t("code",[e._v('serverCmd.Flags().StringVarP(&server.ServerPort, "port", "p", "50052", "server port")')]),e._v("为例，我们定义了一个"),t("code",[e._v("flag")]),e._v("，值存储在"),t("code",[e._v("&server.ServerPort")]),e._v("中，长命令为"),t("code",[e._v("--port")]),e._v("，短命令为"),t("code",[e._v("-p")]),e._v("，，默认值为"),t("code",[e._v("50052")]),e._v("，命令的描述为"),t("code",[e._v("server port")]),e._v("。这一种调用方式成为"),t("code",[e._v("Local Flags")])]),e._v(" "),t("p",[e._v("我们延伸一下，如果觉得每一个子命令都要设一遍觉得很麻烦，我们可以采用"),t("code",[e._v("Persistent Flags")]),e._v("：")]),e._v(" "),t("p",[t("code",[e._v('rootCmd.PersistentFlags().BoolVarP(&Verbose, "verbose", "v", false, "verbose output")')])]),e._v(" "),t("p",[e._v("作用：")]),e._v(" "),t("p",[t("code",[e._v("flag")]),e._v("是可以持久的，这意味着该"),t("code",[e._v("flag")]),e._v("将被分配给它所分配的命令以及该命令下的每个命令。对于全局标记，将标记作为根上的持久标志。")]),e._v(" "),t("p",[e._v("另外还有"),t("code",[e._v("Local Flag on Parent Commands")]),e._v("、"),t("code",[e._v("Bind Flags with Config")]),e._v("、"),t("code",[e._v("Required flags")]),e._v("等等，使用到再 "),t("a",{attrs:{href:"https://github.com/spf13/cobra#local-flag-on-parent-commands",target:"_blank",rel:"noopener noreferrer"}},[e._v("传送"),t("OutboundLink")],1),e._v(" 了解即可")]),e._v(" "),t("h3",{attrs:{id:"测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试"}},[e._v("#")]),e._v(" 测试")]),e._v(" "),t("p",[e._v("回到"),t("code",[e._v("grpc-hello-world/")]),e._v("目录下执行"),t("code",[e._v("go run main.go server")]),e._v("，查看输出是否为（此时应为默认值）：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("2018/02/25 23:23:21 50052\n2018/02/25 23:23:21 dev\n2018/02/25 23:23:21 ./certs/server.pem\n2018/02/25 23:23:21 ./certs/server.key\n")])])]),t("p",[e._v("执行"),t("code",[e._v("go run main.go server --port=8000 --cert-pem=test-pem --cert-key=test-key --cert-name=test-name")]),e._v("，检验命令行参数是否正确：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("2018/02/25 23:24:56 8000\n2018/02/25 23:24:56 test-name\n2018/02/25 23:24:56 test-pem\n2018/02/25 23:24:56 test-key\n")])])]),t("p",[e._v("若都无误，那么恭喜你"),t("code",[e._v("cmd")]),e._v("模块的编写正确了，下一部分开始我们的重点章节！")]),e._v(" "),t("h2",{attrs:{id:"五、服务端模块-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、服务端模块-server"}},[e._v("#")]),e._v(" 五、服务端模块 "),t("code",[e._v("server")])]),e._v(" "),t("h3",{attrs:{id:"编写hello-go"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写hello-go"}},[e._v("#")]),e._v(" 编写"),t("code",[e._v("hello.go")])]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("server")]),e._v("目录下新建文件"),t("code",[e._v("hello.go")]),e._v("，写入文件内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package server\n\nimport (\n\t"golang.org/x/net/context"\n\n\tpb "grpc-hello-world/proto"\n)\n\ntype helloService struct{}\n\nfunc NewHelloService() *helloService {\n\treturn &helloService{}\n}\n\nfunc (h helloService) SayHelloWorld(ctx context.Context, r *pb.HelloWorldRequest) (*pb.HelloWorldResponse, error) {\n\treturn &pb.HelloWorldResponse{\n\t\tMessage : "test",\n\t}, nil\n}\n')])])]),t("p",[e._v("我们创建了"),t("code",[e._v("helloService")]),e._v("及其方法"),t("code",[e._v("SayHelloWorld")]),e._v("，对应"),t("code",[e._v(".proto")]),e._v("的"),t("code",[e._v("rpc SayHelloWorld")]),e._v("，这个方法需要有2个参数："),t("code",[e._v("ctx context.Context")]),e._v("用于接受上下文参数、"),t("code",[e._v("r *pb.HelloWorldRequest")]),e._v("用于接受"),t("code",[e._v("protobuf")]),e._v("的"),t("code",[e._v("Request")]),e._v("参数（对应"),t("code",[e._v(".proto")]),e._v("的"),t("code",[e._v("message HelloWorldRequest")]),e._v("）")]),e._v(" "),t("h3",{attrs:{id:"编写server-go"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写server-go"}},[e._v("#")]),e._v(" *编写"),t("code",[e._v("server.go")])]),e._v(" "),t("p",[e._v("这一小章节，我们编写最为重要的服务端程序部分，涉及到大量的"),t("code",[e._v("grpc")]),e._v("、"),t("code",[e._v("grpc-gateway")]),e._v("及一些网络知识的应用")]),e._v(" "),t("p",[e._v("1、在"),t("code",[e._v("pkg")]),e._v("下新建"),t("code",[e._v("util")]),e._v("目录，新建"),t("code",[e._v("grpc.go")]),e._v("文件，写入内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package util\n\nimport (\n\t"net/http"\n\t"strings"\n\n\t"google.golang.org/grpc"\n)\n\nfunc GrpcHandlerFunc(grpcServer *grpc.Server, otherHandler http.Handler) http.Handler {\n    if otherHandler == nil {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            grpcServer.ServeHTTP(w, r)\n        })\n    }\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        if r.ProtoMajor == 2 && strings.Contains(r.Header.Get("Content-Type"), "application/grpc") {\n            grpcServer.ServeHTTP(w, r)\n        } else {\n            otherHandler.ServeHTTP(w, r)\n        }\n    })\n}\n')])])]),t("p",[t("code",[e._v("GrpcHandlerFunc")]),e._v("函数是用于判断请求是来源于"),t("code",[e._v("Rpc")]),e._v("客户端还是"),t("code",[e._v("Restful Api")]),e._v("的请求，根据不同的请求注册不同的"),t("code",[e._v("ServeHTTP")]),e._v("服务；"),t("code",[e._v("r.ProtoMajor == 2")]),e._v("也代表着请求必须基于"),t("code",[e._v("HTTP/2")])]),e._v(" "),t("p",[e._v("2、在"),t("code",[e._v("pkg")]),e._v("下的"),t("code",[e._v("util")]),e._v("目录下，新建"),t("code",[e._v("tls.go")]),e._v("文件，写入内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package util\n\nimport (\n\t"crypto/tls"\n    "io/ioutil"\n    "log"\n\n    "golang.org/x/net/http2"\n)\n\nfunc GetTLSConfig(certPemPath, certKeyPath string) *tls.Config {\n    var certKeyPair *tls.Certificate\n    cert, _ := ioutil.ReadFile(certPemPath)\n    key, _ := ioutil.ReadFile(certKeyPath)\n    \n    pair, err := tls.X509KeyPair(cert, key)\n    if err != nil {\n        log.Println("TLS KeyPair err: %v\\n", err)\n    }\n    \n    certKeyPair = &pair\n\n    return &tls.Config{\n        Certificates: []tls.Certificate{*certKeyPair},\n        NextProtos:   []string{http2.NextProtoTLS},\n    }\n}\n')])])]),t("p",[t("code",[e._v("GetTLSConfig")]),e._v("函数是用于获取"),t("code",[e._v("TLS")]),e._v("配置，在内部，我们读取了"),t("code",[e._v("server.key")]),e._v("和"),t("code",[e._v("server.pem")]),e._v("这类证书凭证文件")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("tls.X509KeyPair")]),e._v("：从一对"),t("code",[e._v("PEM")]),e._v("编码的数据中解析公钥/私钥对。成功则返回公钥/私钥对")]),e._v(" "),t("li",[t("code",[e._v("http2.NextProtoTLS")]),e._v("："),t("code",[e._v("NextProtoTLS")]),e._v("是谈判期间的"),t("code",[e._v("NPN/ALPN")]),e._v("协议，用于"),t("strong",[e._v("HTTP/2的TLS设置")])]),e._v(" "),t("li",[t("code",[e._v("tls.Certificate")]),e._v("：返回一个或多个证书，实质我们解析"),t("code",[e._v("PEM")]),e._v("调用的"),t("code",[e._v("X509KeyPair")]),e._v("的函数声明就是"),t("code",[e._v("func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)")]),e._v("，返回值就是"),t("code",[e._v("Certificate")])])]),e._v(" "),t("p",[e._v("总的来说该函数是用于处理从证书凭证文件（PEM），最终获取"),t("code",[e._v("tls.Config")]),e._v("作为"),t("code",[e._v("HTTP2")]),e._v("的使用参数")]),e._v(" "),t("p",[e._v("3、修改"),t("code",[e._v("server")]),e._v("目录下的"),t("code",[e._v("server.go")]),e._v("文件，该文件是我们服务里的核心文件，写入内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package server\n\nimport (\n    "crypto/tls"\n    "net"\n    "net/http"\n    "log"\n\n    "golang.org/x/net/context"\n    "google.golang.org/grpc"\n    "google.golang.org/grpc/credentials"\n    "github.com/grpc-ecosystem/grpc-gateway/runtime"\n    \n    pb "grpc-hello-world/proto"\n    "grpc-hello-world/pkg/util"\n)\n\nvar (\n    ServerPort string\n    CertName string\n    CertPemPath string\n    CertKeyPath string\n    EndPoint string\n)\n\nfunc Serve() (err error){\n    EndPoint = ":" + ServerPort\n    conn, err := net.Listen("tcp", EndPoint)\n    if err != nil {\n        log.Printf("TCP Listen err:%v\\n", err)\n    }\n\n    tlsConfig := util.GetTLSConfig(CertPemPath, CertKeyPath)\n    srv := createInternalServer(conn, tlsConfig)\n\n    log.Printf("gRPC and https listen on: %s\\n", ServerPort)\n\n    if err = srv.Serve(tls.NewListener(conn, tlsConfig)); err != nil {\n        log.Printf("ListenAndServe: %v\\n", err)\n    }\n\n    return err\n}\n\nfunc createInternalServer(conn net.Listener, tlsConfig *tls.Config) (*http.Server) {\n    var opts []grpc.ServerOption\n\n    // grpc server\n    creds, err := credentials.NewServerTLSFromFile(CertPemPath, CertKeyPath)\n    if err != nil {\n        log.Printf("Failed to create server TLS credentials %v", err)\n    }\n\n    opts = append(opts, grpc.Creds(creds))\n    grpcServer := grpc.NewServer(opts...)\n\n    // register grpc pb\n    pb.RegisterHelloWorldServer(grpcServer, NewHelloService())\n\n    // gw server\n    ctx := context.Background()\n    dcreds, err := credentials.NewClientTLSFromFile(CertPemPath, CertName)\n    if err != nil {\n        log.Printf("Failed to create client TLS credentials %v", err)\n    }\n    dopts := []grpc.DialOption{grpc.WithTransportCredentials(dcreds)}\n    gwmux := runtime.NewServeMux()\n\n    // register grpc-gateway pb\n    if err := pb.RegisterHelloWorldHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != nil {\n        log.Printf("Failed to register gw server: %v\\n", err)\n    }\n\n    // http服务\n    mux := http.NewServeMux()\n    mux.Handle("/", gwmux)\n\n    return &http.Server{\n        Addr:      EndPoint,\n        Handler:   util.GrpcHandlerFunc(grpcServer, mux),\n        TLSConfig: tlsConfig,\n    }\n}\n')])])]),t("h4",{attrs:{id:"server流程剖析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#server流程剖析"}},[e._v("#")]),e._v(" "),t("code",[e._v("server")]),e._v("流程剖析")]),e._v(" "),t("p",[e._v("我们将这一大块代码，分成以下几个部分来理解")]),e._v(" "),t("h5",{attrs:{id:"一、启动监听"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、启动监听"}},[e._v("#")]),e._v(" 一、启动监听")]),e._v(" "),t("p",[t("code",[e._v('net.Listen("tcp", EndPoint)')]),e._v("用于监听本地的网络地址通知，它的函数原型"),t("code",[e._v("func Listen(network, address string) (Listener, error)")])]),e._v(" "),t("p",[e._v("参数："),t("code",[e._v("network")]),e._v("必须传入"),t("code",[e._v("tcp")]),e._v("、"),t("code",[e._v("tcp4")]),e._v("、"),t("code",[e._v("tcp6")]),e._v("、"),t("code",[e._v("unix")]),e._v("、"),t("code",[e._v("unixpacket")]),e._v("，若"),t("code",[e._v("address")]),e._v("为空或为0则会自动选择一个端口号\n返回值：通过查看源码我们可以得知其返回值为"),t("code",[e._v("Listener")]),e._v("，结构体原型：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type Listener interface {\n    Accept() (Conn, error)\n    Close() error\n    Addr() Addr\n}\n")])])]),t("p",[e._v("通过分析得知，"),t("strong",[e._v("最后"),t("code",[e._v("net.Listen")]),e._v("会返回一个监听器的结构体，返回给接下来的动作，让其执行下一步的操作")]),e._v("，它可以执行三类操作")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Accept")]),e._v("：接受等待并将下一个连接返回给"),t("code",[e._v("Listener")])]),e._v(" "),t("li",[t("code",[e._v("Close")]),e._v("：关闭"),t("code",[e._v("Listener")])]),e._v(" "),t("li",[t("code",[e._v("Addr")]),e._v("：返回"),t("code",[e._v("Listener")]),e._v("的网络地址")])]),e._v(" "),t("h5",{attrs:{id:"二、获取tls"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、获取tls"}},[e._v("#")]),e._v(" 二、获取"),t("code",[e._v("TLS")])]),e._v(" "),t("p",[e._v("通过"),t("code",[e._v("util.GetTLSConfig")]),e._v("解析得到"),t("code",[e._v("tls.Config")]),e._v("，传达给"),t("code",[e._v("http.Server")]),e._v("服务的"),t("code",[e._v("TLSConfig")]),e._v("配置项使用")]),e._v(" "),t("h5",{attrs:{id:"三、创建内部服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、创建内部服务"}},[e._v("#")]),e._v(" 三、创建内部服务")]),e._v(" "),t("p",[t("code",[e._v("createInternalServer")]),e._v("函数，是整个服务端的核心流转部分")]),e._v(" "),t("p",[e._v("程序采用的是"),t("code",[e._v("HTT2")]),e._v("、"),t("code",[e._v("HTTPS")]),e._v("也就是需要支持"),t("code",[e._v("TLS")]),e._v("，因此在启动"),t("code",[e._v("grpc.NewServer")]),e._v("前，我们要将认证的中间件注册进去")]),e._v(" "),t("p",[e._v("而前面所获取的"),t("code",[e._v("tlsConfig")]),e._v("仅能给"),t("code",[e._v("HTTP")]),e._v("使用，因此"),t("strong",[e._v("第一步")]),e._v("我们要创建"),t("code",[e._v("grpc")]),e._v("的"),t("code",[e._v("TLS")]),e._v("认证凭证")]),e._v(" "),t("p",[t("strong",[e._v("1、创建"),t("code",[e._v("grpc")]),e._v("的"),t("code",[e._v("TLS")]),e._v("认证凭证")])]),e._v(" "),t("p",[e._v("新增引用"),t("code",[e._v("google.golang.org/grpc/credentials")]),e._v("的第三方包，它实现了"),t("code",[e._v("grpc")]),e._v("库支持的各种凭证，该凭证封装了客户机需要的所有状态，以便与服务器进行身份验证并进行各种断言，例如关于客户机的身份，角色或是否授权进行特定的呼叫")]),e._v(" "),t("p",[e._v("我们调用"),t("code",[e._v("NewServerTLSFromFile")]),e._v("来达到我们的目的，它能够从输入证书文件和服务器的密钥文件"),t("strong",[e._v("构造TLS证书凭证")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func NewServerTLSFromFile(certFile, keyFile string) (TransportCredentials, error) {\n    //LoadX509KeyPair读取并解析来自一对文件的公钥/私钥对\n    cert, err := tls.LoadX509KeyPair(certFile, keyFile)\n    if err != nil {\n        return nil, err\n    }\n    //NewTLS使用tls.Config来构建基于TLS的TransportCredentials\n    return NewTLS(&tls.Config{Certificates: []tls.Certificate{cert}}), nil\n}\n")])])]),t("p",[t("strong",[e._v("2、设置"),t("code",[e._v("grpc ServerOption")])])]),e._v(" "),t("p",[e._v("以"),t("code",[e._v("grpc.Creds(creds)")]),e._v("为例，其原型为"),t("code",[e._v("func Creds(c credentials.TransportCredentials) ServerOption")]),e._v("，该函数返回"),t("code",[e._v("ServerOption")]),e._v("，它为服务器连接设置凭据")]),e._v(" "),t("p",[t("strong",[e._v("3、创建"),t("code",[e._v("grpc")]),e._v("服务端")])]),e._v(" "),t("p",[e._v("函数原型：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func NewServer(opt ...ServerOption) *Server\n")])])]),t("p",[e._v("我们在此处创建了一个没有注册服务的"),t("code",[e._v("grpc")]),e._v("服务端，还没有开始接受请求")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("grpcServer := grpc.NewServer(opts...)\n")])])]),t("p",[t("strong",[e._v("4、注册"),t("code",[e._v("grpc")]),e._v("服务")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("pb.RegisterHelloWorldServer(grpcServer, NewHelloService())\n")])])]),t("p",[t("strong",[e._v("5、创建"),t("code",[e._v("grpc-gateway")]),e._v("关联组件")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('ctx := context.Background()\ndcreds, err := credentials.NewClientTLSFromFile(CertPemPath, CertName)\nif err != nil {\n    log.Println("Failed to create client TLS credentials %v", err)\n}\ndopts := []grpc.DialOption{grpc.WithTransportCredentials(dcreds)}\n')])])]),t("ul",[t("li",[t("code",[e._v("context.Background")]),e._v("：返回一个非空的空上下文。它没有被注销，没有值，没有过期时间。它通常由主函数、初始化和测试使用，并作为传入请求的"),t("strong",[e._v("顶级上下文")])]),e._v(" "),t("li",[t("code",[e._v("credentials.NewClientTLSFromFile")]),e._v("：从客户机的输入证书文件构造TLS凭证")]),e._v(" "),t("li",[t("code",[e._v("grpc.WithTransportCredentials")]),e._v("：配置一个连接级别的安全凭据(例："),t("code",[e._v("TLS")]),e._v("、"),t("code",[e._v("SSL")]),e._v(")，返回值为"),t("code",[e._v("type DialOption")])]),e._v(" "),t("li",[t("code",[e._v("grpc.DialOption")]),e._v("："),t("code",[e._v("DialOption")]),e._v("选项配置我们如何设置连接（其内部具体由多个的"),t("code",[e._v("DialOption")]),e._v("组成，决定其设置连接的内容）")])]),e._v(" "),t("p",[t("strong",[e._v("6、创建"),t("code",[e._v("HTTP NewServeMux")]),e._v("及注册"),t("code",[e._v("grpc-gateway")]),e._v("逻辑")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('gwmux := runtime.NewServeMux()\n\n// register grpc-gateway pb\nif err := pb.RegisterHelloWorldHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != nil {\n    log.Println("Failed to register gw server: %v\\n", err)\n}\n\n// http服务\nmux := http.NewServeMux()\nmux.Handle("/", gwmux)\n')])])]),t("ul",[t("li",[t("code",[e._v("runtime.NewServeMux")]),e._v("：返回一个新的"),t("code",[e._v("ServeMux")]),e._v("，它的内部映射是空的；"),t("code",[e._v("ServeMux")]),e._v("是"),t("code",[e._v("grpc-gateway")]),e._v("的一个请求多路复用器。它将"),t("code",[e._v("http")]),e._v("请求与模式匹配，并调用相应的处理程序")]),e._v(" "),t("li",[t("code",[e._v("RegisterHelloWorldHandlerFromEndpoint")]),e._v("：如函数名，注册"),t("code",[e._v("HelloWorld")]),e._v("服务的"),t("code",[e._v("HTTP Handle")]),e._v("到"),t("code",[e._v("grpc")]),e._v("端点")]),e._v(" "),t("li",[t("code",[e._v("http.NewServeMux")]),e._v("："),t("code",[e._v("分配并返回一个新的ServeMux")])]),e._v(" "),t("li",[t("code",[e._v("mux.Handle")]),e._v("：为给定模式注册处理程序")])]),e._v(" "),t("p",[e._v("（带着疑问去看程序）为什么"),t("code",[e._v("gwmux")]),e._v("可以放入"),t("code",[e._v("mux.Handle")]),e._v("中？")]),e._v(" "),t("p",[e._v("首先我们看看它们的原型是怎么样的")]),e._v(" "),t("p",[e._v("（1）"),t("code",[e._v("http.NewServeMux()")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func NewServeMux() *ServeMux {\n        return new(ServeMux) \n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n")])])]),t("p",[e._v("（2）"),t("code",[e._v("runtime.NewServeMux")]),e._v("？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func NewServeMux(opts ...ServeMuxOption) *ServeMux {\n    serveMux := &ServeMux{\n        handlers:               make(map[string][]handler),\n        forwardResponseOptions: make([]func(context.Context, http.ResponseWriter, proto.Message) error, 0),\n        marshalers:             makeMarshalerMIMERegistry(),\n    }\n    ...\n    return serveMux\n}\n")])])]),t("p",[e._v("（3）"),t("code",[e._v("http.NewServeMux()")]),e._v("的"),t("code",[e._v("Handle")]),e._v("方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func (mux *ServeMux) Handle(pattern string, handler Handler)\n")])])]),t("p",[e._v("通过分析可得知，两者"),t("code",[e._v("NewServeMux")]),e._v("都是最终返回"),t("code",[e._v("serveMux")]),e._v("，"),t("code",[e._v("Handler")]),e._v("中导出的方法仅有"),t("code",[e._v("ServeHTTP")]),e._v("，功能是用于响应HTTP请求")]),e._v(" "),t("p",[e._v("我们回到"),t("code",[e._v("Handle interface")]),e._v("中，可以得出结论就是任何结构体，只要实现了"),t("code",[e._v("ServeHTTP")]),e._v("方法，这个结构就可以称为"),t("code",[e._v("Handle")]),e._v("，"),t("code",[e._v("ServeMux")]),e._v("会使用该"),t("code",[e._v("Handler")]),e._v("调用"),t("code",[e._v("ServeHTTP")]),e._v("方法处理请求，这也就是"),t("strong",[e._v("自定义"),t("code",[e._v("Handler")])])]),e._v(" "),t("p",[e._v("而我们这里正是将"),t("code",[e._v("grpc-gateway")]),e._v("中注册好的"),t("code",[e._v("HTTP Handler")]),e._v("无缝的植入到"),t("code",[e._v("net/http")]),e._v("的"),t("code",[e._v("Handle")]),e._v("方法中")]),e._v(" "),t("p",[t("strong",[e._v("补充：在"),t("code",[e._v("go")]),e._v("中任何结构体只要实现了与接口相同的方法，就等同于实现了接口")])]),e._v(" "),t("p",[t("strong",[e._v("7、注册具体服务")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('if err := pb.RegisterHelloWorldHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != nil {\n    log.Println("Failed to register gw server: %v\\n", err)\n}\n')])])]),t("p",[e._v("在这段代码中，我们利用了前几小节的")]),e._v(" "),t("ul",[t("li",[e._v("上下文")]),e._v(" "),t("li",[t("code",[e._v("gateway-grpc")]),e._v("的请求多路复用器")]),e._v(" "),t("li",[e._v("服务网络地址")]),e._v(" "),t("li",[e._v("配置好的安全凭据")])]),e._v(" "),t("p",[e._v("注册了"),t("code",[e._v("HelloWorld")]),e._v("这一个服务")]),e._v(" "),t("h5",{attrs:{id:"四、创建tls-newlistener"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、创建tls-newlistener"}},[e._v("#")]),e._v(" 四、创建"),t("code",[e._v("tls.NewListener")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func NewListener(inner net.Listener, config *Config) net.Listener {\n    l := new(listener)\n    l.Listener = inner\n    l.config = config\n    return l\n}\n")])])]),t("p",[t("code",[e._v("NewListener")]),e._v("将会创建一个"),t("code",[e._v("Listener")]),e._v("，它接受两个参数，第一个是来自内部"),t("code",[e._v("Listener")]),e._v("的监听器，第二个参数是"),t("code",[e._v("tls.Config")]),e._v("（必须包含至少一个证书）")]),e._v(" "),t("h5",{attrs:{id:"五、服务开始接受请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、服务开始接受请求"}},[e._v("#")]),e._v(" 五、服务开始接受请求")]),e._v(" "),t("p",[e._v("在最后我们调用"),t("code",[e._v("srv.Serve(tls.NewListener(conn, tlsConfig))")]),e._v("，可以得知它是"),t("code",[e._v("http.Server")]),e._v("的方法，并且需要一个"),t("code",[e._v("Listener")]),e._v("作为参数，那么"),t("code",[e._v("Serve")]),e._v("内部做了些什么事呢？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func (srv *Server) Serve(l net.Listener) error {\n    defer l.Close()\n    ...\n\n    baseCtx := context.Background() // base is always background, per Issue 16220\n    ctx := context.WithValue(baseCtx, ServerContextKey, srv)\n    for {\n        rw, e := l.Accept()\n        ...\n        c := srv.newConn(rw)\n        c.setState(c.rwc, StateNew) // before Serve can return\n        go c.serve(ctx)\n    }\n}\n")])])]),t("p",[e._v("粗略的看，它创建了一个"),t("code",[e._v("context.Background()")]),e._v("上下文对象，并调用"),t("code",[e._v("Listener")]),e._v("的"),t("code",[e._v("Accept")]),e._v("方法开始接受外部请求，在获取到连接数据后使用"),t("code",[e._v("newConn")]),e._v("创建连接对象，在最后使用"),t("code",[e._v("goroutine")]),e._v("的方式处理连接请求，达到其目的")]),e._v(" "),t("p",[t("strong",[e._v("补充：对于"),t("code",[e._v("HTTP/2")]),e._v("支持，在调用"),t("code",[e._v("Serve")]),e._v("之前，应将"),t("code",[e._v("srv.TLSConfig")]),e._v("初始化为提供的"),t("code",[e._v("Listener")]),e._v("的TLS配置。如果"),t("code",[e._v("srv.TLSConfig")]),e._v("非零，并且在"),t("code",[e._v("Config.NextProtos")]),e._v("中不包含字符串"),t("code",[e._v("h2")]),e._v("，则不启用"),t("code",[e._v("HTTP/2")]),e._v("支持")])]),e._v(" "),t("h2",{attrs:{id:"六、验证功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、验证功能"}},[e._v("#")]),e._v(" 六、验证功能")]),e._v(" "),t("h3",{attrs:{id:"编写测试客户端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写测试客户端"}},[e._v("#")]),e._v(" 编写测试客户端")]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("grpc-hello-world/")]),e._v("下新建目录"),t("code",[e._v("client")]),e._v("，新建"),t("code",[e._v("client.go")]),e._v("文件，新增内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package main\n\nimport (\n\t"log"\n\n\t"golang.org/x/net/context"\n\t"google.golang.org/grpc"\n\t"google.golang.org/grpc/credentials"\n\n\tpb "grpc-hello-world/proto"\n)\n\nfunc main() {\n\tcreds, err := credentials.NewClientTLSFromFile("../certs/server.pem", "dev")\n\tif err != nil {\n\t\tlog.Println("Failed to create TLS credentials %v", err)\n\t}\n\tconn, err := grpc.Dial(":50052", grpc.WithTransportCredentials(creds))\n\tdefer conn.Close()\n\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tc := pb.NewHelloWorldClient(conn)\n\tcontext := context.Background()\n\tbody := &pb.HelloWorldRequest{\n\t\tReferer : "Grpc",\n\t}\n\n\tr, err := c.SayHelloWorld(context, body)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tlog.Println(r.Message)\n}\n')])])]),t("p",[e._v("由于客户端只是展示测试用，就简单的来了，原本它理应归类到"),t("code",[e._v("cobra")]),e._v("的管控下，配置管理等等都应可控化")]),e._v(" "),t("p",[e._v("在看这篇文章的你，可以试试将测试客户端归类好")]),e._v(" "),t("h3",{attrs:{id:"启动服务端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启动服务端"}},[e._v("#")]),e._v(" 启动服务端")]),e._v(" "),t("p",[e._v("回到"),t("code",[e._v("grpc-hello-world/")]),e._v("目录下，启动服务端"),t("code",[e._v("go run main.go server")]),e._v("，成功则仅返回")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("2018/02/26 17:19:36 gRPC and https listen on: 50052\n")])])]),t("h3",{attrs:{id:"执行测试客户端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行测试客户端"}},[e._v("#")]),e._v(" 执行测试客户端")]),e._v(" "),t("p",[e._v("回到"),t("code",[e._v("client")]),e._v("目录下，启动客户端"),t("code",[e._v("go run client.go")]),e._v("，成功则返回")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("2018/02/26 17:22:57 Grpc\n")])])]),t("h3",{attrs:{id:"执行测试restful-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行测试restful-api"}},[e._v("#")]),e._v(" 执行测试Restful Api")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('curl -X POST -k https://localhost:50052/hello_world -d \'{"referer": "restful_api"}\'\n')])])]),t("p",[e._v("成功则返回"),t("code",[e._v('{"message":"restful_api"}')])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"最终目录结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最终目录结构"}},[e._v("#")]),e._v(" 最终目录结构")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("grpc-hello-world\n├── certs\n│   ├── server.key\n│   └── server.pem\n├── client\n│   └── client.go\n├── cmd\n│   ├── root.go\n│   └── server.go\n├── main.go\n├── pkg\n│   └── util\n│       ├── grpc.go\n│       └── tls.go\n├── proto\n│   ├── google\n│   │   └── api\n│   │       ├── annotations.pb.go\n│   │       ├── annotations.proto\n│   │       ├── http.pb.go\n│   │       └── http.proto\n│   ├── hello.pb.go\n│   ├── hello.pb.gw.go\n│   └── hello.proto\n└── server\n    ├── hello.go\n    └── server.go\n")])])]),t("p",[e._v("至此本节就结束了，推荐一下"),t("code",[e._v("jergoo")]),e._v("的文章，大家有时间可以看看")]),e._v(" "),t("p",[e._v("另外本节涉及了许多组件间的知识，值得大家细细的回味，非常有意义！")]),e._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("h3",{attrs:{id:"示例代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示例代码"}},[e._v("#")]),e._v(" 示例代码")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/EDDYCJY/grpc-hello-world",target:"_blank",rel:"noopener noreferrer"}},[e._v("grpc-hello-world"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=o.exports}}]);