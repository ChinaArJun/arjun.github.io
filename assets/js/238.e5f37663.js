(window.webpackJsonp=window.webpackJsonp||[]).push([[238],{673:function(t,a,e){"use strict";e.r(a);var s=e(44),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_7-3-深入理解-go-map：初始化和访问元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-深入理解-go-map：初始化和访问元素"}},[t._v("#")]),t._v(" 7.3 深入理解 Go map：初始化和访问元素")]),t._v(" "),e("p",[t._v("从本文开始咱们一起探索 Go map 里面的奥妙吧，看看它的内在是怎么构成的，又分别有什么值得留意的地方？")]),t._v(" "),e("p",[t._v("第一篇将探讨"),e("strong",[t._v("初始化和访问元素")]),t._v("相关板块，咱们带着疑问去学习，例如：")]),t._v(" "),e("ul",[e("li",[t._v("初始化的时候会马上分配内存吗？")]),t._v(" "),e("li",[t._v("底层数据是如何存储的？")]),t._v(" "),e("li",[t._v("底层是如何使用 key 去寻找数据的？")]),t._v(" "),e("li",[t._v("底层是用什么方式解决哈希冲突的？")]),t._v(" "),e("li",[t._v("数据类型那么多，底层又是怎么处理的呢？")])]),t._v(" "),e("p",[t._v("...")]),t._v(" "),e("h2",{attrs:{id:"数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),e("p",[t._v("首先我们一起看看 Go map 的基础数据结构，先有一个大致的印象")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.imgur.com/EAJgaWk.png",alt:"image"}})]),t._v(" "),e("h3",{attrs:{id:"hmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hmap"}},[t._v("#")]),t._v(" hmap")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type hmap struct {\n\tcount     int \n\tflags     uint8\n\tB         uint8\n\tnoverflow uint16\n\thash0     uint32\n\tbuckets    unsafe.Pointer\n\toldbuckets unsafe.Pointer\n\tnevacuate  uintptr \n\textra *mapextra\n}\n\ntype mapextra struct {\n\toverflow    *[]*bmap\n\toldoverflow *[]*bmap\n\tnextOverflow *bmap\n}\n")])])]),e("ul",[e("li",[t._v("count：map 的大小，也就是 len() 的值。代指 map 中的键值对个数")]),t._v(" "),e("li",[t._v("flags：状态标识，主要是 goroutine 写入和扩容机制的相关状态控制。并发读写的判断条件之一就是该值")]),t._v(" "),e("li",[t._v("B：桶，最大可容纳的元素数量，值为 "),e("strong",[t._v("负载因子（默认 6.5） * 2 ^ B")]),t._v("，是 2 的指数")]),t._v(" "),e("li",[t._v("noverflow：溢出桶的数量")]),t._v(" "),e("li",[t._v("hash0：哈希因子")]),t._v(" "),e("li",[t._v("buckets：保存当前桶数据的指针地址（指向一段连续的内存地址，主要存储键值对数据）")]),t._v(" "),e("li",[t._v("oldbuckets，保存旧桶的指针地址")]),t._v(" "),e("li",[t._v("nevacuate：迁移进度")]),t._v(" "),e("li",[t._v("extra：原有 buckets 满载后，会发生扩容动作，在 Go 的机制中使用了增量扩容，如下为细项：\n"),e("ul",[e("li",[e("code",[t._v("overflow")]),t._v(" 为 "),e("code",[t._v("hmap.buckets")]),t._v(" （当前）溢出桶的指针地址")]),t._v(" "),e("li",[e("code",[t._v("oldoverflow")]),t._v(" 为 "),e("code",[t._v("hmap.oldbuckets")]),t._v(" （旧）溢出桶的指针地址")]),t._v(" "),e("li",[e("code",[t._v("nextOverflow")]),t._v(" 为空闲溢出桶的指针地址")])])])]),t._v(" "),e("p",[t._v("在这里我们要注意几点，如下：")]),t._v(" "),e("ol",[e("li",[t._v("如果 keys 和 values 都不包含指针并且允许内联的情况下。会将 bucket 标识为不包含指针，使用 extra 存储溢出桶就可以避免 GC 扫描整个 map，节省不必要的开销")]),t._v(" "),e("li",[t._v("在前面有提到，Go 用了增量扩容。而 "),e("code",[t._v("buckets")]),t._v(" 和 "),e("code",[t._v("oldbuckets")]),t._v(" 也是与扩容相关的载体，一般情况下只使用 "),e("code",[t._v("buckets")]),t._v("，"),e("code",[t._v("oldbuckets")]),t._v(" 是为空的。但如果正在扩容的话，"),e("code",[t._v("oldbuckets")]),t._v(" 便不为空，"),e("code",[t._v("buckets")]),t._v(" 的大小也会改变")]),t._v(" "),e("li",[t._v("当 "),e("code",[t._v("hint")]),t._v(" 大于 8 时，就会使用 "),e("code",[t._v("*mapextra")]),t._v(" 做溢出桶。若小于 8，则存储在 buckets 桶中")])]),t._v(" "),e("h3",{attrs:{id:"bmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bmap"}},[t._v("#")]),t._v(" bmap")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.imgur.com/zHG1CId.png",alt:"image"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("bucketCntBits = 3\nbucketCnt     = 1 << bucketCntBits\n...\ntype bmap struct {\n\ttophash [bucketCnt]uint8\n}\n")])])]),e("ul",[e("li",[t._v("tophash：key 的 hash 值高 8 位")]),t._v(" "),e("li",[t._v("keys：8 个 key")]),t._v(" "),e("li",[t._v("values：8 个 value")]),t._v(" "),e("li",[t._v("overflow：下一个溢出桶的指针地址（当 hash 冲突发生时）")])]),t._v(" "),e("p",[t._v("实际 bmap 就是 buckets 中的 bucket，一个 bucket 最多存储 8 个键值对")]),t._v(" "),e("h4",{attrs:{id:"tophash"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tophash"}},[t._v("#")]),t._v(" tophash")]),t._v(" "),e("p",[t._v("tophash 是个长度为 8 的数组，代指桶最大可容纳的键值对为 8。")]),t._v(" "),e("p",[t._v("存储每个元素 hash 值的高 8 位，如果 "),e("code",[t._v("tophash [0] <minTopHash")]),t._v("，则 "),e("code",[t._v("tophash [0]")]),t._v(" 表示为迁移进度")]),t._v(" "),e("h4",{attrs:{id:"keys-和-values"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keys-和-values"}},[t._v("#")]),t._v(" keys 和 values")]),t._v(" "),e("p",[t._v("在这里我们留意到，存储 k 和 v 的载体并不是用 "),e("code",[t._v("k/v/k/v/k/v/k/v")]),t._v(" 的模式，而是 "),e("code",[t._v("k/k/k/k/v/v/v/v")]),t._v(" 的形式去存储。这是为什么呢？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("map[int64]int8\n")])])]),e("p",[t._v("在这个例子中，如果按照 "),e("code",[t._v("k/v/k/v/k/v/k/v")]),t._v(" 的形式存放的话，虽然每个键值对的值都只占用 1 个字节。但是却需要 7 个填充字节来补齐内存空间。最终就会造成大量的内存 “浪费”")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.imgur.com/yNWBDqD.png",alt:"image"}})]),t._v(" "),e("p",[t._v("但是如果以 "),e("code",[t._v("k/k/k/k/v/v/v/v")]),t._v(' 的形式存放的话，就能够解决因对齐所 "浪费" 的内存空间')]),t._v(" "),e("p",[t._v("因此这部分的拆分主要是考虑到内存对齐的问题，虽然相对会复杂一点，但依然值得如此设计")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.imgur.com/DssSFRr.png",alt:"image"}})]),t._v(" "),e("h4",{attrs:{id:"overflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#overflow"}},[t._v("#")]),t._v(" overflow")]),t._v(" "),e("p",[t._v("可能会有同学疑惑为什么会有溢出桶这个东西？实际上在不存在哈希冲突的情况下，去掉溢出桶，也就是只需要桶、哈希因子、哈希算法。也能实现一个简单的 hash table。但是哈希冲突（碰撞）是不可避免的...")]),t._v(" "),e("p",[t._v("而在 Go map 中当 "),e("code",[t._v("hmap.buckets")]),t._v(" 满了后，就会使用溢出桶接着存储。我们结合分析可确定 Go 采用的是数组 + 链地址法解决哈希冲突")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.imgur.com/uHeHP8k.png",alt:"image"}})]),t._v(" "),e("h2",{attrs:{id:"初始化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[t._v("#")]),t._v(" 初始化")]),t._v(" "),e("h3",{attrs:{id:"用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("m := make(map[int32]int32)\n")])])]),e("h3",{attrs:{id:"函数原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数原型"}},[t._v("#")]),t._v(" 函数原型")]),t._v(" "),e("p",[t._v("通过阅读源码可得知，初始化方法有好几种。函数原型如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func makemap_small() *hmap\nfunc makemap64(t *maptype, hint int64, h *hmap) *hmap\nfunc makemap(t *maptype, hint int, h *hmap) *hmap\n")])])]),e("ul",[e("li",[t._v("makemap_small：当 "),e("code",[t._v("hint")]),t._v(" 小于 8 时，会调用 "),e("code",[t._v("makemap_small")]),t._v(" 来初始化 hmap。主要差异在于是否会马上初始化 hash table")]),t._v(" "),e("li",[t._v("makemap64：当 "),e("code",[t._v("hint")]),t._v(" 类型为 int64 时的特殊转换及校验处理，后续实质调用 "),e("code",[t._v("makemap")])]),t._v(" "),e("li",[t._v("makemap：实现了标准的 map 初始化动作")])]),t._v(" "),e("h3",{attrs:{id:"源码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码"}},[t._v("#")]),t._v(" 源码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func makemap(t *maptype, hint int, h *hmap) *hmap {\n\tif hint < 0 || hint > int(maxSliceCap(t.bucket.size)) {\n\t\thint = 0\n\t}\n\n\tif h == nil {\n\t\th = new(hmap)\n\t}\n\th.hash0 = fastrand()\n\n\tB := uint8(0)\n\tfor overLoadFactor(hint, B) {\n\t\tB++\n\t}\n\th.B = B\n\n\tif h.B != 0 {\n\t\tvar nextOverflow *bmap\n\t\th.buckets, nextOverflow = makeBucketArray(t, h.B, nil)\n\t\tif nextOverflow != nil {\n\t\t\th.extra = new(mapextra)\n\t\t\th.extra.nextOverflow = nextOverflow\n\t\t}\n\t}\n\n\treturn h\n}\n")])])]),e("ul",[e("li",[t._v("根据传入的 "),e("code",[t._v("bucket")]),t._v(" 类型，获取其类型能够申请的最大容量大小。并对其长度 "),e("code",[t._v("make(map[k]v, hint)")]),t._v(" 进行边界值检验")]),t._v(" "),e("li",[t._v("初始化 hmap")]),t._v(" "),e("li",[t._v("初始化哈希因子")]),t._v(" "),e("li",[t._v("根据传入的 "),e("code",[t._v("hint")]),t._v("，计算一个可以放下 "),e("code",[t._v("hint")]),t._v(" 个元素的桶 "),e("code",[t._v("B")]),t._v(" 的最小值")]),t._v(" "),e("li",[t._v("分配并初始化 hash table。如果 "),e("code",[t._v("B")]),t._v(" 为 0 将在后续懒惰分配桶，大于 0 则会马上进行分配")]),t._v(" "),e("li",[t._v("返回初始化完毕的 hmap")])]),t._v(" "),e("p",[t._v("在这里可以注意到，（当 "),e("code",[t._v("hint")]),t._v(" 大于等于 8 ）第一次初始化 map 时，就会通过调用 "),e("code",[t._v("makeBucketArray")]),t._v(" 对 buckets 进行分配。因此我们常常会说，在初始化时指定一个适当大小的容量。能够提升性能。")]),t._v(" "),e("p",[t._v("若该容量过少，而新增的键值对又很多。就会导致频繁的分配 buckets，进行扩容迁移等 rehash 动作。最终结果就是性能直接的下降（敲黑板）")]),t._v(" "),e("p",[t._v("而当 "),e("code",[t._v("hint")]),t._v(" 小于 8 时，这种问题"),e("strong",[t._v("相对")]),t._v("就不会凸显的太明显，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func makemap_small() *hmap {\n\th := new(hmap)\n\th.hash0 = fastrand()\n\treturn h\n}\n")])])]),e("h3",{attrs:{id:"图示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图示"}},[t._v("#")]),t._v(" 图示")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.imgur.com/Hoi01Qt.png",alt:"image"}})]),t._v(" "),e("h2",{attrs:{id:"访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#访问"}},[t._v("#")]),t._v(" 访问")]),t._v(" "),e("h3",{attrs:{id:"用法-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法-2"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("v := m[i]\nv, ok := m[i]\n")])])]),e("h3",{attrs:{id:"函数原型-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数原型-2"}},[t._v("#")]),t._v(" 函数原型")]),t._v(" "),e("p",[t._v("在实现 map 元素访问上有好几种方法，主要是包含针对 32/64 位、string 类型的特殊处理，总的函数原型如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\nmapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n\nmapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer)\n\nmapaccess1_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) unsafe.Pointer\nmapaccess2_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) (unsafe.Pointer, bool)\n\nmapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer\nmapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)\nmapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer\nmapassign_fast32ptr(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n\nmapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer\n...\n\nmapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer\n...\n")])])]),e("ul",[e("li",[t._v("mapaccess1：返回 "),e("code",[t._v("h[key]")]),t._v(" 的指针地址，如果键不在 "),e("code",[t._v("map")]),t._v(" 中，将返回对应类型的零值")]),t._v(" "),e("li",[t._v("mapaccess2：返回 "),e("code",[t._v("h[key]")]),t._v(" 的指针地址，如果键不在 "),e("code",[t._v("map")]),t._v(" 中，将返回零值和布尔值用于判断")])]),t._v(" "),e("h3",{attrs:{id:"源码-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码-2"}},[t._v("#")]),t._v(" 源码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n\t...\n\tif h == nil || h.count == 0 {\n\t\treturn unsafe.Pointer(&zeroVal[0])\n\t}\n\tif h.flags&hashWriting != 0 {\n\t\tthrow("concurrent map read and map write")\n\t}\n\talg := t.key.alg\n\thash := alg.hash(key, uintptr(h.hash0))\n\tm := bucketMask(h.B)\n\tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n\tif c := h.oldbuckets; c != nil {\n\t\tif !h.sameSizeGrow() {\n\t\t\t// There used to be half as many buckets; mask down one more power of two.\n\t\t\tm >>= 1\n\t\t}\n\t\toldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))\n\t\tif !evacuated(oldb) {\n\t\t\tb = oldb\n\t\t}\n\t}\n\ttop := tophash(hash)\n\tfor ; b != nil; b = b.overflow(t) {\n\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n\t\t\tif b.tophash[i] != top {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n\t\t\tif t.indirectkey {\n\t\t\t\tk = *((*unsafe.Pointer)(k))\n\t\t\t}\n\t\t\tif alg.equal(key, k) {\n\t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n\t\t\t\tif t.indirectvalue {\n\t\t\t\t\tv = *((*unsafe.Pointer)(v))\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}\n\t\t}\n\t}\n\treturn unsafe.Pointer(&zeroVal[0])\n}\n')])])]),e("ul",[e("li",[t._v("判断 map 是否为 nil，长度是否为 0。若是则返回零值")]),t._v(" "),e("li",[t._v("判断当前是否并发读写 map，若是则抛出异常")]),t._v(" "),e("li",[t._v("根据 key 的不同类型调用不同的 hash 方法计算得出 hash 值")]),t._v(" "),e("li",[t._v("确定 key 在哪一个 bucket 中，并得到其位置")]),t._v(" "),e("li",[t._v("判断是否正在发生扩容（h.oldbuckets 是否为 nil），若正在扩容，则到老的 buckets 中查找（因为 buckets 中可能还没有值，搬迁未完成），若该 bucket 已经搬迁完毕。则到 buckets 中继续查找")]),t._v(" "),e("li",[t._v("计算 hash 的 tophash 值（高八位）")]),t._v(" "),e("li",[t._v("根据计算出来的 tophash，依次循环对比 buckets 的 tophash 值（快速试错）")]),t._v(" "),e("li",[t._v("如果 tophash 匹配成功，则计算 key 的所在位置，正式完整的对比两个 key 是否一致")]),t._v(" "),e("li",[t._v("若查找成功并返回，若不存在，则返回零值")])]),t._v(" "),e("p",[t._v("在上述步骤三中，提到了根据不同的类型计算出 hash 值，另外会计算出 hash 值的高八位和低八位。低八位会作为 bucket index，作用是用于找到 key 所在的 bucket。而高八位会存储在 bmap tophash 中")]),t._v(" "),e("p",[t._v("其主要作用是在上述步骤七中进行迭代快速定位。这样子可以提高性能，而不是一开始就直接用 key 进行一致性对比")]),t._v(" "),e("h3",{attrs:{id:"图示-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图示-2"}},[t._v("#")]),t._v(" 图示")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.imgur.com/Y4rmolX.png",alt:"image"}})]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("在本章节，我们介绍了 map 类型的以下知识点：")]),t._v(" "),e("ul",[e("li",[t._v("map 的基础数据结构")]),t._v(" "),e("li",[t._v("初始化 map")]),t._v(" "),e("li",[t._v("访问 map")])]),t._v(" "),e("p",[t._v("从阅读源码中，得知 Go 本身"),e("strong",[t._v("对于一些不同大小、不同类型的属性，包括哈希方法都有编写特定方法")]),t._v("去运行。总的来说，这块的设计隐含较多的思路，有不少点值得细细品尝 😃")]),t._v(" "),e("p",[t._v("注：本文基于 Go 1.11.5")])])}),[],!1,null,null,null);a.default=v.exports}}]);