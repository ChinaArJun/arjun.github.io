(window.webpackJsonp=window.webpackJsonp||[]).push([[241],{676:function(t,a,n){"use strict";n.r(a);var e=n(44),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_7-1-深入理解-go-slice"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-深入理解-go-slice"}},[t._v("#")]),t._v(" 7.1 深入理解 Go Slice")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://i.imgur.com/lIoSqWC.png",alt:"image"}})]),t._v(" "),n("h2",{attrs:{id:"是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[t._v("#")]),t._v(" 是什么")]),t._v(" "),n("p",[t._v("在 Go 中，Slice（切片）是抽象在 Array（数组）之上的特殊类型。为了更好地了解 Slice，第一步需要先对 Array 进行理解。深刻了解 Slice 与 Array 之间的区别后，就能更好的对其底层一番摸索 😄")]),t._v(" "),n("h2",{attrs:{id:"用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),n("h3",{attrs:{id:"array"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#array"}},[t._v("#")]),t._v(" Array")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tnums := [3]int{}\n\tnums[0] = 1\n\n\tn := nums[0]\n\tn = 2\n\n\tfmt.Printf("nums: %v\\n", nums)\n\tfmt.Printf("n: %d\\n", n)\n}\n')])])]),n("p",[t._v("我们可得知在 Go 中，数组类型需要指定长度和元素类型。在上述代码中，可得知 "),n("code",[t._v("[3]int{}")]),t._v(" 表示 3 个整数的数组，并进行了初始化。底层数据存储为一段连续的内存空间，通过固定的索引值（下标）进行检索")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://i.imgur.com/uyO3sS6.png",alt:"image"}})]),t._v(" "),n("p",[t._v("数组在声明后，其元素的初始值（也就是零值）为 0。并且该变量可以直接使用，不需要特殊操作")]),t._v(" "),n("p",[t._v("同时数组的长度是固定的，它的长度是类型的一部分，因此 "),n("code",[t._v("[3]int")]),t._v(" 和 "),n("code",[t._v("[4]int")]),t._v(" 在类型上是不同的，不能称为 “一个东西”")]),t._v(" "),n("h4",{attrs:{id:"输出结果"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#输出结果"}},[t._v("#")]),t._v(" 输出结果")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("nums: [1 0 0] \nn: 2 \n")])])]),n("h3",{attrs:{id:"slice"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#slice"}},[t._v("#")]),t._v(" Slice")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tnums := [3]int{}\n\tnums[0] = 1\n\n\tdnums := nums[:]\n\n\tfmt.Printf("dnums: %v", dnums)\n}\n')])])]),n("p",[t._v("Slice 是对 Array 的抽象，类型为 "),n("code",[t._v("[]T")]),t._v("。在上述代码中，"),n("code",[t._v("dnums")]),t._v(" 变量通过 "),n("code",[t._v("nums[:]")]),t._v(" 进行赋值。需要注意的是，Slice 和 Array 不一样，它不需要指定长度。也更加的灵活，能够自动扩容")]),t._v(" "),n("h2",{attrs:{id:"数据结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://i.imgur.com/hRRFLOl.png",alt:"image"}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("type slice struct {\n\tarray unsafe.Pointer\n\tlen   int\n\tcap   int\n}\n")])])]),n("p",[t._v("Slice 的底层数据结构共分为三部分，如下：")]),t._v(" "),n("ul",[n("li",[t._v("array：指向所引用的数组指针（"),n("code",[t._v("unsafe.Pointer")]),t._v(" 可以表示任何可寻址的值的指针）")]),t._v(" "),n("li",[t._v("len：长度，当前引用切片的元素个数")]),t._v(" "),n("li",[t._v("cap：容量，当前引用切片的容量（底层数组的元素总数）")])]),t._v(" "),n("p",[t._v("在实际使用中，cap 一定是大于或等于 len 的。否则会导致 panic")]),t._v(" "),n("h3",{attrs:{id:"示例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),n("p",[t._v("为了更好的理解，我们回顾上小节的代码便于演示，如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tnums := [3]int{}\n\tnums[0] = 1\n\n\tdnums := nums[:]\n\n\tfmt.Printf("dnums: %v", dnums)\n}\n')])])]),n("p",[n("img",{attrs:{src:"https://i.imgur.com/fL1l0Zu.png",alt:"image"}})]),t._v(" "),n("p",[t._v("在代码中，可观察到 "),n("code",[t._v("dnums := nums[:]")]),t._v("，这段代码确定了 Slice 的 Pointer 指向数组，且 len 和 cap 都为数组的基础属性。与图示表达一致")]),t._v(" "),n("h3",{attrs:{id:"len、cap-不同"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#len、cap-不同"}},[t._v("#")]),t._v(" len、cap 不同")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tnums := [3]int{}\n\tnums[0] = 1\n\n\tdnums := nums[0:2]\n\n\tfmt.Printf("dnums: %v, len: %d, cap: %d", dnums, len(dnums), cap(dnums))\n}\n')])])]),n("p",[n("img",{attrs:{src:"https://i.imgur.com/Xkf5tvZ.png",alt:"image"}})]),t._v(" "),n("h4",{attrs:{id:"输出结果-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#输出结果-2"}},[t._v("#")]),t._v(" 输出结果")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("dnums: [1 0], len: 2, cap: 3\n")])])]),n("p",[t._v("显然，在这里指定了 "),n("code",[t._v("Slice[0:2]")]),t._v("，因此 len 为所引用元素的个数，cap 为所引用的数组元素总个数。与期待一致 😄")]),t._v(" "),n("h2",{attrs:{id:"创建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建"}},[t._v("#")]),t._v(" 创建")]),t._v(" "),n("p",[t._v("Slice 的创建有两种方式，如下：")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("var []T")]),t._v(" 或 "),n("code",[t._v("[]T{}")])]),t._v(" "),n("li",[n("code",[t._v("func make（[] T，len，cap）[] T")])])]),t._v(" "),n("p",[t._v("可以留意 make 函数，我们都知道 Slice 需要指向一个 Array。那 make 是怎么做的呢？")]),t._v(" "),n("p",[t._v("它会在调用 make 的时候，分配一个数组并返回引用该数组的 Slice")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func makeslice(et *_type, len, cap int) slice {\n\tmaxElements := maxSliceCap(et.size)\n\tif len < 0 || uintptr(len) > maxElements {\n\t\tpanic(errorString("makeslice: len out of range"))\n\t}\n\n\tif cap < len || uintptr(cap) > maxElements {\n\t\tpanic(errorString("makeslice: cap out of range"))\n\t}\n\n\tp := mallocgc(et.size*uintptr(cap), et, true)\n\treturn slice{p, len, cap}\n}\n')])])]),n("ul",[n("li",[t._v("根据传入的 Slice 类型，获取其类型能够申请的最大容量大小")]),t._v(" "),n("li",[t._v("判断 len 是否合规，检查是否在 0 < x < maxElements 范围内")]),t._v(" "),n("li",[t._v("判断 cap 是否合规，检查是否在 len < x < maxElements 范围内")]),t._v(" "),n("li",[t._v("申请 Slice 所需的内存空间对象。若为大型对象（大于 32 KB）则直接从堆中分配")]),t._v(" "),n("li",[t._v("返回申请成功的 Slice 内存地址和相关属性（默认返回申请到的内存起始地址）")])]),t._v(" "),n("h2",{attrs:{id:"扩容"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩容"}},[t._v("#")]),t._v(" 扩容")]),t._v(" "),n("p",[t._v("当使用 Slice 时，若存储的元素不断增长（例如通过 append）。当条件满足扩容的策略时，将会触发自动扩容")]),t._v(" "),n("p",[t._v("那么分别是什么规则呢？让我们一起看看源码是怎么说的 😄")]),t._v(" "),n("h3",{attrs:{id:"zerobase"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#zerobase"}},[t._v("#")]),t._v(" zerobase")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func growslice(et *_type, old slice, cap int) slice {\n\t...\n\tif et.size == 0 {\n\t\tif cap < old.cap {\n\t\t\tpanic(errorString("growslice: cap out of range"))\n\t\t}\n\t\t\n\t\treturn slice{unsafe.Pointer(&zerobase), old.len, cap}\n\t}\n    ...\n}\n')])])]),n("p",[t._v("当 Slice size 为 0 时，若将要扩容的容量比原本的容量小，则抛出异常（也就是不支持缩容操作）。否则，将重新生成一个新的 Slice 返回，其 Pointer 指向一个 0 byte 地址（不会保留老的 Array 指向）")]),t._v(" "),n("h3",{attrs:{id:"扩容-计算策略"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩容-计算策略"}},[t._v("#")]),t._v(" 扩容 - 计算策略")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func growslice(et *_type, old slice, cap int) slice {\n    ...\n    newcap := old.cap\n\tdoublecap := newcap + newcap\n\tif cap > doublecap {\n\t\tnewcap = cap\n\t} else {\n\t\tif old.len < 1024 {\n\t\t\tnewcap = doublecap\n\t\t} else {\n\t\t\tfor 0 < newcap && newcap < cap {\n\t\t\t\tnewcap += newcap / 4\n\t\t\t}\n\t\t\t...\n\t\t}\n\t}\n\t...\n}\n")])])]),n("ul",[n("li",[t._v("若 Slice cap 大于 doublecap，则扩容后容量大小为 新 Slice 的容量（超了基准值，我就只给你需要的容量大小）")]),t._v(" "),n("li",[t._v("若 Slice len 小于 1024 个，在扩容时，增长因子为 1（也就是 3 个变 6 个）")]),t._v(" "),n("li",[t._v("若 Slice len 大于 1024 个，在扩容时，增长因子为 0.25（原本容量的四分之一）")])]),t._v(" "),n("p",[t._v("注：也就是小于 1024 个时，增长 2 倍。大于 1024 个时，增长 1.25 倍")]),t._v(" "),n("h3",{attrs:{id:"扩容-内存策略"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩容-内存策略"}},[t._v("#")]),t._v(" 扩容 - 内存策略")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func growslice(et *_type, old slice, cap int) slice {\n    ...\n    var overflow bool\n\tvar lenmem, newlenmem, capmem uintptr\n\tconst ptrSize = unsafe.Sizeof((*byte)(nil))\n\tswitch et.size {\n\tcase 1:\n\t\tlenmem = uintptr(old.len)\n\t\tnewlenmem = uintptr(cap)\n\t\tcapmem = roundupsize(uintptr(newcap))\n\t\toverflow = uintptr(newcap) > _MaxMem\n\t\tnewcap = int(capmem)\n\t    ...\n\t}\n\n\tif cap < old.cap || overflow || capmem > _MaxMem {\n\t\tpanic(errorString("growslice: cap out of range"))\n\t}\n\n\tvar p unsafe.Pointer\n\tif et.kind&kindNoPointers != 0 {\n\t\tp = mallocgc(capmem, nil, false)\n\t\tmemmove(p, old.array, lenmem)\n\t\tmemclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)\n\t} else {\n\t\tp = mallocgc(capmem, et, true)\n\t\tif !writeBarrier.enabled {\n\t\t\tmemmove(p, old.array, lenmem)\n\t\t} else {\n\t\t\tfor i := uintptr(0); i < lenmem; i += et.size {\n\t\t\t\ttypedmemmove(et, add(p, i), add(old.array, i))\n\t\t\t}\n\t\t}\n\t}\n\t...\n}\n')])])]),n("p",[t._v("1、获取老 Slice 长度和计算假定扩容后的新 Slice 元素长度、容量大小以及指针地址（用于后续操作内存的一系列操作）")]),t._v(" "),n("p",[t._v("2、确定新 Slice 容量大于老 Sice，并且新容量内存小于指定的最大内存、没有溢出。否则抛出异常")]),t._v(" "),n("p",[t._v("3、若元素类型为 "),n("code",[t._v("kindNoPointers")]),t._v("，也就是"),n("strong",[t._v("非指针")]),t._v("类型。则在老 Slice 后继续扩容")]),t._v(" "),n("ul",[n("li",[t._v("第一步：根据先前计算的 "),n("code",[t._v("capmem")]),t._v("，在老 Slice cap 后继续申请内存空间，其后用于扩容")]),t._v(" "),n("li",[t._v("第二步：将 old.array 上的 n 个 bytes（根据 lenmem）拷贝到新的内存空间上")]),t._v(" "),n("li",[t._v("第三步：新内存空间（p）加上新 Slice cap 的容量地址。最终得到完整的新 Slice cap 内存地址 "),n("code",[t._v("add(p, newlenmem)")]),t._v(" （ptr）")]),t._v(" "),n("li",[t._v("第四步：从 ptr 开始重新初始化 n 个 bytes（capmem-newlenmem）")])]),t._v(" "),n("p",[t._v("注：那么问题来了，为什么要重新初始化这块内存呢？这是因为 ptr 是未初始化的内存（例如：可重用的内存，一般用于新的内存分配），其可能包含 “垃圾”。因此在这里应当进行 “清理”。便于后面实际使用（扩容）")]),t._v(" "),n("p",[t._v("4、不满足 3 的情况下，重新申请并初始化一块内存给新 Slice 用于存储 Array")]),t._v(" "),n("p",[t._v("5、检测当前是否正在执行 GC，也就是当前是否启用 Write Barrier（写屏障），若"),n("strong",[t._v("启用")]),t._v("则通过 "),n("code",[t._v("typedmemmove")]),t._v(" 方法，利用指针运算"),n("strong",[t._v("循环拷贝")]),t._v("。否则通过 "),n("code",[t._v("memmove")]),t._v(" 方法采取"),n("strong",[t._v("整体拷贝")]),t._v("的方式将 lenmem 个字节从 old.array 拷贝到 ptr，以此达到更高的效率")]),t._v(" "),n("p",[t._v("注：一般会在 GC 标记阶段启用 Write Barrier，并且 Write Barrier 只针对指针启用。那么在第 5 点中，你就不难理解为什么会有两种截然不同的处理方式了")]),t._v(" "),n("h4",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("p",[t._v("这里需要注意的是，扩容时的内存管理的选择项，如下：")]),t._v(" "),n("ul",[n("li",[t._v("翻新扩展：当前元素为 "),n("code",[t._v("kindNoPointers")]),t._v("，将在老 Slice cap 的地址后继续申请空间用于扩容")]),t._v(" "),n("li",[t._v("举家搬迁：重新申请一块内存地址，整体迁移并扩容")])]),t._v(" "),n("h3",{attrs:{id:"两个小-陷阱"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#两个小-陷阱"}},[t._v("#")]),t._v(" 两个小 “陷阱”")]),t._v(" "),n("h4",{attrs:{id:"一、同根"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、同根"}},[t._v("#")]),t._v(" 一、同根")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tnums := [3]int{}\n\tnums[0] = 1\n\n\tfmt.Printf("nums: %v , len: %d, cap: %d\\n", nums, len(nums), cap(nums))\n\n\tdnums := nums[0:2]\n\tdnums[0] = 5\n\n\tfmt.Printf("nums: %v ,len: %d, cap: %d\\n", nums, len(nums), cap(nums))\n\tfmt.Printf("dnums: %v, len: %d, cap: %d\\n", dnums, len(dnums), cap(dnums))\n}\n')])])]),n("p",[t._v("输出结果：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("nums: [1 0 0] , len: 3, cap: 3\nnums: [5 0 0] ,len: 3, cap: 3\ndnums: [5 0], len: 2, cap: 3\n")])])]),n("p",[t._v("在"),n("strong",[t._v("未扩容前")]),t._v("，Slice array 指向所引用的 Array。因此在 Slice 上的变更。会直接修改到原始 Array 上（两者所引用的是同一个）")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://i.imgur.com/wCny9zI.png",alt:"image"}})]),t._v(" "),n("h4",{attrs:{id:"二、时过境迁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、时过境迁"}},[t._v("#")]),t._v(" 二、时过境迁")]),t._v(" "),n("p",[t._v("随着 Slice 不断 append，内在的元素越来越多，终于触发了扩容。如下代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tnums := [3]int{}\n\tnums[0] = 1\n\n\tfmt.Printf("nums: %v , len: %d, cap: %d\\n", nums, len(nums), cap(nums))\n\n\tdnums := nums[0:2]\n\tdnums = append(dnums, []int{2, 3}...)\n\tdnums[1] = 1\n\n\tfmt.Printf("nums: %v ,len: %d, cap: %d\\n", nums, len(nums), cap(nums))\n\tfmt.Printf("dnums: %v, len: %d, cap: %d\\n", dnums, len(dnums), cap(dnums))\n}\n')])])]),n("p",[t._v("输出结果：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("nums: [1 0 0] , len: 3, cap: 3\nnums: [1 0 0] ,len: 3, cap: 3\ndnums: [1 1 2 3], len: 4, cap: 6\n")])])]),n("p",[t._v("往 Slice append 元素时，若满足扩容策略，也就是假设插入后，原本数组的容量就超过最大值了")]),t._v(" "),n("p",[t._v("这时候内部就会重新申请一块内存空间，将原本的元素"),n("strong",[t._v("拷贝")]),t._v("一份到新的内存空间上。此时其与原本的数组就没有任何关联关系了，"),n("strong",[t._v("再进行修改值也不会变动到原始数组")]),t._v("。这是需要注意的")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://i.imgur.com/A3kR8nX.png",alt:"image"}})]),t._v(" "),n("h2",{attrs:{id:"复制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#复制"}},[t._v("#")]),t._v(" 复制")]),t._v(" "),n("h3",{attrs:{id:"原型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func copy（dst，src [] T）int\n")])])]),n("p",[t._v("copy 函数将数据从"),n("strong",[t._v("源 Slice")]),t._v("复制到"),n("strong",[t._v("目标 Slice")]),t._v("。它返回复制的元素数。")]),t._v(" "),n("h3",{attrs:{id:"示例-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#示例-2"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tdst := []int{1, 2, 3}\n\tsrc := []int{4, 5, 6, 7, 8}\n\tn := copy(dst, src)\n\n\tfmt.Printf("dst: %v, n: %d", dst, n)\n}\n')])])]),n("p",[t._v("copy 函数支持在不同长度的 Slice 之间进行复制，若出现长度不一致，在复制时会按照最少的 Slice 元素个数进行复制")]),t._v(" "),n("p",[t._v("那么在源码中是如何完成复制这一个行为的呢？我们来一起看看源码的实现，如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func slicecopy(to, fm slice, width uintptr) int {\n\tif fm.len == 0 || to.len == 0 {\n\t\treturn 0\n\t}\n\n\tn := fm.len\n\tif to.len < n {\n\t\tn = to.len\n\t}\n\n\tif width == 0 {\n\t\treturn n\n\t}\n\n\t...\n\n\tsize := uintptr(n) * width\n\tif size == 1 {\n\t\t*(*byte)(to.array) = *(*byte)(fm.array) // known to be a byte pointer\n\t} else {\n\t\tmemmove(to.array, fm.array, size)\n\t}\n\treturn n\n}\n")])])]),n("ul",[n("li",[t._v("若源 Slice 或目标 Slice 存在长度为 0 的情况，则直接返回 0（因为压根不需要执行复制行为）")]),t._v(" "),n("li",[t._v("通过对比两个 Slice，获取最小的 Slice 长度。便于后续操作")]),t._v(" "),n("li",[t._v("若 Slice 只有一个元素，则直接利用指针的特性进行转换")]),t._v(" "),n("li",[t._v("若 Slice 大于一个元素，则从 "),n("code",[t._v("fm.array")]),t._v(" 复制 "),n("code",[t._v("size")]),t._v(" 个字节到 "),n("code",[t._v("to.array")]),t._v(" 的地址处（会覆盖原有的值）")])]),t._v(" "),n("h2",{attrs:{id:"奇特-的初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#奇特-的初始化"}},[t._v("#")]),t._v(' "奇特"的初始化')]),t._v(" "),n("p",[t._v("在 Slice 中流传着两个传说，分别是 Empty 和 Nil Slice，接下来让我们看看它们的小区别 🤓")]),t._v(" "),n("h3",{attrs:{id:"empty"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#empty"}},[t._v("#")]),t._v(" Empty")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tnums := []int{}\n\trenums := make([]int, 0)\n\t\n\tfmt.Printf("nums: %v, len: %d, cap: %d\\n", nums, len(nums), cap(nums))\n\tfmt.Printf("renums: %v, len: %d, cap: %d\\n", renums, len(renums), cap(renums))\n}\n')])])]),n("p",[t._v("输出结果：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("nums: [], len: 0, cap: 0\nrenums: [], len: 0, cap: 0\n")])])]),n("h3",{attrs:{id:"nil"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nil"}},[t._v("#")]),t._v(" Nil")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func main() {\n    var nums []int\n}\n")])])]),n("p",[t._v("输出结果：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("nums: [], len: 0, cap: 0\n")])])]),n("h3",{attrs:{id:"想一想"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#想一想"}},[t._v("#")]),t._v(" 想一想")]),t._v(" "),n("p",[t._v("乍一看，Empty Slice 和 Nil Slice 好像一模一样？不管是 len，还是 cap 都为 0。好像没区别？我们再看看如下代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tvar nums []int\n\trenums := make([]int, 0)\n\tif nums == nil {\n\t\tfmt.Println("nums is nil.")\n\t}\n\tif renums == nil {\n\t\tfmt.Println("renums is nil.")\n\t}\n}\n')])])]),n("p",[t._v("你觉得输出结果是什么呢？你可能已经想到了，最终的输出结果：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("nums is nil.\n")])])]),n("h4",{attrs:{id:"为什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么"}},[t._v("#")]),t._v(" 为什么")]),t._v(" "),n("h5",{attrs:{id:"empty-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#empty-2"}},[t._v("#")]),t._v(" Empty")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://i.imgur.com/2DFo7H0.png",alt:"image"}})]),t._v(" "),n("h5",{attrs:{id:"nil-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nil-2"}},[t._v("#")]),t._v(" Nil")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://i.imgur.com/WClJnJZ.png",alt:"image"}})]),t._v(" "),n("p",[t._v("从图示中可以看出来，两者有本质上的区别。其底层数组的指向指针是不一样的，Nil Slice 指向的是 nil，Empty Slice 指向的是实际存在的空数组地址")]),t._v(" "),n("p",[t._v("你可以认为，Nil Slice 代指不存在的 Slice，Empty Slice 代指空集合。两者所代表的意义是完全不同的")]),t._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[t._v("通过本文，可得知 Go Slice 相当灵活。不需要你手动扩容，也不需要你关注加多少减多少。对 Array 是动态引用，是 Go 类型的一个极大的补充，也因此在应用中使用的更多、更便捷")]),t._v(" "),n("p",[t._v("虽然有个别要注意的 “坑”，但其实是合理的。你觉得呢？😄")])])}),[],!1,null,null,null);a.default=s.exports}}]);