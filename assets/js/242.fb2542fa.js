(window.webpackJsonp=window.webpackJsonp||[]).push([[242],{694:function(t,a,e){"use strict";e.r(a);var l=e(44),s=Object(l.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_7-2-go-slice-最大容量大小是怎么来的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-go-slice-最大容量大小是怎么来的"}},[t._v("#")]),t._v(" 7.2 Go Slice 最大容量大小是怎么来的")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.imgur.com/bQQRTTY.png",alt:"image"}})]),t._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("在《深入理解 Go Slice》中，我们提到了 “根据其类型大小去获取能够申请的最大容量大小” 的处理逻辑。今天我们将更深入地去探究一下，底层到底做了什么东西，涉及什么知识点？")]),t._v(" "),e("p",[t._v("Go Slice 对应代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func makeslice(et *_type, len, cap int) slice {\n\tmaxElements := maxSliceCap(et.size)\n\tif len < 0 || uintptr(len) > maxElements {\n\t\t...\n\t}\n\n\tif cap < len || uintptr(cap) > maxElements {\n\t\t...\n\t}\n\n\tp := mallocgc(et.size*uintptr(cap), et, true)\n\treturn slice{p, len, cap}\n}\n")])])]),e("p",[t._v("根据想要追寻的逻辑，定位到了 "),e("code",[t._v("maxSliceCap")]),t._v(" 方法，它会根据"),e("strong",[t._v("当前类型的大小获取到了所允许的最大容量大小")]),t._v("来进行阈值判断，也就是安全检查。这是浅层的了解，我们继续追下去看看还做了些什么？")]),t._v(" "),e("h2",{attrs:{id:"maxslicecap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#maxslicecap"}},[t._v("#")]),t._v(" maxSliceCap")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func maxSliceCap(elemsize uintptr) uintptr {\n\tif elemsize < uintptr(len(maxElems)) {\n\t\treturn maxElems[elemsize]\n\t}\n\treturn maxAlloc / elemsize\n}\n")])])]),e("h2",{attrs:{id:"maxelems"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#maxelems"}},[t._v("#")]),t._v(" maxElems")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var maxElems = [...]uintptr{\n\t^uintptr(0),\n\tmaxAlloc / 1, maxAlloc / 2, maxAlloc / 3, maxAlloc / 4,\n\tmaxAlloc / 5, maxAlloc / 6, maxAlloc / 7, maxAlloc / 8,\n\tmaxAlloc / 9, maxAlloc / 10, maxAlloc / 11, maxAlloc / 12,\n\tmaxAlloc / 13, maxAlloc / 14, maxAlloc / 15, maxAlloc / 16,\n\tmaxAlloc / 17, maxAlloc / 18, maxAlloc / 19, maxAlloc / 20,\n\tmaxAlloc / 21, maxAlloc / 22, maxAlloc / 23, maxAlloc / 24,\n\tmaxAlloc / 25, maxAlloc / 26, maxAlloc / 27, maxAlloc / 28,\n\tmaxAlloc / 29, maxAlloc / 30, maxAlloc / 31, maxAlloc / 32,\n}\n")])])]),e("p",[e("code",[t._v("maxElems")]),t._v(" 是包含一些预定义的切片最大容量值的查找表，索引是切片元素的类型大小。而值看起来 “奇奇怪怪” 不大眼熟，都是些什么呢。主要是以下三个核心点：")]),t._v(" "),e("ul",[e("li",[t._v("^uintptr(0)")]),t._v(" "),e("li",[t._v("maxAlloc")]),t._v(" "),e("li",[t._v("maxAlloc / typeSize")])]),t._v(" "),e("h3",{attrs:{id:"uintptr-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uintptr-0"}},[t._v("#")]),t._v(" ^uintptr(0)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func main() {\n\tlog.Printf("uintptr: %v\\n", uintptr(0))\n\tlog.Printf("^uintptr: %v\\n", ^uintptr(0))\n}\n')])])]),e("p",[t._v("输出结果：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("2019/01/05 17:51:52 uintptr: 0\n2019/01/05 17:51:52 ^uintptr: 18446744073709551615\n")])])]),e("p",[t._v("我们留意一下输出结果，比较神奇。取反之后为什么是 18446744073709551615 呢？")]),t._v(" "),e("h3",{attrs:{id:"uintptr-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uintptr-是什么"}},[t._v("#")]),t._v(" uintptr 是什么")]),t._v(" "),e("p",[t._v("在分析之前，我们要知道 uintptr 的本质（真面目），也就是它的类型是什么，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type uintptr uintptr\n")])])]),e("p",[t._v("uintptr 的类型是自定义类型，接着找它的真面目，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("#ifdef _64BIT\ntypedef\tuint64\t\tuintptr;\n#else\ntypedef\tuint32\t\tuintptr;\n#endif\n")])])]),e("p",[t._v("通过对以上代码的分析，可得出以下结论：")]),t._v(" "),e("ul",[e("li",[t._v("在 32 位系统下，uintptr 为 uint32 类型，占用大小为 4 个字节")]),t._v(" "),e("li",[t._v("在 64 位系统下，uintptr 为 uint64 类型，占用大小为 8 个字节")])]),t._v(" "),e("h3",{attrs:{id:"uintptr-做了什么事"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uintptr-做了什么事"}},[t._v("#")]),t._v(" ^uintptr 做了什么事")]),t._v(" "),e("p",[t._v("^ 位运算符的作用是"),e("strong",[t._v("按位异或")]),t._v("，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func main() {\n\tlog.Println(^1)\n\tlog.Println(^uint64(0))\n}\n")])])]),e("p",[t._v("输出结果：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("2019/01/05 20:44:49 -2\n2019/01/05 20:44:49 18446744073709551615\n")])])]),e("p",[t._v("接下来我们分析一下，这两段代码都做了什么事情呢")]),t._v(" "),e("h4",{attrs:{id:"_1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1"}},[t._v("#")]),t._v(" ^1")]),t._v(" "),e("p",[t._v("二进制：0001")]),t._v(" "),e("p",[t._v("按位取反：1110")]),t._v(" "),e("p",[t._v("该数为有符号整数，最高位为符号位。低三位为表示数值。按位取反后为 1110，根据先前的说明，最高位为 1，因此表示为 -。取反后 110 对应十进制 -2")]),t._v(" "),e("h4",{attrs:{id:"uint64-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uint64-0"}},[t._v("#")]),t._v(" ^uint64(0)")]),t._v(" "),e("p",[t._v("二进制：0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000")]),t._v(" "),e("p",[t._v("按位取反：1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111")]),t._v(" "),e("p",[t._v("该数为无符号整数，该位取反后得到十进制值为：18446744073709551615")]),t._v(" "),e("p",[t._v("这个值是不是看起来很眼熟呢？没错，就是 "),e("code",[t._v("^uintptr(0)")]),t._v(" 的值。也印证了其底层数据类型为 uint64 的事实 （本机为 64 位）。同时它又代表如下：")]),t._v(" "),e("ul",[e("li",[t._v("math.MaxUint64")]),t._v(" "),e("li",[t._v("2 的 64 次方减 1")])]),t._v(" "),e("h3",{attrs:{id:"maxalloc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#maxalloc"}},[t._v("#")]),t._v(" maxAlloc")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const GoarchMips = 0\nconst GoarchMipsle = 0\nconst GoarchWasm = 0\n\n...\n\n_64bit = 1 << (^uintptr(0) >> 63) / 2\n\nheapAddrBits = (_64bit*(1-sys.GoarchWasm))*48 + (1-_64bit+sys.GoarchWasm)*(32-(sys.GoarchMips+sys.GoarchMipsle))\n\nmaxAlloc = (1 << heapAddrBits) - (1-_64bit)*1\n")])])]),e("p",[e("code",[t._v("maxAlloc")]),t._v(" 是"),e("strong",[t._v("允许用户分配的最大虚拟内存空间")]),t._v("。在 64 位，理论上可分配最大 "),e("code",[t._v("1 << heapAddrBits")]),t._v(" 字节。在 32 位，最大可分配小于 "),e("code",[t._v("1 << 32")]),t._v(" 字节")]),t._v(" "),e("p",[t._v("在本文，仅需了解它承载的是什么就好了。具体的在以后内存管理的文章再讲述")]),t._v(" "),e("p",[t._v("注：该变量在 go 10.1 为 "),e("code",[t._v("_MaxMem")]),t._v("，go 11.4 已改为 "),e("code",[t._v("maxAlloc")]),t._v("。相关的 "),e("code",[t._v("heapAddrBits")]),t._v(" 计算方式也有所改变")]),t._v(" "),e("h3",{attrs:{id:"maxalloc-typesize"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#maxalloc-typesize"}},[t._v("#")]),t._v(" maxAlloc / typeSize")]),t._v(" "),e("p",[t._v("我们再次回顾 "),e("code",[t._v("maxSliceCap")]),t._v(" 的逻辑代码，这次重点放在控制逻辑，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// func makeslice\nmaxElements := maxSliceCap(et.size)\n\n...\n\n// func maxSliceCap\nif elemsize < uintptr(len(maxElems)) {\n\treturn maxElems[elemsize]\n}\nreturn maxAlloc / elemsize\n")])])]),e("p",[t._v("通过这段代码和 Slice 上下文逻辑，可得知在想得到该类型的最大容量大小时。会根据对应的类型大小去查找表查找索引（索引为类型大小，摆放顺序是有考虑原因的）。“迫不得已的情况下” 才会手动的计算它的值，最终计算得到的内存字节大小都为该类型大小的整数倍")]),t._v(" "),e("p",[t._v("查找表的设置，更像是一个优化逻辑。减少常用的计算开销 😃")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("通过本文的分析，可得出 Slice 所允许申请的最大容量大小，与当前"),e("strong",[t._v("值类型")]),t._v("和当前"),e("strong",[t._v("平台位数")]),t._v("有直接关系")]),t._v(" "),e("h2",{attrs:{id:"最后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[t._v("#")]),t._v(" 最后")]),t._v(" "),e("p",[t._v("本文与"),e("a",{attrs:{href:"https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2018-12-15-%E6%9C%89%E7%82%B9%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8D%B4%E5%8F%88%E4%B8%80%E4%BA%AE%E7%9A%84Go-unsafe-Pointer.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("《有点不安全却又一亮的 Go unsafe.Pointer》"),e("OutboundLink")],1),t._v("一同属于"),e("a",{attrs:{href:"https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2018-12-11-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-Slice.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("《深入理解 Go Slice》"),e("OutboundLink")],1),t._v("的关联章节。如果你在阅读源码时，对这些片段有疑惑。记得想尽办法深究下去，搞懂它")]),t._v(" "),e("p",[t._v("短短的一句话其实蕴含着不少知识点，希望这篇文章恰恰好可以帮你解惑")]),t._v(" "),e("p",[t._v("注：本文 Go 代码基于版本 11.4")])])}),[],!1,null,null,null);a.default=s.exports}}]);