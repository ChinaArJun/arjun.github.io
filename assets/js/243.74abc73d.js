(window.webpackJsonp=window.webpackJsonp||[]).push([[243],{678:function(t,r,e){"use strict";e.r(r);var n=e(44),a=Object(n.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_8-1-fmt-标准库-print-是怎么样输出的？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-fmt-标准库-print-是怎么样输出的？"}},[t._v("#")]),t._v(" 8.1 fmt 标准库 --- Print* 是怎么样输出的？")]),t._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package main\n\nimport (\n\t"fmt"\n)\n\nfunc main() {\n\tfmt.Println("Hello World!")\n}\n')])])]),e("p",[t._v("标准开场见多了，那内部标准库又是怎么输出这段英文的呢？今天一起来围观下源码吧 🤭")]),t._v(" "),e("h2",{attrs:{id:"原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func Print(a ...interface{}) (n int, err error) {\n\treturn Fprint(os.Stdout, a...)\n}\n\nfunc Println(a ...interface{}) (n int, err error) {\n\treturn Fprintln(os.Stdout, a...)\n}\n\nfunc Printf(format string, a ...interface{}) (n int, err error) {\n\treturn Fprintf(os.Stdout, format, a...)\n}\n")])])]),e("ul",[e("li",[t._v("Print：使用默认格式说明符打印格式并写入标准输出。当两者都不是字符串时，在操作数之间添加空格")]),t._v(" "),e("li",[t._v("Println：同上，不同的地方是始终在操作数之间添加空格，并附加换行符")]),t._v(" "),e("li",[t._v("Printf：根据格式说明符进行格式化并写入标准输出")])]),t._v(" "),e("p",[t._v("以上三类就是最常见的格式化 I/O 的方法，我们将基于此去进行拆解描述")]),t._v(" "),e("h2",{attrs:{id:"执行流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行流程"}},[t._v("#")]),t._v(" 执行流程")]),t._v(" "),e("h3",{attrs:{id:"案例一：print"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例一：print"}},[t._v("#")]),t._v(" 案例一：Print")]),t._v(" "),e("p",[t._v("在这里我们使用 "),e("code",[t._v("Print")]),t._v(" 方法做一个分析，便于后面的加深理解 😄")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func Print(a ...interface{}) (n int, err error) {\n\treturn Fprint(os.Stdout, a...)\n}\n")])])]),e("p",[e("code",[t._v("Print")]),t._v(" 使用默认格式说明符打印格式并写入标准输出。另外当两者都为非空字符串时将插入一个空格")]),t._v(" "),e("h4",{attrs:{id:"原型-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型-2"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func Fprint(w io.Writer, a ...interface{}) (n int, err error) {\n\tp := newPrinter()\n\tp.doPrint(a)\n\tn, err = w.Write(p.buf)\n\tp.free()\n\treturn\n}\n")])])]),e("p",[t._v("该函数一共有两个形参：")]),t._v(" "),e("ul",[e("li",[t._v("w：输出流，只要实现 io.Writer 就可以（抽象）为流的写入")]),t._v(" "),e("li",[t._v("a：任意类型的多个值")])]),t._v(" "),e("h4",{attrs:{id:"分析主干流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析主干流程"}},[t._v("#")]),t._v(" 分析主干流程")]),t._v(" "),e("p",[t._v("1、 p := newPrinter(): 申请一个临时对象池（sync.Pool）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var ppFree = sync.Pool{\n\tNew: func() interface{} { return new(pp) },\n}\n\nfunc newPrinter() *pp {\n\tp := ppFree.Get().(*pp)\n\tp.panicking = false\n\tp.erroring = false\n\tp.fmt.init(&p.buf)\n\treturn p\n}\n")])])]),e("ul",[e("li",[t._v("ppFree.Get()：基于 sync.Pool 实现 *pp 的临时对象池，每次获取一定会返回一个新的 pp 对象用于接下来的处理")]),t._v(" "),e("li",[t._v("*pp.panicking：用于解决无限递归的 panic、recover 问题，会根据该参数在 catchPanic 及时掐断")]),t._v(" "),e("li",[t._v("*pp.erroring：用于表示正在处理错误无效的 verb 标识符，主要作用是防止调用 handleMethods 方法")]),t._v(" "),e("li",[t._v("*pp.fmt.init(&p.buf)：初始化 fmt 配置，会设置 buf 并且清空 fmtFlags 标志位")])]),t._v(" "),e("p",[t._v("2、 p.doPrint(a): 执行约定的格式化动作（参数间增加一个空格、最后一个参数增加换行符）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func (p *pp) doPrint(a []interface{}) {\n\tprevString := false\n\tfor argNum, arg := range a {\n\t    true && false\n\t\tisString := arg != nil && reflect.TypeOf(arg).Kind() == reflect.String\n\t\t// Add a space between two non-string arguments.\n\t\tif argNum > 0 && !isString && !prevString {\n\t\t\tp.buf.WriteByte(' ')\n\t\t}\n\t\tp.printArg(arg, 'v')\n\t\tprevString = isString\n\t}\n}\n")])])]),e("p",[t._v("可以看到底层通过判断该入参，"),e("strong",[t._v("同时")]),t._v("满足以下条件就会添加分隔符（空格）：")]),t._v(" "),e("ul",[e("li",[t._v("当前入参为多个参数（例如：Slice）")]),t._v(" "),e("li",[t._v("当前入参不为 nil 且不为字符串（通过反射确定）")]),t._v(" "),e("li",[t._v("当前入参不为首项或上一个入参不为字符串")])]),t._v(" "),e("p",[t._v("而在 "),e("code",[t._v("Print")]),t._v(" 方法中，不需要指定格式符。实际上在该方法内直接指定为 "),e("code",[t._v("v")]),t._v("。也就是默认格式的值")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("p.printArg(arg, 'v')\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[e("p",[t._v("w.Write(p.buf): 写入标准输出（io.Writer）")])]),t._v(" "),e("li",[e("p",[t._v("*pp.free(): 释放已缓存的内容。在使用完临时对象后，会将 buf、arg、value 清空再重新存放到 ppFree 中。以便于后面再取出重用（利用 sync.Pool 的临时对象特性）")])])]),t._v(" "),e("h3",{attrs:{id:"案例二：printf"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例二：printf"}},[t._v("#")]),t._v(" 案例二：Printf")]),t._v(" "),e("h4",{attrs:{id:"标识符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标识符"}},[t._v("#")]),t._v(" 标识符")]),t._v(" "),e("h5",{attrs:{id:"verbs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#verbs"}},[t._v("#")]),t._v(" Verbs")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("%v\tthe value in a default format\n\twhen printing structs, the plus flag (%+v) adds field names\n%#v\ta Go-syntax representation of the value\n%T\ta Go-syntax representation of the type of the value\n%%\ta literal percent sign; consumes no value\n%t\tthe word true or false\n")])])]),e("h5",{attrs:{id:"flags"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flags"}},[t._v("#")]),t._v(" Flags")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("+\talways print a sign for numeric values;\n\tguarantee ASCII-only output for %q (%+q)\n-\tpad with spaces on the right rather than the left (left-justify the field)\n#\talternate format: add leading 0 for octal (%#o), 0x for hex (%#x);\n\t0X for hex (%#X); suppress 0x for %p (%#p);\n\tfor %q, print a raw (backquoted) string if strconv.CanBackquote\n\treturns true;\n\talways print a decimal point for %e, %E, %f, %F, %g and %G;\n\tdo not remove trailing zeros for %g and %G;\n\twrite e.g. U+0078 'x' if the character is printable for %U (%#U).\n' '\t(space) leave a space for elided sign in numbers (% d);\n\tput spaces between bytes printing strings or slices in hex (% x, % X)\n0\tpad with leading zeros rather than spaces;\n\tfor numbers, this moves the padding after the sign\n")])])]),e("p",[t._v("详细建议参见 "),e("a",{attrs:{href:"https://golang.org/pkg/fmt/#hdr-Printing",target:"_blank",rel:"noopener noreferrer"}},[t._v("Godoc"),e("OutboundLink")],1)]),t._v(" "),e("h4",{attrs:{id:"原型-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型-3"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {\n\tp := newPrinter()\n\tp.doPrintf(format, a)\n\tn, err = w.Write(p.buf)\n\tp.free()\n\treturn\n}\n")])])]),e("p",[t._v("与 Print 相比，最大的不同就是 doPrintf 方法了。在这里我们来详细看看其代码，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func (p *pp) doPrintf(format string, a []interface{}) {\n\tend := len(format)\n\targNum := 0         // we process one argument per non-trivial format\n\tafterIndex := false // previous item in format was an index like [3].\n\tp.reordered = false\nformatLoop:\n\tfor i := 0; i < end; {\n\t\tp.goodArgNum = true\n\t\tlasti := i\n\t\tfor i < end && format[i] != '%' {\n\t\t\ti++\n\t\t}\n\t\tif i > lasti {\n\t\t\tp.buf.WriteString(format[lasti:i])\n\t\t}\n\t\tif i >= end {\n\t\t\t// done processing format string\n\t\t\tbreak\n\t\t}\n\n\t\t// Process one verb\n\t\ti++\n\n\t\t// Do we have flags?\n\t\tp.fmt.clearflags()\n\tsimpleFormat:\n\t\tfor ; i < end; i++ {\n\t\t\tc := format[i]\n\t\t\tswitch c {\n\t\t\tcase '#':   //'#'、'0'、'+'、'-'、' '\n\t\t\t\t...\n\t\t\tdefault:\n\t\t\t\tif 'a' <= c && c <= 'z' && argNum < len(a) {\n\t\t\t\t\t...\n\t\t\t\t\tp.printArg(a[argNum], rune(c))\n\t\t\t\t\targNum++\n\t\t\t\t\ti++\n\t\t\t\t\tcontinue formatLoop\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak simpleFormat\n\t\t\t}\n\t\t}\n\n\t\t// Do we have an explicit argument index?\n\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n\n\t\t// Do we have width?\n\t\tif i < end && format[i] == '*' {\n\t\t\t...\n\t\t}\n\n\t\t// Do we have precision?\n\t\tif i+1 < end && format[i] == '.' {\n\t\t\t...\n\t\t}\n\n\t\tif !afterIndex {\n\t\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n\t\t}\n\n\t\tif i >= end {\n\t\t\tp.buf.WriteString(noVerbString)\n\t\t\tbreak\n\t\t}\n\n\t\t...\n\n\t\tswitch {\n\t\tcase verb == '%': // Percent does not absorb operands and ignores f.wid and f.prec.\n\t\t\tp.buf.WriteByte('%')\n\t\tcase !p.goodArgNum:\n\t\t\tp.badArgNum(verb)\n\t\tcase argNum >= len(a): // No argument left over to print for the current verb.\n\t\t\tp.missingArg(verb)\n\t\tcase verb == 'v':\n\t\t\t...\n\t\t\tfallthrough\n\t\tdefault:\n\t\t\tp.printArg(a[argNum], verb)\n\t\t\targNum++\n\t\t}\n\t}\n\n\tif !p.reordered && argNum < len(a) {\n\t\t...\n\t}\n}\n")])])]),e("h4",{attrs:{id:"分析主干流程-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析主干流程-2"}},[t._v("#")]),t._v(" 分析主干流程")]),t._v(" "),e("ol",[e("li",[t._v("写入 % 之前的字符内容")]),t._v(" "),e("li",[t._v("如果所有标志位处理完毕（到达字符尾部），则跳出处理逻辑")]),t._v(" "),e("li",[t._v("（往后移）跳过 % ，开始处理其他 verb 标志位")]),t._v(" "),e("li",[t._v("清空（重新初始化） fmt 配置")]),t._v(" "),e("li",[t._v("处理一些基础的 verb 标识符（simpleFormat）。如：'#'、'0'、'+'、'-'、' ' 以及"),e("strong",[t._v("简单的 verbs 标识符（不包含精度、宽度和参数索引）。需要注意的是，若当前字符为简单 verb 标识符。则直接进行处理。完成后会直接后移到下一个字符")]),t._v("。其余标志位则变更 fmt 配置项，便于后续处理")]),t._v(" "),e("li",[t._v("处理参数索引（argument index）")]),t._v(" "),e("li",[t._v("处理参数宽度（width）")]),t._v(" "),e("li",[t._v("处理参数精度（precision）")]),t._v(" "),e("li",[t._v("% 之后若不存在 verbs 标识符则返回 "),e("code",[t._v("noVerbString")]),t._v("。值为 %!(NOVERB)")]),t._v(" "),e("li",[t._v("处理特殊 verbs 标识符（如：'%%'、'%#v'、'%+v'）、错误情况（如：参数索引指定错误、参数集个数与 verbs 标识符数量不匹配）或进行格式化参数集")]),t._v(" "),e("li",[t._v("常规流程处理完毕")])]),t._v(" "),e("p",[t._v("在特殊情况下，若提供的参数集比 verb 标识符多。fmt 将会贪婪检查下去，将多出的参数集以特定的格式输出，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('fmt.Printf("%d", 1, 2, 3)\n// 1%!(EXTRA int=2, int=3)\n')])])]),e("ul",[e("li",[t._v("约定前缀额外标志：%!(EXTRA")]),t._v(" "),e("li",[t._v("当前参数的类型")]),t._v(" "),e("li",[t._v("约定格式符：=")]),t._v(" "),e("li",[t._v("当前参数的值（默认以 %v 格式化）")]),t._v(" "),e("li",[t._v("约定格式符：)")])]),t._v(" "),e("p",[t._v("值得注意的是，当指定了参数索引或实际处理的参数小于入参的参数集时，就不会进行贪婪匹配来展示")]),t._v(" "),e("h3",{attrs:{id:"案例三：println"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例三：println"}},[t._v("#")]),t._v(" 案例三：Println")]),t._v(" "),e("h4",{attrs:{id:"原型-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型-4"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func Fprintln(w io.Writer, a ...interface{}) (n int, err error) {\n\tp := newPrinter()\n\tp.doPrintln(a)\n\tn, err = w.Write(p.buf)\n\tp.free()\n\treturn\n}\n")])])]),e("p",[t._v("在这个方法中，最大的区别就是 doPrintln，我们一起来看看，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func (p *pp) doPrintln(a []interface{}) {\n\tfor argNum, arg := range a {\n\t\tif argNum > 0 {\n\t\t\tp.buf.WriteByte(' ')\n\t\t}\n\t\tp.printArg(arg, 'v')\n\t}\n\tp.buf.WriteByte('\\n')\n}\n")])])]),e("h4",{attrs:{id:"分析主干流程-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析主干流程-3"}},[t._v("#")]),t._v(" 分析主干流程")]),t._v(" "),e("ul",[e("li",[t._v("循环入参的参数集，并以空格分隔")]),t._v(" "),e("li",[t._v("格式化当前参数，默认以 "),e("code",[t._v("%v")]),t._v(" 对参数进行格式化")]),t._v(" "),e("li",[t._v("在结尾添加 "),e("code",[t._v("\\n")]),t._v(" 字符")])]),t._v(" "),e("h2",{attrs:{id:"如何格式化参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何格式化参数"}},[t._v("#")]),t._v(" 如何格式化参数")]),t._v(" "),e("p",[t._v("在上例的执行流程分析中，可以看到格式化参数这一步是在 "),e("code",[t._v("p.printArg(arg, verb)")]),t._v(" 执行的，我们一起来看看它都做了些什么？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func (p *pp) printArg(arg interface{}, verb rune) {\n\tp.arg = arg\n\tp.value = reflect.Value{}\n\n\tif arg == nil {\n\t\tswitch verb {\n\t\tcase 'T', 'v':\n\t\t\tp.fmt.padString(nilAngleString)\n\t\tdefault:\n\t\t\tp.badVerb(verb)\n\t\t}\n\t\treturn\n\t}\n\n\tswitch verb {\n\tcase 'T':\n\t\tp.fmt.fmt_s(reflect.TypeOf(arg).String())\n\t\treturn\n\tcase 'p':\n\t\tp.fmtPointer(reflect.ValueOf(arg), 'p')\n\t\treturn\n\t}\n\n\t// Some types can be done without reflection.\n\tswitch f := arg.(type) {\n\tcase bool:\n\t\tp.fmtBool(f, verb)\n\tcase float32:\n\t\tp.fmtFloat(float64(f), 32, verb)\n\t...\n\tcase reflect.Value:\n\t\tif f.IsValid() && f.CanInterface() {\n\t\t\tp.arg = f.Interface()\n\t\t\tif p.handleMethods(verb) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tp.printValue(f, verb, 0)\n\tdefault:\n\t\tif !p.handleMethods(verb) {\n\t\t\tp.printValue(reflect.ValueOf(f), verb, 0)\n\t\t}\n\t}\n}\n")])])]),e("p",[t._v("在小节代码中可以看见，fmt 本身对不同的类型做了不同的处理。这样子就避免了通过反射确定。相对的提高了性能")]),t._v(" "),e("p",[t._v("其中有两个特殊的方法，分别是 "),e("code",[t._v("handleMethods")]),t._v(" 和 "),e("code",[t._v("badVerb")]),t._v("，接下来分别来看看他们的作用是什么")]),t._v(" "),e("p",[t._v("1、badVerb")]),t._v(" "),e("p",[t._v("它主要用于格式化并处理错误的行为。我们可以一起来看看，代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func (p *pp) badVerb(verb rune) {\n\tp.erroring = true\n\tp.buf.WriteString(percentBangString)\n\tp.buf.WriteRune(verb)\n\tp.buf.WriteByte('(')\n\tswitch {\n\tcase p.arg != nil:\n\t\tp.buf.WriteString(reflect.TypeOf(p.arg).String())\n\t\tp.buf.WriteByte('=')\n\t\tp.printArg(p.arg, 'v')\n\t...\n\tdefault:\n\t\tp.buf.WriteString(nilAngleString)\n\t}\n\tp.buf.WriteByte(')')\n\tp.erroring = false\n}\n")])])]),e("p",[t._v("在处理错误格式化时，我们可以对比以下例子：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('fmt.Printf("%s", []int64{1, 2, 3})\n// [%!s(int64=1) %!s(int64=2) %!s(int64=3)]%\n')])])]),e("p",[t._v("在 badVerb 中可以看到错误字符串的处理主要分为以下部分：")]),t._v(" "),e("ul",[e("li",[t._v("约定前缀错误标志：%!")]),t._v(" "),e("li",[t._v("当前的格式化操作符")]),t._v(" "),e("li",[t._v("约定格式符：(")]),t._v(" "),e("li",[t._v("当前参数的类型")]),t._v(" "),e("li",[t._v("约定格式符：=")]),t._v(" "),e("li",[t._v("当前参数的值（默认以 %v 格式化）")]),t._v(" "),e("li",[t._v("约定格式符：)")])]),t._v(" "),e("p",[t._v("2、handleMethods")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func (p *pp) handleMethods(verb rune) (handled bool) {\n\tif p.erroring {\n\t\treturn\n\t}\n\t// Is it a Formatter?\n\tif formatter, ok := p.arg.(Formatter); ok {\n\t\thandled = true\n\t\tdefer p.catchPanic(p.arg, verb)\n\t\tformatter.Format(p, verb)\n\t\treturn\n\t}\n\n\t// If we're doing Go syntax and the argument knows how to supply it, take care of it now.\n\t...\n\t\n\treturn false\n}\n")])])]),e("p",[t._v("这个方法比较特殊，一般在自定义结构体和未知情况下进行调用。主要流程是：")]),t._v(" "),e("ul",[e("li",[t._v("若当前参数为错误 verb 标识符，则直接返回")]),t._v(" "),e("li",[t._v("判断是否实现了 Formatter")]),t._v(" "),e("li",[t._v("实现，则利用自定义 Formatter 格式化参数")]),t._v(" "),e("li",[t._v("未实现，则最大程度的利用 Go syntax 默认规则去格式化参数")])]),t._v(" "),e("h2",{attrs:{id:"拓展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拓展"}},[t._v("#")]),t._v(" 拓展")]),t._v(" "),e("p",[t._v("在 fmt 标准库中可以通过自定义结构体来实现方法的自定义，大致如下几种")]),t._v(" "),e("h3",{attrs:{id:"fmt-state"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fmt-state"}},[t._v("#")]),t._v(" fmt.State")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type State interface {\n\tWrite(b []byte) (n int, err error)\n\n\tWidth() (wid int, ok bool)\n\n\tPrecision() (prec int, ok bool)\n\n\tFlag(c int) bool\n}\n")])])]),e("p",[t._v("State 用于获取标志位的状态值，涉及如下：")]),t._v(" "),e("ul",[e("li",[t._v("Write：将格式化完毕的字符写入缓冲区中，等待下一步处理")]),t._v(" "),e("li",[t._v("Width：返回宽度信息和是否被设置")]),t._v(" "),e("li",[t._v("Precision：返回精度信息和是否被设置")]),t._v(" "),e("li",[t._v("Flag：返回特殊标志符（'#'、'0'、'+'、'-'、' '）是否被设置")])]),t._v(" "),e("h3",{attrs:{id:"fmt-formatter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fmt-formatter"}},[t._v("#")]),t._v(" fmt.Formatter")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type Formatter interface {\n\tFormat(f State, c rune)\n}\n")])])]),e("p",[t._v("Formatter 用于实现"),e("strong",[t._v("自定义格式化方法")]),t._v("。可通过在自定义结构体中实现 Format 方法来实现这个目的")]),t._v(" "),e("p",[t._v("另外，可以通过 f 获取到当前标识符的宽度、精度等状态值。c 为 verb 标识符，可以得到其动作是什么")]),t._v(" "),e("h3",{attrs:{id:"fmt-stringer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fmt-stringer"}},[t._v("#")]),t._v(" fmt.Stringer")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type Stringer interface {\n\tString() string\n}\n")])])]),e("p",[t._v("当该对象为 String、Array、Slice 等类型时，将会调用 "),e("code",[t._v("String()")]),t._v(" 方法对类字符串进行格式化")]),t._v(" "),e("h3",{attrs:{id:"fmt-gostringer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fmt-gostringer"}},[t._v("#")]),t._v(" fmt.GoStringer")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type GoStringer interface {\n\tGoString() string\n}\n")])])]),e("p",[t._v("当格式化特定 verb 标识符（%v）时，将调用 "),e("code",[t._v("GoString()")]),t._v(" 方法对其进行格式化")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("通过本文对 fmt 标准库的分析，可以发现它有以下特点：")]),t._v(" "),e("ul",[e("li",[t._v("在拓展性方面，可以自定义格式化方法等")]),t._v(" "),e("li",[t._v("在完整度方面，尽可能的贪婪匹配，输出参数集")]),t._v(" "),e("li",[t._v("在性能方面，每种不同的参数类型，都实现了不同的格式化处理操作")]),t._v(" "),e("li",[t._v("在性能方面，尽可能的最短匹配，格式化参数集")])]),t._v(" "),e("p",[t._v("总的来说，fmt 标准库有许多值得推敲的细节，希望你能够在本文学到 😄")])])}),[],!1,null,null,null);r.default=a.exports}}]);