(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{679:function(t,e,a){"use strict";a.r(e);var n=a(44),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_8-2-log-标准库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-log-标准库"}},[t._v("#")]),t._v(" 8.2 log 标准库")]),t._v(" "),a("h2",{attrs:{id:"日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#日志"}},[t._v("#")]),t._v(" 日志")]),t._v(" "),a("h3",{attrs:{id:"输出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输出"}},[t._v("#")]),t._v(" 输出")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("2018/09/28 20:03:08 EDDYCJY Blog...\n")])])]),a("h3",{attrs:{id:"构成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构成"}},[t._v("#")]),t._v(" 构成")]),t._v(" "),a("p",[t._v("[日期]<空格>[时分秒]<空格>[内容]<\\n>")]),t._v(" "),a("h2",{attrs:{id:"源码剖析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码剖析"}},[t._v("#")]),t._v(" 源码剖析")]),t._v(" "),a("h3",{attrs:{id:"logger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#logger"}},[t._v("#")]),t._v(" Logger")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type Logger struct {\n\tmu     sync.Mutex \n\tprefix string\n\tflag   int\n\tout    io.Writer\n\tbuf    []byte\n}\n")])])]),a("ol",[a("li",[t._v("mu：互斥锁，用于确保原子的写入")]),t._v(" "),a("li",[t._v("prefix：每行需写入的日志前缀内容")]),t._v(" "),a("li",[t._v("flag：设置日志辅助信息（时间、文件名、行号）的写入。可选如下标识位：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const (\n\tLdate         = 1 << iota       // value: 1\n\tLtime                           // value: 2\n\tLmicroseconds                   // value: 4\n\tLlongfile                       // value: 8\n\tLshortfile                      // value: 16\n\tLUTC                            // value: 32\n\tLstdFlags     = Ldate | Ltime   // value: 3\n)\n")])])]),a("ul",[a("li",[t._v("Ldate：当地时区的格式化日期：2009/01/23")]),t._v(" "),a("li",[t._v("Ltime：当地时区的格式化时间：01:23:23")]),t._v(" "),a("li",[t._v("Lmicroseconds：在 Ltime 的基础上，增加微秒的时间数值显示")]),t._v(" "),a("li",[t._v("Llongfile：完整的文件名和行号：/a/b/c/d.go:23")]),t._v(" "),a("li",[t._v("Lshortfile：当前文件名和行号：d.go：23，会覆盖 Llongfile 标识")]),t._v(" "),a("li",[t._v("LUTC：如果设置 Ldate 或 Ltime，且设置 LUTC，则优先使用 UTC 时区而不是本地时区")]),t._v(" "),a("li",[t._v("LstdFlags：Logger 的默认初始值（Ldate 和 Ltime）")])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("out：io.Writer")]),t._v(" "),a("li",[t._v("buf：用于存储将要写入的日志内容")])]),t._v(" "),a("h3",{attrs:{id:"new"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new"}},[t._v("#")]),t._v(" New")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('func New(out io.Writer, prefix string, flag int) *Logger {\n\treturn &Logger{out: out, prefix: prefix, flag: flag}\n}\n\nvar std = New(os.Stderr, "", LstdFlags)\n')])])]),a("p",[t._v("New 方法用于初始化 Logger，接受三个初始参数，可以定制化而在 log 包内默认会初始一个 std，它指向标准输入流。而默认的标准输出、标准错误就是显示器（输出到屏幕上），标准输入就是键盘。辅助的时间信息默认为 "),a("code",[t._v("Ldate | Ltime")]),t._v("，也就是 "),a("code",[t._v("2009/01/23 01:23:23")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// os\nvar (\n\tStdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")\n\tStdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")\n\tStderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")\n)\n')])])]),a("ul",[a("li",[t._v("Stdin：标准输入")]),t._v(" "),a("li",[t._v("Stdout：标准输出")]),t._v(" "),a("li",[t._v("Stderr：标准错误")])]),t._v(" "),a("h3",{attrs:{id:"getter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getter"}},[t._v("#")]),t._v(" Getter")]),t._v(" "),a("ul",[a("li",[t._v("Flags")]),t._v(" "),a("li",[t._v("Prefix")])]),t._v(" "),a("h3",{attrs:{id:"setter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setter"}},[t._v("#")]),t._v(" Setter")]),t._v(" "),a("ul",[a("li",[t._v("SetFlags")]),t._v(" "),a("li",[t._v("SetPrefix")]),t._v(" "),a("li",[t._v("SetOutput")])]),t._v(" "),a("h3",{attrs:{id:"print-fatal-panic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#print-fatal-panic"}},[t._v("#")]),t._v(" Print*, Fatal*, Panic*")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("func Print(v ...interface{}) {\n\tstd.Output(2, fmt.Sprint(v...))\n}\n\nfunc Printf(format string, v ...interface{}) {\n\tstd.Output(2, fmt.Sprintf(format, v...))\n}\n\nfunc Println(v ...interface{}) {\n\tstd.Output(2, fmt.Sprintln(v...))\n}\n\nfunc Fatal(v ...interface{}) {\n\tstd.Output(2, fmt.Sprint(v...))\n\tos.Exit(1)\n}\n\nfunc Panic(v ...interface{}) {\n\ts := fmt.Sprint(v...)\n\tstd.Output(2, s)\n\tpanic(s)\n}\n\n...\n")])])]),a("p",[t._v("这一部分介绍最常用的日志写入方法，从源码可得知 "),a("code",[t._v("Xrintln")]),t._v("、"),a("code",[t._v("Xrintf")]),t._v(" 函数 "),a("strong",[t._v("换行")]),t._v("、"),a("strong",[t._v("可变参数")]),t._v("都是通过 "),a("code",[t._v("fmt")]),t._v(" 标准库的方法去实现的")]),t._v(" "),a("p",[a("code",[t._v("Fatal")]),t._v(" 和 "),a("code",[t._v("Panic")]),t._v(" 是通过 "),a("code",[t._v("os.Exit(1)")]),t._v("、"),a("code",[t._v("panic(s)")]),t._v(" 集成实现的。而具体的组装逻辑是通过 "),a("code",[t._v("Output")]),t._v(" 方法实现的")]),t._v(" "),a("h4",{attrs:{id:"logger-output"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#logger-output"}},[t._v("#")]),t._v(" Logger.Output")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("func (l *Logger) Output(calldepth int, s string) error {\n\tnow := time.Now() // get this early.\n\tvar file string\n\tvar line int\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tif l.flag&(Lshortfile|Llongfile) != 0 {\n\t\t// Release lock while getting caller info - it's expensive.\n\t\tl.mu.Unlock()\n\t\tvar ok bool\n\t\t_, file, line, ok = runtime.Caller(calldepth)\n\t\tif !ok {\n\t\t\tfile = \"???\"\n\t\t\tline = 0\n\t\t}\n\t\tl.mu.Lock()\n\t}\n\tl.buf = l.buf[:0]\n\tl.formatHeader(&l.buf, now, file, line)\n\tl.buf = append(l.buf, s...)\n\tif len(s) == 0 || s[len(s)-1] != '\\n' {\n\t\tl.buf = append(l.buf, '\\n')\n\t}\n\t_, err := l.out.Write(l.buf)\n\treturn err\n}\n")])])]),a("p",[t._v("Output 方法，简单来讲就是将写入的日志事件信息组装并输出，它会根据 flag 标识位的不同来使用 "),a("code",[t._v("runtime.Caller")]),t._v(" 去获取当前 goroutine 所执行的函数文件、行号等调用信息（log 标准库中默认深度为 2）。另外如果结尾不是换行符 "),a("code",[t._v("\\n")]),t._v("，将自动补全一个换行")]),t._v(" "),a("h4",{attrs:{id:"logger-formatheader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#logger-formatheader"}},[t._v("#")]),t._v(" Logger.formatHeader")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) {\n\t*buf = append(*buf, l.prefix...)\n\tif l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {\n\t\tif l.flag&LUTC != 0 {\n\t\t\tt = t.UTC()\n\t\t}\n\t\tif l.flag&Ldate != 0 {\n\t\t\tyear, month, day := t.Date()\n\t\t\titoa(buf, year, 4)\n\t\t\t*buf = append(*buf, '/')\n\t\t\titoa(buf, int(month), 2)\n\t\t\t*buf = append(*buf, '/')\n\t\t\titoa(buf, day, 2)\n\t\t\t*buf = append(*buf, ' ')\n\t\t}\n\t\tif l.flag&(Ltime|Lmicroseconds) != 0 {\n\t\t\thour, min, sec := t.Clock()\n\t\t\titoa(buf, hour, 2)\n\t\t\t*buf = append(*buf, ':')\n\t\t\titoa(buf, min, 2)\n\t\t\t*buf = append(*buf, ':')\n\t\t\titoa(buf, sec, 2)\n\t\t\tif l.flag&Lmicroseconds != 0 {\n\t\t\t\t*buf = append(*buf, '.')\n\t\t\t\titoa(buf, t.Nanosecond()/1e3, 6)\n\t\t\t}\n\t\t\t*buf = append(*buf, ' ')\n\t\t}\n\t}\n\tif l.flag&(Lshortfile|Llongfile) != 0 {\n\t\tif l.flag&Lshortfile != 0 {\n\t\t\tshort := file\n\t\t\tfor i := len(file) - 1; i > 0; i-- {\n\t\t\t\tif file[i] == '/' {\n\t\t\t\t\tshort = file[i+1:]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tfile = short\n\t\t}\n\t\t*buf = append(*buf, file...)\n\t\t*buf = append(*buf, ':')\n\t\titoa(buf, line, -1)\n\t\t*buf = append(*buf, \": \"...)\n\t}\n}\n")])])]),a("p",[t._v("该方法主要是用于格式化日志头（前缀），根据入参不同的标识位，添加分隔符和对应的值到日志信息中。执行流程如下：")]),t._v(" "),a("p",[t._v("（1）如果不是空值，则将 prefix 写入 buf")]),t._v(" "),a("p",[t._v("（2）如果设置 "),a("code",[t._v("Ldate")]),t._v("、"),a("code",[t._v("Ltime")]),t._v("、"),a("code",[t._v("Lmicroseconds")]),t._v("，则对应将日期和时间写入 buf")]),t._v(" "),a("p",[t._v("（3）如果设置 "),a("code",[t._v("Lshortfile")]),t._v("、"),a("code",[t._v("Llongfile")]),t._v("，则对应将文件和行号信息写入 buf")]),t._v(" "),a("h4",{attrs:{id:"logger-itoa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#logger-itoa"}},[t._v("#")]),t._v(" Logger.itoa")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("func itoa(buf *[]byte, i int, wid int) {\n\t// Assemble decimal in reverse order.\n\tvar b [20]byte\n\tbp := len(b) - 1\n\tfor i >= 10 || wid > 1 {\n\t\twid--\n\t\tq := i / 10\n\t\tb[bp] = byte('0' + i - q*10)\n\t\tbp--\n\t\ti = q\n\t}\n\t// i < 10\n\tb[bp] = byte('0' + i)\n\t*buf = append(*buf, b[bp:]...)\n}\n")])])]),a("p",[t._v("该方法主要用于将整数转换为定长的十进制 ASCII，同时给出负数宽度避免左侧补 0。另外会以相反的顺序组合十进制")]),t._v(" "),a("h3",{attrs:{id:"如何定制化-logger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何定制化-logger"}},[t._v("#")]),t._v(" 如何定制化 Logger")]),t._v(" "),a("p",[t._v("在标准库内，可通过其开放的 New 方法来实现各种各样的自定义 Logger 组件，但是为什么也可以直接 "),a("code",[t._v("log.Print*")]),t._v(" 等方法呢？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("func New(out io.Writer, prefix string, flag int) *Logger\n")])])]),a("p",[t._v("其实是在标准库内，如果你刚刚细心的看了前面的小节，不难发现其默认实现了一个 Logger 组件")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('var std = New(os.Stderr, "", LstdFlags)\n')])])]),a("p",[t._v("这也是一个小小的精妙之处 ⭕️")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("通过查阅 log 标准库的源码，可得知最简单的一个日志包应该如何编写。另外 log 包是在所有涉及到 Logger 的地方都对 "),a("code",[t._v("sync.Mutex")]),t._v(" 进行操作（以此解决原子问题），其余逻辑均为组装日志信息和转换数值格式，该包较为经典，可以多读几遍 😄")]),t._v(" "),a("h2",{attrs:{id:"问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),a("p",[t._v("为什么在调用 "),a("code",[t._v("runtime.Caller")]),t._v(" 前要先解锁，后再加锁呢?")])])}),[],!1,null,null,null);e.default=r.exports}}]);