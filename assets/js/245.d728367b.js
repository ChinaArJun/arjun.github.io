(window.webpackJsonp=window.webpackJsonp||[]).push([[245],{680:function(t,n,e){"use strict";e.r(n);var a=e(44),v=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_8-3-有点不安全却又一亮的-go-unsafe-pointer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-有点不安全却又一亮的-go-unsafe-pointer"}},[t._v("#")]),t._v(" 8.3 有点不安全却又一亮的 Go unsafe.Pointer")]),t._v(" "),e("p",[t._v("在上一篇文章"),e("a",{attrs:{href:"https://book.eddycjy.com/golang/slice/slice.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("《深入理解 Go Slice》"),e("OutboundLink")],1),t._v("中，大家会发现其底层数据结构使用了 "),e("code",[t._v("unsafe.Pointer")]),t._v("。因此想着再介绍一下其关联知识")]),t._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("在大家学习 Go 的时候，肯定都学过 “Go 的指针是不支持指针运算和转换” 这个知识点。为什么呢？")]),t._v(" "),e("p",[t._v("首先，Go 是一门静态语言，所有的变量都必须为标量类型。不同的类型不能够进行赋值、计算等跨类型的操作。那么指针也对应着相对的类型，也在 Compile 的静态类型检查的范围内。同时静态语言，也称为强类型。也就是一旦定义了，就不能再改变它")]),t._v(" "),e("h2",{attrs:{id:"错误示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误示例"}},[t._v("#")]),t._v(" 错误示例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func main(){\n\tnum := 5\n\tnumPointer := &num\n\n\tflnum := (*float32)(numPointer)\n\tfmt.Println(flnum)\n}\n")])])]),e("p",[t._v("输出结果：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# command-line-arguments\n...: cannot convert numPointer (type *int) to type *float32\n")])])]),e("p",[t._v("在示例中，我们创建了一个 "),e("code",[t._v("num")]),t._v(" 变量，值为 5，类型为 "),e("code",[t._v("int")]),t._v("。取了其对于的指针地址后，试图强制转换为 "),e("code",[t._v("*float32")]),t._v("，结果失败...")]),t._v(" "),e("h2",{attrs:{id:"unsafe"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unsafe"}},[t._v("#")]),t._v(" unsafe")]),t._v(" "),e("p",[t._v("针对刚刚的 “错误示例”，我们可以采用今天的男主角 "),e("code",[t._v("unsafe")]),t._v(" 标准库来解决。它是一个神奇的包，在官方的诠释中，有如下概述：")]),t._v(" "),e("ul",[e("li",[t._v("围绕 Go 程序内存安全及类型的操作")]),t._v(" "),e("li",[t._v("很可能会是不可移植的")]),t._v(" "),e("li",[t._v("不受 Go 1 兼容性指南的保护")])]),t._v(" "),e("p",[t._v("简单来讲就是，不怎么推荐你使用。因为它是 unsafe（不安全的），但是在特殊的场景下，使用了它。可以打破 Go 的类型和内存安全机制，让你获得眼前一亮的惊喜效果 😄")]),t._v(" "),e("h3",{attrs:{id:"pointer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pointer"}},[t._v("#")]),t._v(" Pointer")]),t._v(" "),e("p",[t._v("为了解决这个问题，需要用到 "),e("code",[t._v("unsafe.Pointer")]),t._v("。它表示任意类型且可寻址的指针值，可以在不同的指针类型之间进行转换（类似 C 语言的 void * 的用途）")]),t._v(" "),e("p",[t._v("其包含四种核心操作：")]),t._v(" "),e("ul",[e("li",[t._v("任何类型的指针值都可以转换为 Pointer")]),t._v(" "),e("li",[t._v("Pointer 可以转换为任何类型的指针值")]),t._v(" "),e("li",[t._v("uintptr 可以转换为 Pointer")]),t._v(" "),e("li",[t._v("Pointer 可以转换为 uintptr")])]),t._v(" "),e("p",[t._v("在这一部分，重点看第一点、第二点。你再想想怎么修改 “错误示例” 让它运行起来？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func main(){\n\tnum := 5\n\tnumPointer := &num\n\n\tflnum := (*float32)(unsafe.Pointer(numPointer))\n\tfmt.Println(flnum)\n}\n")])])]),e("p",[t._v("输出结果：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("0xc4200140b0\n")])])]),e("p",[t._v("在上述代码中，我们小加改动。通过 "),e("code",[t._v("unsafe.Pointer")]),t._v(" 的特性对该指针变量进行了修改，就可以完成任意类型（*T）的指针转换")]),t._v(" "),e("p",[t._v("需要注意的是，这时还无法对变量进行操作或访问。因为不知道该指针地址指向的东西具体是什么类型。不知道是什么类型，又如何进行解析呢。无法解析也就自然无法对其变更了")]),t._v(" "),e("h3",{attrs:{id:"offsetof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#offsetof"}},[t._v("#")]),t._v(" Offsetof")]),t._v(" "),e("p",[t._v("在上小节中，我们对普通的指针变量进行了修改。那么它是否能做更复杂一点的事呢？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('type Num struct{\n\ti string\n\tj int64\n}\n\nfunc main(){\n\tn := Num{i: "EDDYCJY", j: 1}\n\tnPointer := unsafe.Pointer(&n)\n\n\tniPointer := (*string)(unsafe.Pointer(nPointer))\n\t*niPointer = "煎鱼"\n\n\tnjPointer := (*int64)(unsafe.Pointer(uintptr(nPointer) + unsafe.Offsetof(n.j)))\n\t*njPointer = 2\n\n\tfmt.Printf("n.i: %s, n.j: %d", n.i, n.j)\n}\n\n')])])]),e("p",[t._v("输出结果：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("n.i: 煎鱼, n.j: 2\n")])])]),e("p",[t._v("在剖析这段代码做了什么事之前，我们需要了解结构体的一些基本概念：")]),t._v(" "),e("ul",[e("li",[t._v("结构体的成员变量在内存存储上是一段连续的内存")]),t._v(" "),e("li",[t._v("结构体的初始地址就是第一个成员变量的内存地址")]),t._v(" "),e("li",[t._v("基于结构体的成员地址去计算偏移量。就能够得出其他成员变量的内存地址")])]),t._v(" "),e("p",[t._v("再回来看看上述代码，得出执行流程：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("修改 "),e("code",[t._v("n.i")]),t._v(" 值："),e("code",[t._v("i")]),t._v(" 为第一个成员变量。因此不需要进行偏移量计算，直接取出指针后转换为 "),e("code",[t._v("Pointer")]),t._v("，再强制转换为字符串类型的指针值即可")])]),t._v(" "),e("li",[e("p",[t._v("修改 "),e("code",[t._v("n.j")]),t._v(" 值："),e("code",[t._v("j")]),t._v(" 为第二个成员变量。需要进行偏移量计算，才可以对其内存地址进行修改。在进行了偏移运算后，当前地址已经指向第二个成员变量。接着重复转换赋值即可")])])]),t._v(" "),e("p",[t._v("需要注意的是，这里使用了如下方法（来完成偏移计算的目标）：")]),t._v(" "),e("p",[t._v("1、uintptr："),e("code",[t._v("uintptr")]),t._v(" 是 Go 的内置类型。返回无符号整数，可存储一个完整的地址。后续常用于指针运算")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type uintptr uintptr\n")])])]),e("p",[t._v("2、unsafe.Offsetof：返回成员变量 x 在结构体当中的偏移量。更具体的讲，就是返回结构体初始位置到 x 之间的字节数。需要注意的是入参 "),e("code",[t._v("ArbitraryType")]),t._v(" 表示任意类型，并非定义的 "),e("code",[t._v("int")]),t._v("。它实际作用是一个占位符")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func Offsetof(x ArbitraryType) uintptr\n")])])]),e("p",[t._v("在这一部分，其实就是巧用了 "),e("code",[t._v("Pointer")]),t._v(" 的第三、第四点特性。这时候就已经可以对变量进行操作了 😄")]),t._v(" "),e("h3",{attrs:{id:"错误示例-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误示例-2"}},[t._v("#")]),t._v(" 错误示例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func main(){\n\tn := Num{i: "EDDYCJY", j: 1}\n\tnPointer := unsafe.Pointer(&n)\n    ...\n\n\tptr := uintptr(nPointer)\n\tnjPointer := (*int64)(unsafe.Pointer(ptr + unsafe.Offsetof(n.j)))\n\t...\n}\n')])])]),e("p",[t._v("这里存在一个问题，"),e("code",[t._v("uintptr")]),t._v(" 类型是不能存储在临时变量中的。因为从 GC 的角度来看，"),e("code",[t._v("uintptr")]),t._v(" 类型的临时变量只是一个无符号整数，并不知道它是一个指针地址")]),t._v(" "),e("p",[t._v("因此当满足一定条件后，"),e("code",[t._v("ptr")]),t._v(" 这个临时变量是可能被垃圾回收掉的，那么接下来的内存操作，岂不成迷？")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("简洁回顾两个知识点。第一是 "),e("code",[t._v("unsafe.Pointer")]),t._v(" 可以让你的变量在不同的指针类型转来转去，也就是表示为任意可寻址的指针类型。第二是 "),e("code",[t._v("uintptr")]),t._v(" 常用于与 "),e("code",[t._v("unsafe.Pointer")]),t._v(" 打配合，用于做指针运算，巧妙地很")]),t._v(" "),e("p",[t._v("最后还是那句，没有特殊必要的话。是不建议使用 "),e("code",[t._v("unsafe")]),t._v(" 标准库，它并不安全。虽然它常常能让你眼前一亮 👌")])])}),[],!1,null,null,null);n.default=v.exports}}]);