(window.webpackJsonp=window.webpackJsonp||[]).push([[283],{720:function(t,e,o){"use strict";o.r(e);var r=o(44),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"go-test-测试你的代码"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#go-test-测试你的代码"}},[t._v("#")]),t._v(" go test 测试你的代码")]),t._v(" "),o("p",[t._v("在实际开发中，不仅要开发功能，更重要的是确保这些功能稳定可靠，并且拥有一个不错的性能，要确保这些就要对代码进行测试，开发人员通常会进行单元测试和性能测试。不同的语言通常都有自己的测试包/模块，Go 语言也一样，在 Go 中可以通过 testing 包对代码进行单元和性能测试，下面就来详细介绍。")]),t._v(" "),o("h2",{attrs:{id:"本节核心内容"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#本节核心内容"}},[t._v("#")]),t._v(" 本节核心内容")]),t._v(" "),o("ul",[o("li",[t._v("如何进行单元测试")]),t._v(" "),o("li",[t._v("如何进行压力/性能测试")]),t._v(" "),o("li",[t._v("如何进行性能分析")])]),t._v(" "),o("blockquote",[o("p",[t._v("本小节源码下载路径："),o("a",{attrs:{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo15",target:"_blank",rel:"noopener noreferrer"}},[t._v("demo15"),o("OutboundLink")],1)]),t._v(" "),o("p",[t._v("可先下载源码到本地，结合源码理解后续内容，边学边练。")]),t._v(" "),o("p",[t._v("本小节的代码是基于 "),o("a",{attrs:{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo14",target:"_blank",rel:"noopener noreferrer"}},[t._v("demo14"),o("OutboundLink")],1),t._v(" 来开发的。")])]),t._v(" "),o("h2",{attrs:{id:"go-语言测试支持"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#go-语言测试支持"}},[t._v("#")]),t._v(" Go 语言测试支持")]),t._v(" "),o("p",[t._v("Go 语言有自带的测试框架 testing，可以用来实现单元测试和性能测试，通过 "),o("code",[t._v("go test")]),t._v(" 命令来执行单元测试和性能测试。")]),t._v(" "),o("p",[o("code",[t._v("go test")]),t._v(" 执行测试用例时，是以 go 包为单位进行测试的。执行时需要指定包名，比如："),o("code",[t._v("go test 包名")]),t._v("，如果没有指定包名，默认会选择执行命令时所在的包。"),o("code",[t._v("go test")]),t._v(" 在执行时会遍历以 "),o("code",[t._v("_test.go")]),t._v(" 结尾的源码文件，执行其中以 "),o("code",[t._v("Test")]),t._v("、"),o("code",[t._v("Benchmark")]),t._v("、"),o("code",[t._v("Example")]),t._v(" 开头的测试函数。其中源码文件需要满足以下规范：")]),t._v(" "),o("ul",[o("li",[o("p",[t._v("文件名必须是 "),o("code",[t._v("_test.go")]),t._v(" 结尾，跟源文件在同一个包。")])]),t._v(" "),o("li",[o("p",[t._v("测试用例函数必须以 Test、Benchmark、Example 开头")])]),t._v(" "),o("li",[o("p",[t._v("执行测试用例时的顺序，会按照源码中的顺序依次执行")])]),t._v(" "),o("li",[o("p",[t._v("单元测试函数 TestXxx() 的参数是 testing.T，可以使用该类型来记录错误或测试状态")])]),t._v(" "),o("li",[o("p",[t._v("性能测试函数 BenchmarkXxx() 的参数是 testing.B，函数内以 b.N 作为循环次数，其中 N 会动态变化")])]),t._v(" "),o("li",[o("p",[t._v("示例函数 ExampleXxx() 没有参数，执行完会将输出与注释 "),o("code",[t._v("// Output:")]),t._v(" 进行对比")])]),t._v(" "),o("li",[o("p",[t._v("测试函数原型：func TestXxx(t *testing.T)，Xxx 部分为任意字母数字组合，首字母大写，例如： "),o("code",[t._v("TestgenShortId")]),t._v(" 是错误的函数名，"),o("code",[t._v("TestGenShortId")]),t._v(" 是正确的函数名")])]),t._v(" "),o("li",[o("p",[t._v("通过调用 testing.T 的 Error、Errorf、FailNow、Fatal、FatalIf 方法来说明测试不通过，通过调用 Log、Logf 方法来记录测试信息：")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("t.Log t.Logf     # 正常信息 \nt.Error t.Errorf # 测试失败信息 \nt.Fatal t.Fatalf # 致命错误，测试程序退出的信息\nt.Fail     # 当前测试标记为失败\nt.Failed   # 查看失败标记\nt.FailNow  # 标记失败，并终止当前测试函数的执行，需要注意的是，我们只能在运行测试函数的 Goroutine 中调用 t.FailNow 方法，而不能在我们在测试代码创建出的 Goroutine 中调用它\nt.Skip     # 调用 t.Skip 方法相当于先后对 t.Log 和 t.SkipNow 方法进行调用，而调用 t.Skipf 方法则相当于先后对 t.Logf 和 t.SkipNow 方法进行调用。方法 t.Skipped 的结果值会告知我们当前的测试是否已被忽略\nt.Parallel # 标记为可并行运算\n")])])])])]),t._v(" "),o("h2",{attrs:{id:"编写测试用例（对-genshortid-函数进行单元测试）"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#编写测试用例（对-genshortid-函数进行单元测试）"}},[t._v("#")]),t._v(" 编写测试用例（对 "),o("code",[t._v("GenShortId")]),t._v(" 函数进行单元测试）")]),t._v(" "),o("ol",[o("li",[t._v("在 "),o("code",[t._v("util")]),t._v(" 目录下创建文件 "),o("code",[t._v("util_test.go")]),t._v("，内容为：")])]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('package util\n\nimport (\n\t"testing"\n)\n\nfunc TestGenShortId(t *testing.T) {\n\tshortId, err := GenShortId()\n\tif shortId == "" || err != nil {\n\t\tt.Error("GenShortId failed!")\n\t}\n\n\tt.Log("GenShortId test pass")\n}\n')])])]),o("p",[t._v("从用例可以看出，如果 "),o("code",[t._v("GenShortId()")]),t._v(" 返回的 "),o("code",[t._v("shortId")]),t._v(" 为空或者 "),o("code",[t._v("err")]),t._v(" 不为空，则调用 "),o("code",[t._v("t.Error()")]),t._v(" 函数标明该用例测试不通过。")]),t._v(" "),o("p",[o("strong",[t._v("执行用例")])]),t._v(" "),o("p",[t._v("在 "),o("code",[t._v("util")]),t._v(" 目录下执行命令 "),o("code",[t._v("go test")]),t._v("：")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("$ cd util/\n$ go test\nPASS\nok  \tapiserver/util\t0.006s\n")])])]),o("p",[t._v("要查看更详细的执行信息可以执行 "),o("code",[t._v("go test -v")]),t._v("：")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("$ go test -v\n=== RUN   TestGenShortId\n--- PASS: TestGenShortId (0.00s)\n\tutil_test.go:13: GenShortId test pass\nPASS\nok  \tapiserver/util\t0.006s\n")])])]),o("p",[t._v("根据 "),o("code",[t._v("go test")]),t._v(" 的输出可以知道 "),o("code",[t._v("TestGenShortId")]),t._v(" 用例测试通过。")]),t._v(" "),o("p",[t._v("如果要执行测试 N 次可以使用 "),o("code",[t._v("-count N")]),t._v("：")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("$ go test -v -count 2\n=== RUN   TestGenShortId\n--- PASS: TestGenShortId (0.00s)\n\tutil_test.go:13: GenShortId test pass\n=== RUN   TestGenShortId\n--- PASS: TestGenShortId (0.00s)\n\tutil_test.go:13: GenShortId test pass\nPASS\nok  \tapiserver/util\t0.006s\n")])])]),o("h2",{attrs:{id:"编写性能测试用例"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#编写性能测试用例"}},[t._v("#")]),t._v(" 编写性能测试用例")]),t._v(" "),o("p",[t._v("在 "),o("code",[t._v("util/util_test.go")]),t._v(" 测试文件中，新增两个性能测试函数："),o("code",[t._v("BenchmarkGenShortId()")]),t._v(" 和 "),o("code",[t._v("BenchmarkGenShortIdTimeConsuming()")]),t._v("（详见 "),o("a",{attrs:{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo15/util/util_test.go",target:"_blank",rel:"noopener noreferrer"}},[t._v("demo15/util/util_test.go"),o("OutboundLink")],1),t._v("）：")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('func BenchmarkGenShortId(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tGenShortId()\n\t}\n}\n\nfunc BenchmarkGenShortIdTimeConsuming(b *testing.B) {\n\tb.StopTimer() // 调用该函数停止压力测试的时间计数\n\n\tshortId, err := GenShortId()\n\tif shortId == "" || err != nil {\n\t\tb.Error(err)\n\t}\n\n\tb.StartTimer() // 重新开始时间\n\n\tfor i := 0; i < b.N; i++ {\n\t\tGenShortId()\n\t}\n}\n')])])]),o("p",[o("strong",[t._v("说明")])]),t._v(" "),o("ul",[o("li",[t._v("性能测试函数名必须以 Benchmark 开头，如 BenchmarkXxx 或 Benchmark_xxx")]),t._v(" "),o("li",[o("code",[t._v("go test")]),t._v(" 默认不会执行压力测试函数，需要通过指定参数 "),o("code",[t._v("-test.bench")]),t._v(" 来运行压力测试函数，"),o("code",[t._v("-test.bench")]),t._v(" 后跟正则表达式，如 "),o("code",[t._v('go test -test.bench=".*"')]),t._v(" 表示执行所有的压力测试函数")]),t._v(" "),o("li",[t._v("在压力测试中，需要在循环体中指定 "),o("code",[t._v("testing.B.N")]),t._v(" 来循环执行压力测试代码")])]),t._v(" "),o("p",[o("strong",[t._v("执行压力测试")])]),t._v(" "),o("p",[t._v("在 "),o("code",[t._v("util")]),t._v(" 目录下执行命令 "),o("code",[t._v('go test -test.bench=".*"')]),t._v("：")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('$ go test -test.bench=".*"\ngoos: linux\ngoarch: amd64\npkg: apiserver/util\nBenchmarkGenShortId-2                \t  500000\t      2291 ns/op\nBenchmarkGenShortIdTimeConsuming-2   \t  500000\t      2333 ns/op\nPASS\nok  \tapiserver/util\t2.373s\n')])])]),o("ul",[o("li",[t._v("上面的结果显示，我们没有执行任何 TestXXX 的单元测试函数，只执行了压力测试函数")]),t._v(" "),o("li",[t._v("第一条显示了 "),o("code",[t._v("BenchmarkGenShortId")]),t._v(" 执行了 500000 次，每次的执行平均时间是 2291 纳秒")]),t._v(" "),o("li",[t._v("第二条显示了 "),o("code",[t._v("BenchmarkGenShortIdTimeConsuming")]),t._v(" 执行了 500000，每次的平均执行时间是 2333 纳秒")]),t._v(" "),o("li",[t._v("最后一条显示总执行时间")])]),t._v(" "),o("blockquote",[o("p",[o("code",[t._v("BenchmarkGenShortIdTimeConsuming")]),t._v(" 比 "),o("code",[t._v("BenchmarkGenShortId")]),t._v(" 多了两个调用 "),o("code",[t._v("b.StopTimer()")]),t._v(" 和 "),o("code",[t._v("b.StartTimer()")]),t._v("。")]),t._v(" "),o("ul",[o("li",[o("code",[t._v("b.StopTimer()")]),t._v("：调用该函数停止压力测试的时间计数")]),t._v(" "),o("li",[o("code",[t._v("b.StartTimer()")]),t._v("：重新开始时间")])]),t._v(" "),o("p",[t._v("在 "),o("code",[t._v("b.StopTimer()")]),t._v(" 和 "),o("code",[t._v("b.StartTimer()")]),t._v(" 之间可以做一些准备工作，这样这些时间不影响我们测试函数本身的性能。")])]),t._v(" "),o("h2",{attrs:{id:"查看性能并生成函数调用图"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#查看性能并生成函数调用图"}},[t._v("#")]),t._v(" 查看性能并生成函数调用图")]),t._v(" "),o("ol",[o("li",[t._v("执行命令：")])]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('$ go test -bench=".*" -cpuprofile=cpu.profile ./util\n')])])]),o("p",[t._v("上述命令会在当前目录下生成 "),o("code",[t._v("cpu.profile")]),t._v(" 和 "),o("code",[t._v("util.test")]),t._v(" 文件。")]),t._v(" "),o("ol",[o("li",[t._v("执行 "),o("code",[t._v("go tool pprof util.test cpu.profile")]),t._v(" 查看性能（进入交互界面后执行 "),o("code",[t._v("top")]),t._v(" 指令）：")])]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('$ go tool pprof util.test cpu.profile\n\nFile: util.test\nType: cpu\nTime: Jun 5, 2018 at 7:28pm (CST)\nDuration: 4.93s, Total samples = 4.97s (100.78%)\nEntering interactive mode (type "help" for commands, "o" for options)\n(pprof) top\nShowing nodes accounting for 3480ms, 70.02% of 4970ms total\nDropped 34 nodes (cum <= 24.85ms)\nShowing top 10 nodes out of 75\n      flat  flat%   sum%        cum   cum%\n    1890ms 38.03% 38.03%     1900ms 38.23%  syscall.Syscall\n     500ms 10.06% 48.09%      620ms 12.47%  runtime.mallocgc\n     240ms  4.83% 52.92%     3700ms 74.45%  vendor/github.com/teris-io/shortid.(*Abc).Encode\n     150ms  3.02% 55.94%      200ms  4.02%  runtime.scanobject\n     140ms  2.82% 58.75%      640ms 12.88%  runtime.makeslice\n     140ms  2.82% 61.57%      280ms  5.63%  runtime.slicerunetostring\n     120ms  2.41% 63.98%      120ms  2.41%  math.Log\n     110ms  2.21% 66.20%     2430ms 48.89%  io.ReadAtLeast\n     110ms  2.21% 68.41%      110ms  2.21%  runtime._ExternalCode\n      80ms  1.61% 70.02%      140ms  2.82%  runtime.deferreturn\n(pprof) \n')])])]),o("p",[t._v("pprof 程序中最重要的命令就是 "),o("code",[t._v("topN")]),t._v("，此命令用于显示 profile 文件中的最靠前的 N 个样本（sample），它的输出格式各字段的含义依次是：")]),t._v(" "),o("ol",[o("li",[t._v("采样点落在该函数中的总时间")]),t._v(" "),o("li",[t._v("采样点落在该函数中的百分比")]),t._v(" "),o("li",[t._v("上一项的累积百分比")]),t._v(" "),o("li",[t._v("采样点落在该函数，以及被它调用的函数中的总时间")]),t._v(" "),o("li",[t._v("采样点落在该函数，以及被它调用的函数中的总次数百分比")]),t._v(" "),o("li",[t._v("函数名")])]),t._v(" "),o("p",[t._v("此外，在 pprof 程序中还可以使用 "),o("code",[t._v("svg")]),t._v(" 来生成函数调用关系图（需要安装 graphviz），例如：")]),t._v(" "),o("p",[t._v("该调用图生成方法如下：")]),t._v(" "),o("ol",[o("li",[t._v("安装 "),o("code",[t._v("graphviz")]),t._v(" 命令")])]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("# yum -y install graphviz.x86_64\n")])])]),o("ol",[o("li",[t._v("执行 "),o("code",[t._v("go tool pprof")]),t._v(" 生成 svg 图：")])]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('$ go tool pprof util.test cpu.profile\nFile: util.test\nType: cpu\nTime: Jun 5, 2018 at 7:28pm (CST)\nDuration: 4.93s, Total samples = 4.97s (100.78%)\nEntering interactive mode (type "help" for commands, "o" for options)\n(pprof) svg\nGenerating report in profile001.svg\n')])])]),o("p",[o("code",[t._v("svg")]),t._v(" 子命令会提示在 "),o("code",[t._v("$GOPATH/src")]),t._v(" 目录下生成了一个 svg 文件 "),o("code",[t._v("profile001.svg")]),t._v("。")]),t._v(" "),o("blockquote",[o("p",[t._v("关于如何看懂 pprof 信息，请参考官方文档 "),o("a",{attrs:{href:"https://blog.golang.org/profiling-go-programs",target:"_blank",rel:"noopener noreferrer"}},[t._v("Profiling Go Programs"),o("OutboundLink")],1),t._v("。")]),t._v(" "),o("p",[t._v("关于如何做性能分析，请参考郝林大神的文章 "),o("a",{attrs:{href:"https://github.com/hyper0x/go_command_tutorial/blob/master/0.12.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("go tool pprof"),o("OutboundLink")],1),t._v("。")])]),t._v(" "),o("h2",{attrs:{id:"测试覆盖率"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#测试覆盖率"}},[t._v("#")]),t._v(" 测试覆盖率")]),t._v(" "),o("p",[t._v("我们写单元测试的时候应该想得很全面，能够覆盖到所有的测试用例，但有时也会漏过一些 case，go 提供了 cover 工具来统计测试覆盖率。")]),t._v(" "),o("p",[o("code",[t._v("go test -coverprofile=cover.out")]),t._v("：在测试文件目录下运行测试并统计测试覆盖率")]),t._v(" "),o("p",[o("code",[t._v("go tool cover -func=cover.out")]),t._v("：分析覆盖率文件，可以看出哪些函数没有测试，哪些函数内部的分支没有测试完全，cover 工具会通过执行代码的行数与总行数的比例表示出覆盖率")]),t._v(" "),o("p",[o("strong",[t._v("测试覆盖率")])]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("$ go test -coverprofile=cover.out\nPASS\ncoverage: 14.3% of statements\nok  \tapiserver/util\t0.006s\n[api@centos util]$ go tool cover -func=cover.out\napiserver/util/util.go:8:\tGenShortId\t100.0%\napiserver/util/util.go:12:\tGetReqID\t0.0%\ntotal:\t\t\t\t(statements)\t14.3%\n")])])]),o("p",[t._v("可以看到 "),o("code",[t._v("GenShortId()")]),t._v(" 函数测试覆盖率为 100%，"),o("code",[t._v("GetReqID()")]),t._v(" 测试覆盖率为 0%。")]),t._v(" "),o("h2",{attrs:{id:"小结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),o("p",[t._v("本小节简单介绍了如何用 testing 包做单元和性能测试。在实际的开发中，要养成编写单元测试代码的好习惯，在项目上线前，最好对一些业务逻辑比较复杂的函数做一些性能测试，提前发现性能问题。")]),t._v(" "),o("p",[t._v("至于怎么去分析性能，比如查找耗时最久的函数等，笔者链接了郝林大神专业的分析方法（"),o("a",{attrs:{href:"https://github.com/hyper0x/go_command_tutorial/blob/master/0.12.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("go tool pprof"),o("OutboundLink")],1),t._v("），更深的分析技巧需要读者在实际开发中自己去探索。")])])}),[],!1,null,null,null);e.default=s.exports}}]);