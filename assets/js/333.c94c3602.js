(window.webpackJsonp=window.webpackJsonp||[]).push([[333],{770:function(e,t,n){"use strict";n.r(t);var o=n(44),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Go scheduler 的职责就是将所有处于 runnable 的 goroutines 均匀分布到在 P 上运行的 M。")]),e._v(" "),n("p",[e._v("当一个 P 发现自己的 LRQ 已经没有 G 时，会从其他 P “偷” 一些 G 来运行。看看这是什么精神！自己的工作做完了，为了全局的利益，主动为别人分担。这被称为 "),n("code",[e._v("Work-stealing")]),e._v("，Go 从 1.1 开始实现。")]),e._v(" "),n("p",[e._v("Go scheduler 使用 M:N 模型，在任一时刻，M 个 goroutines（G） 要分配到 N 个内核线程（M），这些 M 跑在个数最多为 GOMAXPROCS 的逻辑处理器（P）上。每个 M 必须依附于一个 P，每个 P 在同一时刻只能运行一个 M。如果 P 上的 M 阻塞了，那它就需要其他的 M 来运行 P 的 LRQ 里的 goroutines。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/62031928-02a8f880-b21b-11e9-96a9-96820452463e.png",alt:"GPM relatioship"}})]),e._v(" "),n("p",[e._v("个人感觉，上面这张图比常见的那些用三角形表示 M，圆形表示 G，矩形表示 P 的那些图更生动形象。")]),e._v(" "),n("p",[e._v("实际上，Go scheduler 每一轮调度要做的工作就是找到处于 runnable 的 goroutines，并执行它。找的顺序如下：")]),e._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("runtime.schedule() {\n    // only 1/61 of the time, check the global runnable queue for a G.\n    // if not found, check the local queue.\n    // if not found,\n    //     try to steal from other Ps.\n    //     if not, check the global runnable queue.\n    //     if not found, poll network.\n}\n")])])]),n("p",[e._v("找到一个可执行的 goroutine 后，就会一直执行下去，直到被阻塞。")]),e._v(" "),n("p",[e._v("当 P2 上的一个 G 执行结束，它就会去 LRQ 获取下一个 G 来执行。如果 LRQ 已经空了，就是说本地可运行队列已经没有 G 需要执行，并且这时 GRQ 也没有 G 了。这时，P2 会随机选择一个 P（称为 P1），P2 会从 P1 的 LRQ “偷”过来一半的 G。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/62033338-4ea96c80-b21e-11e9-9167-98767c03d2d9.png",alt:"Work Stealing"}})]),e._v(" "),n("p",[e._v("这样做的好处是，有更多的 P 可以一起工作，加速执行完所有的 G。")])])}),[],!1,null,null,null);t.default=r.exports}}]);