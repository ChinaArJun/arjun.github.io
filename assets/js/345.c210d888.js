(window.webpackJsonp=window.webpackJsonp||[]).push([[345],{783:function(t,a,s){"use strict";s.r(a);var n=s(44),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("从语法上看，是可以的。Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 "),s("code",[t._v("==")]),t._v(" 和 "),s("code",[t._v("!=")]),t._v(" 操作符，"),s("code",[t._v("k1 == k2")]),t._v(" 时，可认为 k1 和 k2 是同一个 key。如果是结构体，只有 hash 后的值相等以及字面值相等，才被认为是相同的 key。很多字面值相等的，hash出来的值不一定相等，比如引用。")]),t._v(" "),s("p",[t._v("顺便说一句，任何类型都可以作为 value，包括 map 类型。")]),t._v(" "),s("p",[t._v("来看个例子：")]),t._v(" "),s("div",{staticClass:"language-golang extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('func main() {\n\tm := make(map[float64]int)\n\tm[1.4] = 1\n\tm[2.4] = 2\n\tm[math.NaN()] = 3\n\tm[math.NaN()] = 3\n\n\tfor k, v := range m {\n\t\tfmt.Printf("[%v, %d] ", k, v)\n\t}\n\n\tfmt.Printf("\\nk: %v, v: %d\\n", math.NaN(), m[math.NaN()])\n\tfmt.Printf("k: %v, v: %d\\n", 2.400000000001, m[2.400000000001])\n\tfmt.Printf("k: %v, v: %d\\n", 2.4000000000000000000000001, m[2.4000000000000000000000001])\n\n\tfmt.Println(math.NaN() == math.NaN())\n}\n')])])]),s("p",[t._v("程序的输出：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.4")]),t._v(", "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NaN, "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NaN, "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.4")]),t._v(", "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" \nk: NaN, v: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\nk: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.400000000001")]),t._v(", v: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\nk: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.4")]),t._v(", v: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n")])])]),s("p",[t._v("例子中定义了一个 key 类型是 float 型的 map，并向其中插入了 4 个 key：1.4， 2.4， NAN，NAN。")]),t._v(" "),s("p",[t._v("打印的时候也打印出了 4 个 key，如果你知道 NAN != NAN，也就不奇怪了。因为他们比较的结果不相等，自然，在 map 看来就是两个不同的 key 了。")]),t._v(" "),s("p",[t._v("接着，我们查询了几个 key，发现 NAN 不存在，2.400000000001 也不存在，而 2.4000000000000000000000001 却存在。")]),t._v(" "),s("p",[t._v("有点诡异，不是吗？")]),t._v(" "),s("p",[t._v("接着，我通过汇编发现了如下的事实：")]),t._v(" "),s("p",[t._v("当用 float64 作为 key 的时候，先要将其转成 unit64 类型，再插入 key 中。")]),t._v(" "),s("p",[t._v("具体是通过 "),s("code",[t._v("Float64frombits")]),t._v(" 函数完成：")]),t._v(" "),s("div",{staticClass:"language-golang extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// Float64frombits returns the floating point number corresponding\n// the IEEE 754 binary representation b.\nfunc Float64frombits(b uint64) float64 { return *(*float64)(unsafe.Pointer(&b)) }\n")])])]),s("p",[t._v("也就是将浮点数表示成 IEEE 754 规定的格式。如赋值语句：")]),t._v(" "),s("div",{staticClass:"language-asm extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('0x00bd 00189 (test18.go:9)      LEAQ    "".statictmp_0(SB), DX\n0x00c4 00196 (test18.go:9)      MOVQ    DX, 16(SP)\n0x00c9 00201 (test18.go:9)      PCDATA  $0, $2\n0x00c9 00201 (test18.go:9)      CALL    runtime.mapassign(SB)\n')])])]),s("p",[s("code",[t._v('"".statictmp_0(SB)')]),t._v(" 变量是这样的：")]),t._v(" "),s("div",{staticClass:"language-asm extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('"".statictmp_0 SRODATA size=8\n        0x0000 33 33 33 33 33 33 03 40\n"".statictmp_1 SRODATA size=8\n        0x0000 ff 3b 33 33 33 33 03 40\n"".statictmp_2 SRODATA size=8\n        0x0000 33 33 33 33 33 33 03 40\n')])])]),s("p",[t._v("我们再来输出点东西：")]),t._v(" "),s("div",{staticClass:"language-golang extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('package main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc main() {\n\tm := make(map[float64]int)\n\tm[2.4] = 2\n\n    fmt.Println(math.Float64bits(2.4))\n\tfmt.Println(math.Float64bits(2.400000000001))\n\tfmt.Println(math.Float64bits(2.4000000000000000000000001))\n}\n')])])]),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4612586738352862003")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4612586738352864255")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4612586738352862003")]),t._v("\n")])])]),s("p",[t._v("转成十六进制为：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("0x4003333333333333\n0x4003333333333BFF\n0x4003333333333333\n")])])]),s("p",[t._v("和前面的 "),s("code",[t._v('"".statictmp_0')]),t._v(" 比较一下，很清晰了吧。"),s("code",[t._v("2.4")]),t._v(" 和 "),s("code",[t._v("2.4000000000000000000000001")]),t._v(" 经过 "),s("code",[t._v("math.Float64bits()")]),t._v(" 函数转换后的结果是一样的。自然，二者在 map 看来，就是同一个 key 了。")]),t._v(" "),s("p",[t._v("再来看一下 NAN（not a number）：")]),t._v(" "),s("div",{staticClass:"language-golang extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// NaN returns an IEEE 754 ``not-a-number'' value.\nfunc NaN() float64 { return Float64frombits(uvnan) }\n")])])]),s("p",[t._v("uvan 的定义为：")]),t._v(" "),s("div",{staticClass:"language-golang extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("uvnan    = 0x7FF8000000000001\n")])])]),s("p",[t._v("NAN() 直接调用 "),s("code",[t._v("Float64frombits")]),t._v("，传入写死的 const 型变量 "),s("code",[t._v("0x7FF8000000000001")]),t._v("，得到 NAN 型值。既然，NAN 是从一个常量解析得来的，为什么插入 map 时，会被认为是不同的 key？")]),t._v(" "),s("p",[t._v("这是由类型的哈希函数决定的，例如，对于 64 位的浮点数，它的哈希函数如下：")]),t._v(" "),s("div",{staticClass:"language-golang extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("func f64hash(p unsafe.Pointer, h uintptr) uintptr {\n\tf := *(*float64)(p)\n\tswitch {\n\tcase f == 0:\n\t\treturn c1 * (c0 ^ h) // +0, -0\n\tcase f != f:\n\t\treturn c1 * (c0 ^ h ^ uintptr(fastrand())) // any kind of NaN\n\tdefault:\n\t\treturn memhash(p, h, 8)\n\t}\n}\n")])])]),s("p",[t._v("第二个 case，"),s("code",[t._v("f != f")]),t._v(" 就是针对 "),s("code",[t._v("NAN")]),t._v("，这里会再加一个随机数。")]),t._v(" "),s("p",[t._v("这样，所有的谜题都解开了。")]),t._v(" "),s("p",[t._v("由于 NAN 的特性：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("NAN "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" NAN\nhash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NAN"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NAN"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("因此向 map 中查找的 key 为 NAN 时，什么也查不到；如果向其中增加了 4 次 NAN，遍历会得到 4 个 NAN。")]),t._v(" "),s("p",[t._v("最后说结论：float 型可以作为 key，但是由于精度的问题，会导致一些诡异的问题，慎用之。")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("关于当 key 是引用类型时，判断两个 key 是否相等，需要 hash 后的值相等并且 key 的字面量相等。由 @WuMingyu 补充的例子：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("TestT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("testing"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" S "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tID\t"),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\ts1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" S"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("ID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\ts2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" S"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("ID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("S"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\th"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("s1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n\tt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("s1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("s2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" s2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("test output:")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" RUN   TestT\n--- PASS: TestT "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(".00s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    endpoint_test.go:74: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    endpoint_test.go:75: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    endpoint_test.go:76: "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\nPASS\n\nProcess finished with "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("exit")]),t._v(" code "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);