(window.webpackJsonp=window.webpackJsonp||[]).push([[361],{799:function(t,e,n){"use strict";n.r(e);var a=n(44),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("Go 语言中提供了一个函数可以完成此项功能：")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func DeepEqual(x, y interface{}) bool\n")])])]),n("p",[n("code",[t._v("DeepEqual")]),t._v(" 函数的参数是两个 "),n("code",[t._v("interface")]),t._v("，实际上也就是可以输入任意类型，输出 true 或者 flase 表示输入的两个变量是否是“深度”相等。")]),t._v(" "),n("p",[t._v("先明白一点，如果是不同的类型，即使是底层类型相同，相应的值也相同，那么两者也不是“深度”相等。")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("type MyInt int\ntype YourInt int\n\nfunc main() {\n\tm := MyInt(1)\n\ty := YourInt(1)\n\n\tfmt.Println(reflect.DeepEqual(m, y)) // false\n}\n")])])]),n("p",[t._v("上面的代码中，m, y 底层都是 int，而且值都是 1，但是两者静态类型不同，前者是 "),n("code",[t._v("MyInt")]),t._v("，后者是 "),n("code",[t._v("YourInt")]),t._v("，因此两者不是“深度”相等。")]),t._v(" "),n("p",[t._v("在源码里，有对 DeepEqual 函数的非常清楚地注释，列举了不同类型，DeepEqual 的比较情形，这里做一个总结：")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("类型")]),t._v(" "),n("th",[t._v("深度相等情形")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("Array")]),t._v(" "),n("td",[t._v("相同索引处的元素“深度”相等")])]),t._v(" "),n("tr",[n("td",[t._v("Struct")]),t._v(" "),n("td",[t._v("相应字段，包含导出和不导出，“深度”相等")])]),t._v(" "),n("tr",[n("td",[t._v("Func")]),t._v(" "),n("td",[t._v("只有两者都是 nil 时")])]),t._v(" "),n("tr",[n("td",[t._v("Interface")]),t._v(" "),n("td",[t._v("两者存储的具体值“深度”相等")])]),t._v(" "),n("tr",[n("td",[t._v("Map")]),t._v(" "),n("td",[t._v("1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等")])]),t._v(" "),n("tr",[n("td",[t._v("Pointer")]),t._v(" "),n("td",[t._v("1、使用 == 比较的结果相等；2、指向的实体“深度”相等")])]),t._v(" "),n("tr",[n("td",[t._v("Slice")]),t._v(" "),n("td",[t._v("1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &x[0] == &y[0] 或者 相同索引处的元素“深度”相等")])]),t._v(" "),n("tr",[n("td",[t._v("numbers, bools, strings, and channels")]),t._v(" "),n("td",[t._v("使用 == 比较的结果为真")])])])]),t._v(" "),n("p",[t._v("一般情况下，DeepEqual 的实现只需要递归地调用 == 就可以比较两个变量是否是真的“深度”相等。")]),t._v(" "),n("p",[t._v("但是，有一些异常情况：比如 func 类型是不可比较的类型，只有在两个 func 类型都是 nil 的情况下，才是“深度”相等；float 类型，由于精度的原因，也是不能使用 == 比较的；包含 func 类型或者 float 类型的 struct， interface， array 等。")]),t._v(" "),n("p",[t._v("对于指针而言，当两个值相等的指针就是“深度”相等，因为两者指向的内容是相等的，即使两者指向的是 func 类型或者 float 类型，这种情况下不关心指针所指向的内容。")]),t._v(" "),n("p",[t._v("同样，对于指向相同 slice， map 的两个变量也是“深度”相等的，不关心 slice， map 具体的内容。")]),t._v(" "),n("p",[t._v("对于“有环”的类型，比如循环链表，比较两者是否“深度”相等的过程中，需要对已比较的内容作一个标记，一旦发现两个指针之前比较过，立即停止比较，并判定二者是深度相等的。这样做的原因是，及时停止比较，避免陷入无限循环。")]),t._v(" "),n("p",[t._v("来看源码：")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func DeepEqual(x, y interface{}) bool {\n\tif x == nil || y == nil {\n\t\treturn x == y\n\t}\n\tv1 := ValueOf(x)\n\tv2 := ValueOf(y)\n\tif v1.Type() != v2.Type() {\n\t\treturn false\n\t}\n\treturn deepValueEqual(v1, v2, make(map[visit]bool), 0)\n}\n")])])]),n("p",[t._v("首先查看两者是否有一个是 nil 的情况，这种情况下，只有两者都是 nil，函数才会返回 true")]),t._v(" "),n("p",[t._v("接着，使用反射，获取x，y 的反射对象，并且立即比较两者的类型，根据前面的内容，这里实际上是动态类型，如果类型不同，直接返回 false。")]),t._v(" "),n("p",[t._v("最后，最核心的内容在子函数 "),n("code",[t._v("deepValueEqual")]),t._v(" 中。")]),t._v(" "),n("p",[t._v("代码比较长，思路却比较简单清晰：核心是一个 switch 语句，识别输入参数的不同类型，分别递归调用 deepValueEqual 函数，一直递归到最基本的数据类型，比较 int，string 等可以直接得出 true 或者 false，再一层层地返回，最终得到“深度”相等的比较结果。")]),t._v(" "),n("p",[t._v("实际上，各种类型的比较套路比较相似，这里就直接节选一个稍微复杂一点的 "),n("code",[t._v("map")]),t._v(" 类型的比较：")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// deepValueEqual 函数\n// ……\n\ncase Map:\n\tif v1.IsNil() != v2.IsNil() {\n\t\treturn false\n\t}\n\tif v1.Len() != v2.Len() {\n\t\treturn false\n\t}\n\tif v1.Pointer() == v2.Pointer() {\n\t\treturn true\n\t}\n\tfor _, k := range v1.MapKeys() {\n\t\tval1 := v1.MapIndex(k)\n\t\tval2 := v2.MapIndex(k)\n\t\tif !val1.IsValid() || !val2.IsValid() || !deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+1) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n\t\n// ……\t\n")])])]),n("p",[t._v("和前文总结的表格里，比较 map 是否相等的思路比较一致，也不需要多说什么。说明一点，"),n("code",[t._v("visited")]),t._v(" 是一个 map，记录递归过程中，比较过的“对”：")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("type visit struct {\n\ta1  unsafe.Pointer\n\ta2  unsafe.Pointer\n\ttyp Type\n}\n\nmap[visit]bool\n")])])]),n("p",[t._v("比较过程中，一旦发现比较的“对”，已经在 map 里出现过的话，直接判定“深度”比较结果的是 "),n("code",[t._v("true")]),t._v("。")])])}),[],!1,null,null,null);e.default=v.exports}}]);