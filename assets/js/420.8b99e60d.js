(window.webpackJsonp=window.webpackJsonp||[]).push([[420],{859:function(t,n,e){"use strict";e.r(n);var s=e(44),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("在 "),e("code",[t._v("runtime.main()")]),t._v(" 函数中，执行 "),e("code",[t._v("runtime_init()")]),t._v(" 前，会启动一个 sysmon 的监控线程，执行后台监控任务：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("systemstack(func() {\n\t// 创建监控线程，该线程独立于调度器，不需要跟 p 关联即可运行\n\tnewm(sysmon, nil)\n})\n")])])]),e("p",[e("code",[t._v("sysmon")]),t._v(" 函数不依赖 P 直接执行，通过 newm 函数创建一个工作线程：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func newm(fn func(), _p_ *p) {\n\t// 创建 m 对象\n\tmp := allocm(_p_, fn)\n\t// 暂存 m\n\tmp.nextp.set(_p_)\n\tmp.sigmask = initSigmask\n\t\n\t// ……………………\n\t\n\texecLock.rlock() // Prevent process clone.\n\t// 创建系统线程\n\tnewosproc(mp, unsafe.Pointer(mp.g0.stack.hi))\n\texecLock.runlock()\n}\n")])])]),e("p",[t._v("先调用 "),e("code",[t._v("allocm")]),t._v(" 在堆上创建一个 m，接着调用 "),e("code",[t._v("newosproc")]),t._v(" 函数启动一个工作线程：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// src/runtime/os_linux.go\n//go:nowritebarrier\nfunc newosproc(mp *m, stk unsafe.Pointer) {\n\t// ……………………\n\n\tret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))\n\n\t// ……………………\n}\n")])])]),e("p",[t._v("核心就是调用 clone 函数创建系统线程，新线程从 mstart 函数开始执行。"),e("code",[t._v("clone")]),t._v(" 函数由汇编语言实现：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));\nTEXT runtime·clone(SB),NOSPLIT,$0\n    // 准备系统调用的参数\n    MOVL\tflags+0(FP), DI\n    MOVQ\tstk+8(FP), SI\n    MOVQ\t$0, DX\n\tMOVQ\t$0, R10\n\n\t// 将 mp，gp，fn 拷贝到寄存器，对子线程可见\n\tMOVQ\tmp+16(FP), R8\n\tMOVQ\tgp+24(FP), R9\n\tMOVQ\tfn+32(FP), R12\n\n    // 系统调用 clone\n\tMOVL\t$56, AX\n\tSYSCALL\n\n\t// In parent, return.\n\tCMPQ\tAX, $0\n\tJEQ\t3(PC)\n\t// 父线程，返回\n\tMOVL\tAX, ret+40(FP)\n\tRET\n\n\t// In child, on new stack.\n\t// 在子线程中。设置 CPU 栈顶寄存器指向子线程的栈顶\n\tMOVQ\tSI, SP\n\n\t// If g or m are nil, skip Go-related setup.\n\tCMPQ\tR8, $0    // m\n    JEQ\tnog\n    CMPQ\tR9, $0    // g\n\tJEQ\tnog\n\n\t// Initialize m->procid to Linux tid\n\t// 通过 gettid 系统调用获取线程 ID（tid）\n\tMOVL\t$186, AX\t// gettid\n\tSYSCALL\n\t// 设置 m.procid = tid\n\tMOVQ\tAX, m_procid(R8)\n\n\t// Set FS to point at m->tls.\n\t// 新线程刚刚创建出来，还未设置线程本地存储，即 m 结构体对象还未与工作线程关联起来，\n    // 下面的指令负责设置新线程的 TLS，把 m 对象和工作线程关联起来\n\tLEAQ\tm_tls(R8), DI\n\tCALL\truntime·settls(SB)\n\n\t// In child, set up new stack\n\tget_tls(CX)\n\tMOVQ\tR8, g_m(R9) // g.m = m\n\tMOVQ\tR9, g(CX) // tls.g = &m.g0\n\tCALL\truntime·stackcheck(SB)\n\nnog:\n\t// Call fn\n\t// 调用 mstart 函数。永不返回\n\tCALL\tR12\n\n\t// It shouldn't return. If it does, exit that thread.\n\tMOVL\t$111, DI\n    MOVL\t$60, AX\n\tSYSCALL\n\tJMP\t-3(PC)\t// keep exiting\n")])])]),e("p",[t._v("先是为 clone 系统调用准备参数，参数通过寄存器传递。第一个参数指定内核创建线程时的选项，第二个参数指定新线程应该使用的栈，这两个参数都是通过 newosproc 函数传递进来的。")]),t._v(" "),e("p",[t._v("接着将 m, g0, fn 分别保存到寄存器中，待子线程创建好后再拿出来使用。因为这些参数此时是在父线程的栈上，若不保存到寄存器中，子线程就取不出来了。")]),t._v(" "),e("blockquote",[e("p",[t._v("这个几个参数保存在父线程的寄存器中，创建子线程时，操作系统内核会把父线程所有的寄存器帮我们复制一份给子线程，所以当子线程开始运行时就能拿到父线程保存在寄存器中的值，从而拿到这几个参数。")])]),t._v(" "),e("p",[t._v("之后，调用 clone 系统调用，内核帮我们创建出了一个子线程。相当于原来的一个执行分支现在变成了两个执行分支，于是会有两个返回。这和著名的 fork 系统调用类似，根据返回值来判断现在是处于父线程还是子线程。")]),t._v(" "),e("p",[t._v("如果是父线程，就直接返回了。如果是子线程，接着还要执行一堆操作，例如设置 tls，设置 m.procid 等等。")]),t._v(" "),e("p",[t._v("最后执行 mstart 函数，这是在 newosproc 函数传递进来的。"),e("code",[t._v("mstart")]),t._v(" 函数再调用 "),e("code",[t._v("mstart1")]),t._v("，在 "),e("code",[t._v("mstart1")]),t._v(" 里会执行这一行：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 执行启动函数。初始化过程中，fn == nil\nif fn := _g_.m.mstartfn; fn != nil {\n\tfn()\n}\n")])])]),e("p",[t._v("之前我们在讲初始化的时候，这里的 fn 是空，会跳过的。但在这里，fn 就是最开始在 "),e("code",[t._v("runtime.main")]),t._v(" 里设置的 "),e("code",[t._v("sysmon")]),t._v(" 函数，因此这里会执行 "),e("code",[t._v("sysmon")]),t._v("，而它又是一个无限循环，永不返回。")]),t._v(" "),e("p",[t._v("所以，这里不会执行到 mstart1 函数后面的 schedule 函数，也就不会进入 schedule 循环。因此这是一个不用和 p 结合的 m，它直接在后台执行，默默地执行监控任务。")]),t._v(" "),e("p",[t._v("接下来，我们就来看 "),e("code",[t._v("sysmon")]),t._v(" 函数到底做了什么？")]),t._v(" "),e("blockquote",[e("p",[e("code",[t._v("sysmon")]),t._v(" 执行一个无限循环，一开始每次循环休眠 20us，之后（1 ms 后）每次休眠时间倍增，最终每一轮都会休眠 10ms。")])]),t._v(" "),e("blockquote",[e("p",[e("code",[t._v("sysmon")]),t._v(" 中会进行 netpool（获取 fd 事件）、retake（抢占）、forcegc（按时间强制执行 gc），scavenge heap（释放自由列表中多余的项减少内存占用）等处理。")])]),t._v(" "),e("p",[t._v("和调度相关的，我们只关心 retake 函数：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func retake(now int64) uint32 {\n\tn := 0\n\t// 遍历所有的 p\n\tfor i := int32(0); i < gomaxprocs; i++ {\n\t\t_p_ := allp[i]\n\t\tif _p_ == nil {\n\t\t\tcontinue\n\t\t}\n\t\t// 用于 sysmon 线程记录被监控 p 的系统调用时间和运行时间\n\t\tpd := &_p_.sysmontick\n\t\t// p 的状态\n\t\ts := _p_.status\n\t\tif s == _Psyscall {\n\t\t\t// P 处于系统调用之中，需要检查是否需要抢占\n\t\t\t// Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us).\n\t\t\t// _p_.syscalltick 用于记录系统调用的次数，在完成系统调用之后加 1\n\t\t\tt := int64(_p_.syscalltick)\n\t\t\tif int64(pd.syscalltick) != t {\n\t\t\t\t// pd.syscalltick != _p_.syscalltick，说明已经不是上次观察到的系统调用了，\n\t\t\t\t// 而是另外一次系统调用，所以需要重新记录 tick 和 when 值\n\t\t\t\tpd.syscalltick = uint32(t)\n\t\t\t\tpd.syscallwhen = now\n\t\t\t\tcontinue\n\t\t\t}\n\t\n\t\t\t// 只要满足下面三个条件中的任意一个，则抢占该 p，否则不抢占\n\t\t\t// 1. p 的运行队列里面有等待运行的 goroutine\n\t\t\t// 2. 没有无所事事的 p\n\t\t\t// 3. 从上一次监控线程观察到 p 对应的 m 处于系统调用之中到现在已经超过 10 毫秒\n\t\t\tif runqempty(_p_) && atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) > 0 && pd.syscallwhen+10*1000*1000 > now {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\tincidlelocked(-1)\n\t\t\tif atomic.Cas(&_p_.status, s, _Pidle) {\n\t\t\t\t// ……………………\n\t\t\t\tn++\n\t\t\t\t_p_.syscalltick++\n\t\t\t\t// 寻找一新的 m 接管 p\n\t\t\t\thandoffp(_p_)\n\t\t\t}\n\t\t\tincidlelocked(1)\n\t\t} else if s == _Prunning {\n\t\t\t// P 处于运行状态，检查是否运行得太久了\n\t\t\t// Preempt G if it's running for too long.\n\t\t\t// 每发生一次调度，调度器 ++ 该值\n\t\t\tt := int64(_p_.schedtick)\n\t\t\tif int64(pd.schedtick) != t {\n\t\t\t\tpd.schedtick = uint32(t)\n\t\t\t\tpd.schedwhen = now\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t//pd.schedtick == t 说明(pd.schedwhen ～ now)这段时间未发生过调度\n\t\t\t// 这段时间是同一个goroutine一直在运行，检查是否连续运行超过了 10 毫秒\n\t\t\tif pd.schedwhen+forcePreemptNS > now {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// 连续运行超过 10 毫秒了，发起抢占请求\n\t\t\tpreemptone(_p_)\n\t\t}\n\t}\n\treturn uint32(n)\n}\n")])])]),e("p",[t._v("从代码来看，主要会对处于 "),e("code",[t._v("_Psyscall")]),t._v(" 和 "),e("code",[t._v("_Prunning")]),t._v(" 状态的 p 进行抢占。")]),t._v(" "),e("h1",{attrs:{id:"抢占进行系统调用的-p"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抢占进行系统调用的-p"}},[t._v("#")]),t._v(" 抢占进行系统调用的 P")]),t._v(" "),e("p",[t._v("当 P 处于 "),e("code",[t._v("_Psyscall")]),t._v(" 状态时，表明对应的 goroutine 正在进行系统调用。如果抢占 p，需要满足几个条件：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("p 的本地运行队列里面有等待运行的 goroutine。这时 p 绑定的 g 正在进行系统调用，无法去执行其他的 g，因此需要接管 p 来执行其他的 g。")])]),t._v(" "),e("li",[e("p",[t._v("没有“无所事事”的 p。"),e("code",[t._v("sched.nmspinning")]),t._v(" 和 "),e("code",[t._v("sched.npidle")]),t._v(" 都为 0，这就意味着没有“找工作”的 m，也没有空闲的 p，大家都在“忙”，可能有很多工作要做。因此要抢占当前的 p，让它来承担一部分工作。")])]),t._v(" "),e("li",[e("p",[t._v("从上一次监控线程观察到 p 对应的 m 处于系统调用之中到现在已经超过 10 毫秒。这说明系统调用所花费的时间较长，需要对其进行抢占，以此来使得 "),e("code",[t._v("retake")]),t._v(" 函数返回值不为 0，这样，会保持 sysmon 线程 20 us 的检查周期，提高 sysmon 监控的实时性。")])])]),t._v(" "),e("p",[t._v("注意，原代码是用的三个与条件，三者都要满足才会执行下面的 continue，也就是不进行抢占。因此要想进行抢占的话，只需要三个条件有一个不满足就行了。于是就有了上述三种情况。")]),t._v(" "),e("p",[t._v("确定要抢占当前 p 后，先使用原子操作将 p 的状态修改为 "),e("code",[t._v("_Pidle")]),t._v("，最后调用 "),e("code",[t._v("handoffp")]),t._v(" 进行抢占。")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func handoffp(_p_ *p) {\n\t// 如果 p 本地有工作或者全局有工作，需要绑定一个 m\n\tif !runqempty(_p_) || sched.runqsize != 0 {\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\n\t// ……………………\n\n\t// 所有其它 p 都在运行 goroutine，说明系统比较忙，需要启动 m\n\tif atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) == 0 && atomic.Cas(&sched.nmspinning, 0, 1) { // TODO: fast atomic\n\t\t// p 没有本地工作，启动一个自旋 m 来找工作\n\t\tstartm(_p_, true)\n\t\treturn\n\t}\n\tlock(&sched.lock)\n\n\t// ……………………\n\n\t// 全局队列有工作\n\tif sched.runqsize != 0 {\n\t\tunlock(&sched.lock)\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\n\t// ……………………\n\n\t// 没有工作要处理，把 p 放入全局空闲队列\n\tpidleput(_p_)\n\tunlock(&sched.lock)\n}\n")])])]),e("p",[e("code",[t._v("handoffp")]),t._v(" 再次进行场景判断，以调用 "),e("code",[t._v("startm")]),t._v(" 启动一个工作线程来绑定 p，使得整体工作继续推进。")]),t._v(" "),e("p",[t._v("当 p 的本地运行队列或全局运行队列里面有待运行的 goroutine，说明还有很多工作要做，调用 "),e("code",[t._v("startm(_p_, false)")]),t._v(" 启动一个 m 来结合 p，继续工作。")]),t._v(" "),e("p",[t._v("当除了当前的 p 外，其他所有的 p 都在运行 goroutine，说明天下太平，每个人都有自己的事做，唯独自己没有。为了全局更快地完成工作，需要启动一个 m，且要使得 m 处于自旋状态，和 p 结合之后，尽快找到工作。")]),t._v(" "),e("p",[t._v("最后，如果实在没有工作要处理，就将 p 放入全局空闲队列里。")]),t._v(" "),e("p",[t._v("我们接着来看 "),e("code",[t._v("startm")]),t._v(" 函数都做了些什么：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// runtime/proc.go\n// \n// 调用 m 来绑定 p，如果没有 m，那就新建一个\n// 如果 p 为空，那就尝试获取一个处于空闲状态的 p，如果找到 p，那就什么都不做\nfunc startm(_p_ *p, spinning bool) {\n\tlock(&sched.lock)\n\tif _p_ == nil {\n\t\t// 没有指定 p 则需要从全局空闲队列中获取一个 p\n\t\t_p_ = pidleget()\n\t\tif _p_ == nil {\n\t\t\tunlock(&sched.lock)\n\t\t\tif spinning {\n\t\t\t\t// 如果找到 p，放弃。还原全局处于自旋状态的 m 的数量\n\t\t\t\tif int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {\n\t\t\t\t\tthrow("startm: negative nmspinning")\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 没有空闲的 p，直接返回\n\t\t\treturn\n\t\t}\n\t}\n\n\t// 从 m 空闲队列中获取正处于睡眠之中的工作线程，\n\t// 所有处于睡眠状态的 m 都在此队列中\n\tmp := mget()\n\tunlock(&sched.lock)\n\tif mp == nil {\n\t\t// 如果没有找到 m\n\t\tvar fn func()\n\t\tif spinning {\n\t\t\t// The caller incremented nmspinning, so set m.spinning in the new M.\n\t\t\tfn = mspinning\n\t\t}\n\t\t// 创建新的工作线程\n\t\tnewm(fn, _p_)\n\t\treturn\n\t}\n\tif mp.spinning {\n\t\tthrow("startm: m is spinning")\n\t}\n\tif mp.nextp != 0 {\n\t\tthrow("startm: m has p")\n\t}\n\tif spinning && !runqempty(_p_) {\n\t\tthrow("startm: p has runnable gs")\n\t}\n\t// The caller incremented nmspinning, so set m.spinning in the new M.\n\tmp.spinning = spinning\n\t// 设置 m 马上要结合的 p\n\tmp.nextp.set(_p_)\n\t// 唤醒 m\n\tnotewakeup(&mp.park)\n}\n')])])]),e("p",[t._v("首先处理 p 为空的情况，直接从全局空闲 p 队列里找，如果没找到，则直接返回。如果设置了 spinning 为 true 的话，还需要还原全局的处于自旋状态的 m 的数值："),e("code",[t._v("&sched.nmspinning")]),t._v(" 。")]),t._v(" "),e("p",[t._v("搞定了 p，接下来看 m。先调用 "),e("code",[t._v("mget")]),t._v(" 函数从全局空闲的 m 队列里获取一个 m，如果没找到 m，则要调用 newm 新创建一个 m，并且如果设置了 spinning 为 true 的话，先要设置好 mstartfn：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func mspinning() {\n\t// startm's caller incremented nmspinning. Set the new M's spinning.\n\tgetg().m.spinning = true\n}\n")])])]),e("p",[t._v("这样，启动 m 后，在 mstart1 函数里，进入 schedule 循环前，执行 mstartfn 函数，使得 m 处于自旋状态。")]),t._v(" "),e("p",[t._v("接下来是正常情况下（找到了 p 和 m）的处理：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("mp.spinning = spinning\n// 设置 m 马上要结合的 p\nmp.nextp.set(_p_)\n// 唤醒 m\nnotewakeup(&mp.park)\n")])])]),e("p",[t._v("设置 nextp 为找到的 p，调用 "),e("code",[t._v("notewakeup")]),t._v(" 唤醒 m。之前我们讲 findrunnable 函数的时候，对于最后没有找到工作的 m，我们调用 "),e("code",[t._v("notesleep(&_g_.m.park)")]),t._v("，使得 m 进入睡眠状态。现在终于有工作了，需要老将出山，将其唤醒：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// src/runtime/lock_futex.go\nfunc notewakeup(n *note) {\n\t// 设置 n.key = 1, 被唤醒的线程通过查看该值是否等于 1 \n\t// 来确定是被其它线程唤醒还是意外从睡眠中苏醒\n\told := atomic.Xchg(key32(&n.key), 1)\n\tif old != 0 {\n\t\tprint("notewakeup - double wakeup (", old, ")\\n")\n\t\tthrow("notewakeup - double wakeup")\n\t}\n\tfutexwakeup(key32(&n.key), 1)\n}\n')])])]),e("blockquote",[e("p",[e("code",[t._v("notewakeup")]),t._v(" 函数首先使用 "),e("code",[t._v("atomic.Xchg")]),t._v(" 设置 "),e("code",[t._v("note.key")]),t._v(" 值为 1，这是为了使被唤醒的线程可以通过查看该值是否等于 1 来确定是被其它线程唤醒还是意外从睡眠中苏醒了过来。")])]),t._v(" "),e("blockquote",[e("p",[t._v("如果该值为 1 则表示是被唤醒的，可以继续工作，但如果该值为 0 则表示是意外苏醒，需要再次进入睡眠。")])]),t._v(" "),e("p",[t._v("调用 "),e("code",[t._v("futexwakeup")]),t._v(" 来唤醒工作线程，它和 "),e("code",[t._v("futexsleep")]),t._v(" 是相对的。")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func futexwakeup(addr *uint32, cnt uint32) {\n\t// 调用 futex 函数唤醒工作线程\n\tret := futex(unsafe.Pointer(addr), _FUTEX_WAKE, cnt, nil, nil, 0)\n\tif ret >= 0 {\n\t\treturn\n\t}\n\t\n    // ……………………\n    \n}\n")])])]),e("p",[e("code",[t._v("futex")]),t._v(" 由汇编语言实现，前面已经分析过，这里就不重复了。主要内容就是先准备好参数，然后进行系统调用，由内核唤醒线程。")]),t._v(" "),e("blockquote",[e("p",[t._v("内核在完成唤醒工作之后当前工作线程从内核返回到 futex 函数继续执行 SYSCALL 指令之后的代码并按函数调用链原路返回，继续执行其它代码。")])]),t._v(" "),e("blockquote",[e("p",[t._v("而被唤醒的工作线程则由内核负责在适当的时候调度到 CPU 上运行。")])]),t._v(" "),e("h1",{attrs:{id:"抢占长时间运行的-p"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抢占长时间运行的-p"}},[t._v("#")]),t._v(" 抢占长时间运行的 P")]),t._v(" "),e("p",[t._v("我们知道，Go scheduler 采用的是一种称为协作式的抢占式调度，就是说并不强制调度，大家保持协作关系，互相信任。对于长时间运行的 P，或者说绑定在 P 上的长时间运行的 goroutine，sysmon 会检测到这种情况，然后设置一些标志，表示 goroutine 自己让出 CPU 的执行权，给其他 goroutine 一些机会。")]),t._v(" "),e("p",[t._v("接下来我们就来分析当 P 处于 "),e("code",[t._v("_Prunning")]),t._v(" 状态的情况。"),e("code",[t._v("sysmon")]),t._v(" 扫描每个 p 时，都会记录下当前调度器调度的次数和当前时间，数据记录在结构体：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type sysmontick struct {\n\tschedtick   uint32\n\tschedwhen   int64\n\tsyscalltick uint32\n\tsyscallwhen int64\n}\n")])])]),e("p",[t._v("前面两个字段记录调度器调度的次数和时间，后面两个字段记录系统调用的次数和时间。")]),t._v(" "),e("p",[t._v("在下一次扫描时，对比 sysmon 记录下的 p 的调度次数和时间，与当前 p 自己记录下的调度次数和时间对比，如果一致。说明 P 在这一段时间内一直在运行同一个 goroutine。那就来计算一下运行时间是否太长了。")]),t._v(" "),e("p",[t._v("如果发现运行时间超过了 10 ms，则要调用 "),e("code",[t._v("preemptone(_p_)")]),t._v(" 发起抢占的请求：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func preemptone(_p_ *p) bool {\n\tmp := _p_.m.ptr()\n\tif mp == nil || mp == getg().m {\n\t\treturn false\n\t}\n\t// 被抢占的 goroutine\n\tgp := mp.curg\n\tif gp == nil || gp == mp.g0 {\n\t\treturn false\n\t}\n\n\t// 设置抢占标志\n\tgp.preempt = true\n\n\t// 在 goroutine 内部的每次调用都会比较栈顶指针和 g.stackguard0，\n\t// 来判断是否发生了栈溢出。stackPreempt 非常大的一个数，比任何栈都大\n\t// stackPreempt = 0xfffffade\n\tgp.stackguard0 = stackPreempt\n\treturn true\n}\n")])])]),e("p",[t._v("基本上只是将 stackguard0 设置了一个很大的值，而检查 stackguard0 的地方在函数调用前的一段汇编代码里进行。")]),t._v(" "),e("p",[t._v("举一个简单的例子：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package main\n\nimport "fmt"\n\nfunc main() {\n\tfmt.Println("hello qcrao.com!")\n}\n')])])]),e("p",[t._v("执行命令：")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("go tool compile -S main.go\n")])])]),e("p",[t._v("得到汇编代码：")]),t._v(" "),e("div",{staticClass:"language-asm extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('"".main STEXT size=120 args=0x0 locals=0x48\n\t0x0000 00000 (test26.go:5)\tTEXT\t"".main(SB), $72-0\n    0x0000 00000 (test26.go:5)\tMOVQ\t(TLS), CX\n    0x0009 00009 (test26.go:5)\tCMPQ\tSP, 16(CX)\n    0x000d 00013 (test26.go:5)\tJLS\t113\n    0x000f 00015 (test26.go:5)\tSUBQ\t$72, SP\n\t0x0013 00019 (test26.go:5)\tMOVQ\tBP, 64(SP)\n\t0x0018 00024 (test26.go:5)\tLEAQ\t64(SP), BP\n    0x001d 00029 (test26.go:5)\tFUNCDATA\t$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)\n    0x001d 00029 (test26.go:5)\tFUNCDATA\t$1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)\n\t0x001d 00029 (test26.go:6)\tMOVQ\t$0, ""..autotmp_0+48(SP)\n    0x0026 00038 (test26.go:6)\tMOVQ\t$0, ""..autotmp_0+56(SP)\n\t0x002f 00047 (test26.go:6)\tLEAQ\ttype.string(SB), AX\n\t0x0036 00054 (test26.go:6)\tMOVQ\tAX, ""..autotmp_0+48(SP)\n\t0x003b 00059 (test26.go:6)\tLEAQ\t"".statictmp_0(SB), AX\n\t0x0042 00066 (test26.go:6)\tMOVQ\tAX, ""..autotmp_0+56(SP)\n\t0x0047 00071 (test26.go:6)\tLEAQ\t""..autotmp_0+48(SP), AX\n\t0x004c 00076 (test26.go:6)\tMOVQ\tAX, (SP)\n\t0x0050 00080 (test26.go:6)\tMOVQ\t$1, 8(SP)\n    0x0059 00089 (test26.go:6)\tMOVQ\t$1, 16(SP)\n\t0x0062 00098 (test26.go:6)\tPCDATA\t$0, $1\n\t0x0062 00098 (test26.go:6)\tCALL\tfmt.Println(SB)\n\t0x0067 00103 (test26.go:7)\tMOVQ\t64(SP), BP\n\t0x006c 00108 (test26.go:7)\tADDQ\t$72, SP\n    0x0070 00112 (test26.go:7)\tRET\n    0x0071 00113 (test26.go:7)\tNOP\n    0x0071 00113 (test26.go:5)\tPCDATA\t$0, $-1\n\t0x0071 00113 (test26.go:5)\tCALL\truntime.morestack_noctxt(SB)\n\t0x0076 00118 (test26.go:5)\tJMP\t0\n')])])]),e("p",[t._v("以前看这段代码的时候会直接跳过前面的几行代码，看不懂。这次能看懂了！所以，那些暂时看不懂的，先放一放，没关系，让子弹飞一会儿，很多东西回过头再来看就会豁然开朗，这就是一个很好的例子。")]),t._v(" "),e("div",{staticClass:"language-asm extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("0x0000 00000 (test26.go:5)\tMOVQ\t(TLS), CX\n")])])]),e("p",[t._v("将本地存储 tls 保存到 CX 寄存器中，（TLS）表示它所关联的 g，这里就是前面所讲到的 main gouroutine。")]),t._v(" "),e("div",{staticClass:"language-asm extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("0x0009 00009 (test26.go:5)\tCMPQ\tSP, 16(CX)\n")])])]),e("p",[t._v("比较 SP 寄存器（代表当前 main goroutine 的栈顶寄存器）和 16(CX)，我们看下 g 结构体：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type g struct {\n\t// goroutine 使用的栈\n\tstack       stack   // offset known to runtime/cgo\n\t// 用于栈的扩张和收缩检查\n\tstackguard0 uintptr // offset known to liblink\n\t// ……………………\n}\n")])])]),e("p",[t._v("对象 g 的第一个字段是 stack 结构体：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type stack struct {\n\tlo uintptr\n\thi uintptr\n}\n")])])]),e("p",[t._v("共 16 字节。而 "),e("code",[t._v("16(CX)")]),t._v(" 表示 g 对象的第 16 个字节，跳过了 g 的第一个字段，也就是 "),e("code",[t._v("g.stackguard0")]),t._v(" 字段。")]),t._v(" "),e("p",[t._v("如果 SP 小于 g.stackguard0，这是必然的，因为前面已经把 g.stackguard0 设置成了一个非常大的值，因此跳转到了 113 行。")]),t._v(" "),e("div",{staticClass:"language-asm extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("0x0071 00113 (test26.go:7)\tNOP\n0x0071 00113 (test26.go:5)\tPCDATA\t$0, $-1\n0x0071 00113 (test26.go:5)\tCALL\truntime.morestack_noctxt(SB)\n0x0076 00118 (test26.go:5)\tJMP\t0\n")])])]),e("p",[t._v("调用 "),e("code",[t._v("runtime.morestack_noctxt")]),t._v(" 函数：")]),t._v(" "),e("div",{staticClass:"language-asm extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// src/runtime/asm_amd64.s\nTEXT runtime·morestack_noctxt(SB),NOSPLIT,$0\n\tMOVL\t$0, DX\n\tJMP\truntime·morestack(SB)\n")])])]),e("p",[t._v("直接跳转到 "),e("code",[t._v("morestack")]),t._v(" 函数：")]),t._v(" "),e("div",{staticClass:"language-asm extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("TEXT runtime·morestack(SB),NOSPLIT,$0-0\n    // Cannot grow scheduler stack (m->g0).\n    get_tls(CX)\n    // BX = g，g 表示 main goroutine\n    MOVQ\tg(CX), BX\n    // BX = g.m\n    MOVQ\tg_m(BX), BX\n    // SI = g.m.g0\n    MOVQ\tm_g0(BX), SI\n    CMPQ\tg(CX), SI\n    JNE\t3(PC)\n    CALL\truntime·badmorestackg0(SB)\n    INT\t$3\n\n\t// ……………………\n\n\t// Set g->sched to context in f.\n\t// 将函数的返回地址保存到 AX 寄存器\n\tMOVQ\t0(SP), AX // f's PC\n\t// 将函数的返回地址保存到 g.sched.pc\n\tMOVQ\tAX, (g_sched+gobuf_pc)(SI)\n\t// g.sched.g = g\n\tMOVQ\tSI, (g_sched+gobuf_g)(SI)\n\t// 取地址操作符，调用 morestack_noctxt 之前的 rsp\n\tLEAQ\t8(SP), AX // f's SP\n\t// 将 main 函数的栈顶地址保存到 g.sched.sp\n\tMOVQ\tAX, (g_sched+gobuf_sp)(SI)\n\t// 将 BP 寄存器保存到 g.sched.bp\n\tMOVQ\tBP, (g_sched+gobuf_bp)(SI)\n\t// newstack will fill gobuf.ctxt.\n\n\t// Call newstack on m->g0's stack.\n\t// BX = g.m.g0\n\tMOVQ\tm_g0(BX), BX\n\t// 将 g0 保存到本地存储 tls\n\tMOVQ\tBX, g(CX)\n\t// 把 g0 栈的栈顶寄存器的值恢复到 CPU 的寄存器 SP，达到切换栈的目的，下面这一条指令执行之前，\n    // CPU 还是使用的调用此函数的 g 的栈，执行之后 CPU 就开始使用 g0 的栈了\n\tMOVQ\t(g_sched+gobuf_sp)(BX), SP\n\t// 准备参数\n\tPUSHQ\tDX\t// ctxt argument\n\t// 不返回\n\tCALL\truntime·newstack(SB)\n\tMOVQ\t$0, 0x1003\t// crash if newstack returns\n\tPOPQ\tDX\t// keep balance check happy\n\tRET\n")])])]),e("p",[t._v("主要做的工作就是将当前 goroutine，也就是 main goroutine 的和调度相关的信息保存到 g.sched 中，以便在调度到它执行时，可以恢复。")]),t._v(" "),e("p",[t._v("最后，将 g0 的地址保存到 tls 本地存储，并且切到 g0 栈执行之后的代码。继续调用 newstack 函数：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func newstack(ctxt unsafe.Pointer) {\n\t// thisg = g0\n\tthisg := getg()\n\t\n\t// ……………………\n\n\t// gp = main goroutine\n\tgp := thisg.m.curg\n\t// Write ctxt to gp.sched. We do this here instead of in\n\t// morestack so it has the necessary write barrier.\n\tgp.sched.ctxt = ctxt\n\n\t// ……………………\n\n\tmorebuf := thisg.m.morebuf\n\tthisg.m.morebuf.pc = 0\n\tthisg.m.morebuf.lr = 0\n\tthisg.m.morebuf.sp = 0\n\tthisg.m.morebuf.g = 0\n\n\t// 检查 g.stackguard0 是否被设置成抢占标志\n\tpreempt := atomic.Loaduintptr(&gp.stackguard0) == stackPreempt\n\n\tif preempt {\n\t\tif thisg.m.locks != 0 || thisg.m.mallocing != 0 || thisg.m.preemptoff != "" || thisg.m.p.ptr().status != _Prunning {\n\t\t\t// 还原 stackguard0 为正常值，表示我们已经处理过抢占请求了\n\t\t\tgp.stackguard0 = gp.stack.lo + _StackGuard\n\t\t\t// 不抢占，调用 gogo 继续运行当前这个 g，不需要调用 schedule 函数去挑选另一个 goroutine\n\t\t\tgogo(&gp.sched) // never return\n\t\t}\n\t}\n\n\t// ……………………\n\n\tif preempt {\n\t\tif gp == thisg.m.g0 {\n\t\t\tthrow("runtime: preempt g0")\n\t\t}\n\t\tif thisg.m.p == 0 && thisg.m.locks == 0 {\n\t\t\tthrow("runtime: g is running but p is not")\n\t\t}\n\t\t// Synchronize with scang.\n\t\tcasgstatus(gp, _Grunning, _Gwaiting)\n\n\t\t// ……………………\n\n\t\t// Act like goroutine called runtime.Gosched.\n\t\t// 修改为 running，调度起来运行\n\t\tcasgstatus(gp, _Gwaiting, _Grunning)\n\t\t// 调用 gopreempt_m 把 gp 切换出去\n\t\tgopreempt_m(gp) // never return\n\t}\n\n\t// ……………………\n}\n')])])]),e("p",[t._v("去掉了很多暂时还看不懂的地方，留到后面再研究。只关注有关抢占相关的。第一次判断 preempt 标志是 true 时，检查了 g 的状态，发现不能抢占，例如它所绑定的 P 的状态不是 "),e("code",[t._v("_Prunning")]),t._v("，那就恢复它的 stackguard0 字段，下次就不会走这一套流程了。然后，调用 "),e("code",[t._v("gogo(&gp.sched)")]),t._v(" 继续执行当前的 goroutine。")]),t._v(" "),e("p",[t._v("中间又处理了很多判断流程，再次判断 preempt 标志是 true 时，调用 "),e("code",[t._v("gopreempt_m(gp)")]),t._v(" 将 gp 切换出去。")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func gopreempt_m(gp *g) {\n\tif trace.enabled {\n\t\ttraceGoPreempt()\n\t}\n\tgoschedImpl(gp)\n}\n")])])]),e("p",[t._v("最终调用 "),e("code",[t._v("goschedImpl")]),t._v(" 函数：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func goschedImpl(gp *g) {\n\tstatus := readgstatus(gp)\n\tif status&^_Gscan != _Grunning {\n\t\tdumpgstatus(gp)\n\t\tthrow("bad g status")\n\t}\n\t// 更改 gp 的状态\n\tcasgstatus(gp, _Grunning, _Grunnable)\n\t// 解除 m 和 g 的关系\n\tdropg()\n\tlock(&sched.lock)\n\t// 将 gp 放入全局可运行队列\n\tglobrunqput(gp)\n\tunlock(&sched.lock)\n\n\t// 进入新一轮的调度循环\n\tschedule()\n}\n')])])]),e("p",[t._v("将 gp 的状态改为 "),e("code",[t._v("_Grunnable")]),t._v("，放入全局可运行队列，等待下次有 m 来全局队列找工作时才能继续运行，毕竟你已经运行这么长时间了，给别人一点机会嘛。")]),t._v(" "),e("p",[t._v("最后，调用 "),e("code",[t._v("schedule()")]),t._v(" 函数进入新一轮的调度循环，会找出一个 goroutine 来运行，永不返回。")]),t._v(" "),e("p",[t._v("这样，关于 sysmon 线程在关于调度这块到底做了啥，我们已经回答完了。总结一下：")]),t._v(" "),e("ol",[e("li",[t._v("抢占处于系统调用的 P，让其他 m 接管它，以运行其他的 goroutine。")]),t._v(" "),e("li",[t._v("将运行时间过长的 goroutine 调度出去，给其他 goroutine 运行的机会。")])])])}),[],!1,null,null,null);n.default=a.exports}}]);