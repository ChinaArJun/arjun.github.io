(window.webpackJsonp=window.webpackJsonp||[]).push([[445],{884:function(e,t,v){"use strict";v.r(t);var _=v(44),c=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。")]),e._v(" "),v("p",[e._v("上面说的是发生在多个协程同时读写同一个 map 的情况下。 如果在同一个协程内边遍历边删除，并不会检测到同时读写，理论上是可以这样做的。但是，遍历的结果就可能不会是相同的了，有可能结果遍历结果集中包含了删除的 key，也有可能不包含，这取决于删除 key 的时间：是在遍历到 key 所在的 bucket 时刻前或者后。")]),e._v(" "),v("p",[e._v("一般而言，这可以通过读写锁来解决："),v("code",[e._v("sync.RWMutex")]),e._v("。")]),e._v(" "),v("p",[e._v("读之前调用 "),v("code",[e._v("RLock()")]),e._v(" 函数，读完之后调用 "),v("code",[e._v("RUnlock()")]),e._v(" 函数解锁；写之前调用 "),v("code",[e._v("Lock()")]),e._v(" 函数，写完之后，调用 "),v("code",[e._v("Unlock()")]),e._v(" 解锁。")]),e._v(" "),v("p",[e._v("另外，"),v("code",[e._v("sync.Map")]),e._v(" 是线程安全的 map，也可以使用。")])])}),[],!1,null,null,null);t.default=c.exports}}]);