(window.webpackJsonp=window.webpackJsonp||[]).push([[453],{892:function(s,n,t){"use strict";t.r(n);var e=t(44),a=Object(e.a)({},(function(){var s=this,n=s.$createElement,t=s._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("前面我们说到，slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。")]),s._v(" "),t("p",[s._v("当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作改变；若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。")]),s._v(" "),t("p",[s._v("值的注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据。为什么能改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，仅管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。")]),s._v(" "),t("p",[s._v("通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 "),t("code",[s._v("s[i]=10")]),s._v(" 这种操作改变 slice 底层数组元素值。")]),s._v(" "),t("p",[s._v("另外，值得注意的是，Go 语言的函数参数传递，只有值传递，没有引用传递。")]),s._v(" "),t("p",[s._v("来看一个代码片段：")]),s._v(" "),t("div",{staticClass:"language-golang extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("package main\n\nfunc main() {\n\ts := []int{1, 1, 1}\n\tf(s)\n\tfmt.Println(s)\n}\n\nfunc f(s []int) {\n\t// i只是一个副本，不能改变s中元素的值\n\t/*for _, i := range s {\n\t\ti++\n\t}\n\t*/\n\n\tfor i := range s {\n\t\ts[i] += 1\n\t}\n}\n")])])]),t("p",[s._v("运行一下，程序输出：")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])])]),t("p",[s._v("果真改变了原始 slice 的底层数据。这里传递的是一个 slice 的副本，在 "),t("code",[s._v("f")]),s._v(" 函数中，"),t("code",[s._v("s")]),s._v(" 只是 "),t("code",[s._v("main")]),s._v(" 函数中 "),t("code",[s._v("s")]),s._v(" 的一个拷贝。在"),t("code",[s._v("f")]),s._v(" 函数内部，对 "),t("code",[s._v("s")]),s._v(" 的作用并不会改变外层 "),t("code",[s._v("main")]),s._v(" 函数的 "),t("code",[s._v("s")]),s._v("。")]),s._v(" "),t("p",[s._v("要想真的改变外层 "),t("code",[s._v("slice")]),s._v("，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。我们再来看一个例子：")]),s._v(" "),t("div",{staticClass:"language-golang extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('package main\n\nimport "fmt"\n\nfunc myAppend(s []int) []int {\n\t// 这里 s 虽然改变了，但并不会影响外层函数的 s\n\ts = append(s, 100)\n\treturn s\n}\n\nfunc myAppendPtr(s *[]int) {\n\t// 会改变外层 s 本身\n\t*s = append(*s, 100)\n\treturn\n}\n\nfunc main() {\n\ts := []int{1, 1, 1}\n\tnewS := myAppend(s)\n\n\tfmt.Println(s)\n\tfmt.Println(newS)\n\n\ts = newS\n\n\tmyAppendPtr(&s)\n\tfmt.Println(s)\n}\n')])])]),t("p",[s._v("运行结果：")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])])]),t("p",[t("code",[s._v("myAppend")]),s._v(" 函数里，虽然改变了 "),t("code",[s._v("s")]),s._v("，但它只是一个值传递，并不会影响外层的 "),t("code",[s._v("s")]),s._v("，因此第一行打印出来的结果仍然是 "),t("code",[s._v("[1 1 1]")]),s._v("。")]),s._v(" "),t("p",[s._v("而 "),t("code",[s._v("newS")]),s._v(" 是一个新的 "),t("code",[s._v("slice")]),s._v("，它是基于 "),t("code",[s._v("s")]),s._v(" 得到的。因此它打印的是追加了一个 "),t("code",[s._v("100")]),s._v(" 之后的结果： "),t("code",[s._v("[1 1 1 100]")]),s._v("。")]),s._v(" "),t("p",[s._v("最后，将 "),t("code",[s._v("newS")]),s._v(" 赋值给了 "),t("code",[s._v("s")]),s._v("，"),t("code",[s._v("s")]),s._v(" 这时才真正变成了一个新的slice。之后，再给 "),t("code",[s._v("myAppendPtr")]),s._v(" 函数传入一个 "),t("code",[s._v("s 指针")]),s._v("，这回它真的被改变了："),t("code",[s._v("[1 1 1 100 100]")]),s._v("。")])])}),[],!1,null,null,null);n.default=a.exports}}]);