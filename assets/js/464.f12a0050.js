(window.webpackJsonp=window.webpackJsonp||[]).push([[464],{903:function(t,n,a){"use strict";a.r(n);var e=a(44),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("我们从一个 "),a("code",[t._v("Hello World")]),t._v(" 的例子开始：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package main\n\nimport "fmt"\n\nfunc main() {\n\tfmt.Println("hello world")\n}\n')])])]),a("p",[t._v("在项目根目录下执行：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("go build -gcflags "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-N -l"')]),t._v(" -o hello src/main.go\n")])])]),a("p",[a("code",[t._v('-gcflags "-N -l"')]),t._v(" 是为了关闭编译器优化和函数内联，防止后面在设置断点的时候找不到相对应的代码位置。")]),t._v(" "),a("p",[t._v("得到了可执行文件 hello，执行：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("qcrao@qcrao hello-world"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("$ gdb hello\n")])])]),a("p",[t._v("进入 gdb 调试模式，执行 "),a("code",[t._v("info files")]),t._v("，得到可执行文件的文件头，列出了各种段：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/60392813-db88d980-9b3d-11e9-8b0f-7c1d845a8191.png",alt:"gdb info"}})]),t._v(" "),a("p",[t._v("同时，我们也得到了入口地址：0x450e20。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("gdb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" b *0x450e20\nBreakpoint "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" at 0x450e20: "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("file")]),t._v(" /usr/local/go/src/runtime/rt0_linux_amd64.s, line "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(".\n")])])]),a("p",[t._v("这就是 Go 程序的入口地址，我是在 linux 上运行的，所以入口文件为 "),a("code",[t._v("src/runtime/rt0_linux_amd64.s")]),t._v("，runtime 目录下有各种不同名称的程序入口文件，支持各种操作系统和架构，代码为：")]),t._v(" "),a("div",{staticClass:"language-asm extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8\n\tLEAQ\t8(SP), SI // argv\n\tMOVQ\t0(SP), DI // argc\n\tMOVQ\t$main(SB), AX\n\tJMP\tAX\n")])])]),a("p",[t._v("主要是把 argc，argv 从内存拉到了寄存器。这里 LEAQ 是计算内存地址，然后把内存地址本身放进寄存器里，也就是把 argv 的地址放到了 SI 寄存器中。最后跳转到：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("TEXT main(SB),NOSPLIT,$-8\n\tMOVQ\t$runtime·rt0_go(SB), AX\n\tJMP\tAX\n")])])]),a("p",[t._v("继续跳转到 "),a("code",[t._v("runtime·rt0_go(SB)")]),t._v("，位置："),a("code",[t._v("/usr/local/go/src/runtime/asm_amd64.s")]),t._v("，代码：")]),t._v(" "),a("div",{staticClass:"language-ams extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("TEXT runtime·rt0_go(SB),NOSPLIT,$0\n    // 省略很多 CPU 相关的特性标志位检查的代码\n    // 主要是看不懂，^_^\n    \n    // ………………………………\n    \n    // 下面是最后调用的一些函数，比较重要\n    // 初始化执行文件的绝对路径\n    CALL\truntime·args(SB)\n    // 初始化 CPU 个数和内存页大小\n\tCALL\truntime·osinit(SB)\n\t// 初始化命令行参数、环境变量、gc、栈空间、内存管理、所有 P 实例、HASH算法等\n\tCALL\truntime·schedinit(SB)\n\n\t// 要在 main goroutine 上运行的函数\n\tMOVQ\t$runtime·mainPC(SB), AX\t\t// entry\n\tPUSHQ\tAX\n\tPUSHQ\t$0\t\t\t// arg size\n\t\n\t// 新建一个 goroutine，该 goroutine 绑定 runtime.main，放在 P 的本地队列，等待调度\n\tCALL\truntime·newproc(SB)\n\tPOPQ\tAX\n\tPOPQ\tAX\n\n    // 启动M，开始调度goroutine\n\tCALL\truntime·mstart(SB)\n\n\tMOVL\t$0xf1, 0xf1  // crash\n\tRET\n\n\t\nDATA\truntime·mainPC+0(SB)/8,$runtime·main(SB)\nGLOBL\truntime·mainPC(SB),RODATA,$8\t\n")])])]),a("p",[t._v("参考文献里的一篇文章【探索 golang 程序启动过程】研究得比较深入，总结下：")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("检查运行平台的CPU，设置好程序运行需要相关标志。")])])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("TLS的初始化。")]),t._v(" "),a("li",[t._v("runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。")]),t._v(" "),a("li",[t._v("runtime.newproc创建新的goroutine用于绑定用户写的main方法。")]),t._v(" "),a("li",[t._v("runtime.mstart开始goroutine的调度。")])]),t._v(" "),a("p",[t._v("最后用一张图来总结 go bootstrap 过程吧：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/60493589-b2a04a00-9cdf-11e9-9c9e-a4b275973f60.png",alt:"golang bootstrap"}})]),t._v(" "),a("p",[t._v("main 函数里执行的一些重要的操作包括：新建一个线程执行 sysmon 函数，定期垃圾回收和调度抢占；启动 gc；执行所有的 init 函数等等。")]),t._v(" "),a("p",[t._v("上面是启动过程，看一下退出过程：")]),t._v(" "),a("blockquote",[a("p",[t._v("当 main 函数执行结束之后，会执行 exit(0) 来退出进程。若执行 exit(0) 后，进程没有退出，main 函数最后的代码会一直访问非法地址：")])]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("exit(0)\nfor {\n\tvar x *int32\n\t*x = 0\n}\n")])])]),a("blockquote",[a("p",[t._v("正常情况下，一旦出现非法地址访问，系统会把进程杀死，用这样的方法确保进程退出。")])]),t._v(" "),a("p",[t._v("关于程序退出这一段的阐述来自群聊《golang runtime 阅读》，又是一个高阶的读源码的组织，github 主页见参考资料。")]),t._v(" "),a("p",[t._v("当然 Go 程序启动这一部分其实还会涉及到 fork 一个新进程、装载可执行文件，控制权转移等问题。还是推荐看前面的两本书，我觉得我不会写得更好，就不叙述了。")])])}),[],!1,null,null,null);n.default=s.exports}}]);