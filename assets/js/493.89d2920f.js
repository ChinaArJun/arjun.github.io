(window.webpackJsonp=window.webpackJsonp||[]).push([[493],{932:function(t,a,r){"use strict";r.r(a);var s=r(44),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"golang面试的一些技术要点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#golang面试的一些技术要点"}},[t._v("#")]),t._v(" golang面试的一些技术要点")]),t._v(" "),r("h3",{attrs:{id:"自我介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自我介绍"}},[t._v("#")]),t._v(" 自我介绍")]),t._v(" "),r("p",[t._v("描述自己的所做过的哪些项目")]),t._v(" "),r("h3",{attrs:{id:"http"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),r("p",[t._v("​")]),t._v(" "),r("h3",{attrs:{id:"https"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),r("h3",{attrs:{id:"tcp的三次握手-四次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp的三次握手-四次挥手"}},[t._v("#")]),t._v(" TCP的三次握手 四次挥手")]),t._v(" "),r("h3",{attrs:{id:"用户端向服务端请求会走哪些流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用户端向服务端请求会走哪些流程"}},[t._v("#")]),t._v(" 用户端向服务端请求会走哪些流程")]),t._v(" "),r("h3",{attrs:{id:"mysql优化-关联表如何优化-如何保持数据的一致性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql优化-关联表如何优化-如何保持数据的一致性"}},[t._v("#")]),t._v(" mysql优化 关联表如何优化 如何保持数据的一致性")]),t._v(" "),r("h3",{attrs:{id:"mysql索引"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引"}},[t._v("#")]),t._v(" mysql索引")]),t._v(" "),r("h3",{attrs:{id:"go多个defer的执行顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#go多个defer的执行顺序"}},[t._v("#")]),t._v(" go多个defer的执行顺序")]),t._v(" "),r("blockquote",[r("p",[t._v("多个defer出现的时候，"),r("strong",[t._v("它是一个“栈”的关系，也就是先进后出")]),t._v("。一个函数中，写在前面的defer会比写在后面的defer调用的晚。")])]),t._v(" "),r("h3",{attrs:{id:"nginx服务负载均衡有哪五种策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#nginx服务负载均衡有哪五种策略"}},[t._v("#")]),t._v(" Nginx服务负载均衡有哪五种策略")]),t._v(" "),r("h3",{attrs:{id:"docker常用操作及命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker常用操作及命令"}},[t._v("#")]),t._v(" docker常用操作及命令")]),t._v(" "),r("h3",{attrs:{id:"如何处理消息队列-rabbitmq和kafka"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何处理消息队列-rabbitmq和kafka"}},[t._v("#")]),t._v(" 如何处理消息队列~ RabbitMQ和Kafka")]),t._v(" "),r("h3",{attrs:{id:"dockerfile常用命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile常用命令"}},[t._v("#")]),t._v(" Dockerfile常用命令")]),t._v(" "),r("h3",{attrs:{id:"docker和虚拟机的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker和虚拟机的区别"}},[t._v("#")]),t._v(" Docker和虚拟机的区别")]),t._v(" "),r("h3",{attrs:{id:"redis数据类型有哪些-常用操作有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis数据类型有哪些-常用操作有哪些"}},[t._v("#")]),t._v(" Redis数据类型有哪些  常用操作有哪些")]),t._v(" "),r("h3",{attrs:{id:"redis雪崩解决方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis雪崩解决方案"}},[t._v("#")]),t._v(" Redis雪崩解决方案")]),t._v(" "),r("h3",{attrs:{id:"shell-需要学习"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#shell-需要学习"}},[t._v("#")]),t._v(" shell ~ 需要学习")]),t._v(" "),r("h3",{attrs:{id:"linux常用命令-rm-ls-cd-ps-mv等等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linux常用命令-rm-ls-cd-ps-mv等等"}},[t._v("#")]),t._v(" Linux常用命令 rm ls cd ps mv等等")]),t._v(" "),r("h3",{attrs:{id:"goroutine传值有几种方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#goroutine传值有几种方式"}},[t._v("#")]),t._v(" goroutine传值有几种方式")]),t._v(" "),r("h3",{attrs:{id:"goroutine详细-grpc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#goroutine详细-grpc"}},[t._v("#")]),t._v(" goroutine详细  gRPC")]),t._v(" "),r("h4",{attrs:{id:"interface接口设计原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#interface接口设计原则"}},[t._v("#")]),t._v(" interface接口设计原则")]),t._v(" "),r("blockquote",[r("p",[t._v("1、interface是方法声明的集合")]),t._v(" "),r("p",[t._v("2、任何类型的对象实现了在interface接口中声明的全部方法，则表明该类型实现了接口。")]),t._v(" "),r("p",[t._v("3、interface可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值。")])]),t._v(" "),r("h3",{attrs:{id:"gmp调度原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gmp调度原理"}},[t._v("#")]),t._v(" GMP调度原理")]),t._v(" "),r("blockquote",[r("p",[t._v("G代表go协程  M代表thread线程  P代表processor处理器")]),t._v(" "),r("p",[t._v("线程中有用户线程(也可以称为协程)和内核线程，他们之间相互绑定")]),t._v(" "),r("p",[t._v("一个线程正常绑定一个协程，在go实现中，可以绑定多个协程，达到多并发的能力")])]),t._v(" "),r("h3",{attrs:{id:"socket通信机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#socket通信机制"}},[t._v("#")]),t._v(" socket通信机制")]),t._v(" "),r("blockquote"),t._v(" "),r("h3",{attrs:{id:"负责的项目"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#负责的项目"}},[t._v("#")]),t._v(" 负责的项目")]),t._v(" "),r("h3",{attrs:{id:"技术博客或github会加分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#技术博客或github会加分"}},[t._v("#")]),t._v(" 技术博客或github会加分")]),t._v(" "),r("h4",{attrs:{id:"算法-手写最长回文字串-需要再多了解几种算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法-手写最长回文字串-需要再多了解几种算法"}},[t._v("#")]),t._v(" 算法 手写最长回文字串 ~ 需要再多了解几种算法")]),t._v(" "),r("h4",{attrs:{id:"拓展-epoll"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#拓展-epoll"}},[t._v("#")]),t._v(" 拓展: epoll")]),t._v(" "),r("h4",{attrs:{id:"consul服务发现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#consul服务发现"}},[t._v("#")]),t._v(" Consul服务发现")]),t._v(" "),r("h4",{attrs:{id:"protobuf"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#protobuf"}},[t._v("#")]),t._v(" Protobuf")]),t._v(" "),r("p",[t._v("Protobuf 的全称是 "),r("a",{attrs:{href:"https://developers.google.com/protocol-buffers/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Protocol Buffers"),r("OutboundLink")],1),t._v("，是 Google 开发的，诞生之初是为了解决服务器端新旧协议（高低版本）兼容性问题，所以取名叫做「协议缓冲区」，现在已经演变为语言中立、平台无关、可扩展的序列化数据的格式，可用于通信协议（尤其是 RPC 通信）、数据存储等。与 XML 和 JSON 相比，Protobuf 更小巧、更快、更简单，一旦定义了要处理的数据结构后（保存在 "),r("code",[t._v(".proto")]),t._v(" 文件中），就可以利用 Protobuf 代码生成工具 "),r("code",[t._v("protoc")]),t._v(" 生成相应的代码，就像我们在"),r("a",{attrs:{href:"https://xueyuanjun.com/post/21015",target:"_blank",rel:"noopener noreferrer"}},[t._v("基于 Go Micro 框架创建第一个微服务接口"),r("OutboundLink")],1),t._v("中所做的那样。此外，只需使用 Protobuf 对数据结构进行一次描述，即可通过不同语言或从不同数据流中对结构化数据进行读写。通过前面对 "),r("a",{attrs:{href:"https://xueyuanjun.com/post/21274",target:"_blank",rel:"noopener noreferrer"}},[t._v("Codec 组件"),r("OutboundLink")],1),t._v("的介绍我们也已经知道，Go Micro 默认的编码格式就是 Protobuf。")]),t._v(" "),r("h4",{attrs:{id:"http里的cookie和session"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http里的cookie和session"}},[t._v("#")]),t._v(" http里的cookie和session")]),t._v(" "),r("h3",{attrs:{id:"go-1-14新版本特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#go-1-14新版本特性"}},[t._v("#")]),t._v(" GO 1.14新版本特性")]),t._v(" "),r("ul",[r("li",[t._v("Go 1.14 defer性能提升")]),t._v(" "),r("li",[t._v("Go 1.14 test 优化")]),t._v(" "),r("li",[t._v("Go1.14 time.Timer定时器性能得到“巨幅”提升")])])])}),[],!1,null,null,null);a.default=e.exports}}]);