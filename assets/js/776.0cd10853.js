(window.webpackJsonp=window.webpackJsonp||[]).push([[776],{1232:function(t,p,a){"use strict";a.r(p);var s=a(44),n=Object(s.a)({},(function(){var t=this,p=t.$createElement,a=t._self._c||p;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"第22章-python字节码-补充内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第22章-python字节码-补充内容"}},[t._v("#")]),t._v(" 第22章 python字节码-补充内容")]),t._v(" "),a("p",[t._v("[toc]")]),t._v(" "),a("h2",{attrs:{id:"python编译过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#python编译过程"}},[t._v("#")]),t._v(" python编译过程")]),t._v(" "),a("p",[t._v("在日常生活中，Python代码一般是不编译的，几个py文件复制来就能用。再加上脚本语言的名头，有些不太了解Python的朋友就以为Python没有编译这个过程。")]),t._v(" "),a("p",[t._v("其实，虽然Python是脚本语言，但它与Java和C#一样，"),a("strong",[a("code",[t._v("只能执行字节码")])]),t._v("。")]),t._v(" "),a("p",[t._v("只是Python将编译过程隐藏起来，不大明显而已。")]),t._v(" "),a("p",[t._v("这一章就详细记述一下Python的编译过程以及一些技巧。")]),t._v(" "),a("p",[a("code",[t._v("这里使用的python版本是3.6.6")])]),t._v(" "),a("h3",{attrs:{id:"py文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#py文件"}},[t._v("#")]),t._v(" py文件")]),t._v(" "),a("p",[a("strong",[t._v("py文件 就是python代码文件")])]),t._v(" "),a("p",[t._v("这里准备两个py文件为下面分析使用")]),t._v(" "),a("p",[t._v("mymodule.py")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyModule")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("say")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Say..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("demo.py")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" mymodule "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" MyModule\n\ntest "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" MyModule"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\ntest"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("say"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("br"),t._v("\n运行demo.py方法在当前目录会产生一个`__pycache__`目录\n"),a("p",[t._v("进入这个目录我们看到里面有个文件mymodule.cpython-36.pyc")]),t._v(" "),a("br"),t._v("\n这里就有两个问题了\n"),a("p",[a("code",[t._v("__pycache__")]),t._v("目录是什么？")]),t._v(" "),a("p",[t._v("pyc文件又是什么？")]),t._v(" "),a("h4",{attrs:{id:"pycache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pycache"}},[t._v("#")]),t._v(" "),a("code",[t._v("__pycache__")])]),t._v(" "),a("p",[a("code",[t._v("__pycache__")]),t._v("是包含编译并准备执行Python 3字节码的目录")]),t._v(" "),a("p",[t._v("当第一次运行 python 脚本时,解释器会将 *.py 脚本进行编译并保存到 "),a("code",[t._v("__pycache__")]),t._v(" 目录")]),t._v(" "),a("p",[a("strong",[t._v("这里有个问题？")])]),t._v(" "),a("p",[t._v("我就写个一个文件，里面就打印一句话，会不会产生pycache目录呢？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('print("hello world")\n')])])]),a("p",[t._v("实验表明：")]),t._v(" "),a("blockquote",[a("p",[t._v("并不会产生这个pycache目录，这个目录只有当**"),a("code",[t._v("import xxx")]),t._v("**才会生成")])]),t._v(" "),a("p",[a("strong",[a("code",[t._v("这个目录能不能删掉呢？删掉有什么影响呢?")])])]),t._v(" "),a("p",[t._v("下次执行脚本时,若解释器发现你的 *.py 脚本没有变更,便会跳过编译一步,直接运行保存在 "),a("code",[t._v("__pycache__")]),t._v("目录下的 *.pyc 文件")]),t._v(" "),a("p",[a("strong",[t._v("执行python脚本会导致字节代码在内存中生成并保持到程序关闭。")])]),t._v(" "),a("p",[a("strong",[t._v("如果导入模块，为了更快的可重用性，Python将创建一个缓存.pyc(PYC是'Python''Compiled')文件，其中导入的模块的字节代码被缓存。")])]),t._v(" "),a("p",[t._v("想法是通过避免在重新导入时重新编译(编译一次，运行多次策略)来加速python模块的加载。")]),t._v(" "),a("p",[t._v("文件名与模块名称相同。\n初始点后面的部分表示创建缓存的Python实现(可能是CPython)，后跟其版本号。")]),t._v(" "),a("p",[t._v("如前面说的mymodule.cpython-36.pyc文件")]),t._v(" "),a("h4",{attrs:{id:"pyc文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pyc文件"}},[t._v("#")]),t._v(" pyc文件")]),t._v(" "),a("p",[t._v("python2 代码 运行是直接在本地产生pyc文件\npython3 代码运行是把pyc文件放在pycache目录")]),t._v(" "),a("p",[t._v(".pyc文件是由.py文件经过编译后生成的字节码文件，其加载速度相对于之前的.py文件有所提高，而且还可以实现源码隐藏，以及一定程度上的反编译")]),t._v(" "),a("p",[t._v("pyc文件，是python编译后的字节码（bytecode）文件。\n只要你运行了py文件，python编译器就会自动生成一个对应的pyc字节码文件。\n这个pyc字节码文件，经过python解释器，会生成机器码运行")]),t._v(" "),a("p",[t._v("下次调用直接调用pyc，而不调用py文件。直到你这个py文件有改变。")]),t._v(" "),a("p",[t._v("python解释器会检查pyc文件中的生成时间，对比py文件的修改时间，如果py更新，那么就生成新的pyc。")]),t._v(" "),a("h4",{attrs:{id:"pyo文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pyo文件"}},[t._v("#")]),t._v(" pyo文件")]),t._v(" "),a("p",[t._v("pyo文件也是优化（注意这两个字，便于后续的理解）编译后的程序（相比于.pyc文件更小），也可以提高加载速度。")]),t._v(" "),a("p",[t._v("但对于嵌入式系统，它可将所需模块编译成.pyo文件以减少容量。  但总的来说，作用上是几乎与原来的.py脚本没有区别的，")]),t._v(" "),a("p",[t._v("在所有的Python选项中：")]),t._v(" "),a("blockquote",[a("p",[t._v("-O，表示优化生成.pyo字节码")])]),t._v(" "),a("blockquote",[a("p",[t._v("-OO，表示进一步移除-O选项生成的字节码文件中的文档字符串")])]),t._v(" "),a("blockquote",[a("p",[t._v("-m，表示导入并运行指定的模块")])]),t._v(" "),a("p",[t._v("执行下面的命令查看是否生成pyo文件")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#py_compile是Python的自带模块")]),t._v("\npython "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("O "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("m py_compile demo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("py\npython "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("OO "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("m py_compile demo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("py\n")])])]),a("p",[t._v("到pycache目录看到生成了cpython-36.opt-1.pyc文件")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Syncma/Figurebed/master/img/1578027718663.png",alt:"Alt text"}})]),t._v(" "),a("p",[t._v("我们发现下面的结果：")]),t._v(" "),a("p",[t._v("1."),a("code",[t._v("咦，说好的生成pyo文件的呢？怎么又生成了pyc文件？")])]),t._v(" "),a("p",[t._v("2.两个pyc文件\n-O 选择生成的是xxxx-1.pyc\n-OO 选项生成的是xxxx-2.pyc")]),t._v(" "),a("p",[a("code",[t._v("这两个pyc又有啥区别呢？")])]),t._v(" "),a("blockquote",[a("p",[t._v("查资料，发现从python3.5+开始就去除了pyo文件后缀名，\n"),a("a",{attrs:{href:"https://www.python.org/dev/peps/pep-0488/",target:"_blank",rel:"noopener noreferrer"}},[t._v("消除pyo文件原文链接"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://www.python.org/dev/peps/pep-3147/",target:"_blank",rel:"noopener noreferrer"}},[t._v("PYC目录链接"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("为啥官方要去除pyo呢？")]),t._v(" "),a("p",[t._v("我读完这两篇文章，简单总结下：")]),t._v(" "),a("p",[t._v("由于pyc 文件在 Python 主要版本之间并不兼容\n所以引入了一种更灵活的替代机制 -pyc")]),t._v(" "),a("p",[t._v("格式包含实现名称和版本号")]),t._v(" "),a("p",[t._v("*.pyc 文件可以表示优化和未优化的字节码。")]),t._v(" "),a("p",[t._v("优化级别信息可以包含在 *.pyc 文件的名字中，")]),t._v(" "),a("p",[t._v("优化级别：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("0: .pyc\n1 (-O): .pyo\n2 (-OO): .pyo\n")])])]),a("h2",{attrs:{id:"python程序执行原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#python程序执行原理"}},[t._v("#")]),t._v(" python程序执行原理")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/Syncma/Figurebed/master/img/1578032890559.png",alt:"Alt text"}})])])}),[],!1,null,null,null);p.default=n.exports}}]);